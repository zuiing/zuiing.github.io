<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="......" type="application/atom+xml">






<meta name="description" content="AlgorithmNotes第三章 入门篇（1）——入门模拟3.1 挖掘机技术哪家强 12345678910111213141516171819const int maxn = 100010;int school[maxn] = &amp;#123; 0 &amp;#125;;int main() &amp;#123;	int n,schID,score;	cin &amp;gt;&amp;gt; n;	while (n--) &amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="......">
<meta property="og:url" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/index.html">
<meta property="og:site_name" content="......">
<meta property="og:description" content="AlgorithmNotes第三章 入门篇（1）——入门模拟3.1 挖掘机技术哪家强 12345678910111213141516171819const int maxn = 100010;int school[maxn] = &amp;#123; 0 &amp;#125;;int main() &amp;#123;	int n,schID,score;	cin &amp;gt;&amp;gt; n;	while (n--) &amp;#12">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/3.1.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章//AlgorithmNotes//说反话.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.1Ranking.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.1Ranking2.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.3字符串hash值.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.3.1permutation.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.3.2nQueens.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.4月饼.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.4组个最小数.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.4区间不相交问题.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.5二分拓展.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.5快速幂.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.7打表.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.7有几个PAT.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.7有几个PAT2.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/4.7随机选择算法.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/5.1数字黑洞.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/5.2辗转相除法.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/5.8n阶乘的问题.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/5.8n阶乘的问题2.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/5.8组合数计算.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/5.8组合数计算2.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/7.1简单计算器.png">
<meta property="og:image" content="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/AlgorithmNotes/7.3静态链表.png">
<meta property="og:updated_time" content="2019-09-22T13:57:51.719Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="......">
<meta name="twitter:description" content="AlgorithmNotes第三章 入门篇（1）——入门模拟3.1 挖掘机技术哪家强 12345678910111213141516171819const int maxn = 100010;int school[maxn] = &amp;#123; 0 &amp;#125;;int main() &amp;#123;	int n,schID,score;	cin &amp;gt;&amp;gt; n;	while (n--) &amp;#12">
<meta name="twitter:image" content="http://yoursite.com/2019/09/22/数据结构与算法/3.1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/">





  <title> | ......</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">......</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天都要开心哦 ^_^</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/数据结构与算法/算法笔记1-7章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/assets/img/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="......">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T09:38:27+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

		
		  <span class="post-meta-divider">|</span>
		  <span id="busuanzi_value_page_pv"></span>次阅读
		

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="AlgorithmNotes"><a href="#AlgorithmNotes" class="headerlink" title="AlgorithmNotes"></a>AlgorithmNotes</h1><h2 id="第三章-入门篇（1）——入门模拟"><a href="#第三章-入门篇（1）——入门模拟" class="headerlink" title="第三章 入门篇（1）——入门模拟"></a>第三章 入门篇（1）——入门模拟</h2><h3 id="3-1-挖掘机技术哪家强"><a href="#3-1-挖掘机技术哪家强" class="headerlink" title="3.1 挖掘机技术哪家强"></a>3.1 挖掘机技术哪家强</h3><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/../3.1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const int maxn = 100010;</span><br><span class="line">int school[maxn] = &#123; 0 &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n,schID,score;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	while (n--) &#123;</span><br><span class="line">		cin &gt;&gt; schID &gt;&gt; score;</span><br><span class="line">		school[schID] += score;</span><br><span class="line">	&#125;</span><br><span class="line">	int idx = 1, max = -1;</span><br><span class="line">	for (int i = 1; i &lt; maxn; i++) &#123;</span><br><span class="line">		if (school[i] &gt; max) &#123;</span><br><span class="line">			idx = i;</span><br><span class="line">			max = school[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; idx &lt;&lt; &quot; &quot; &lt;&lt; max &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-说反话"><a href="#3-2-说反话" class="headerlink" title="3.2 说反话"></a>3.2 说反话</h3><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./\AlgorithmNotes\\说反话.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void reverse(string &amp;s, int l, int r) &#123;</span><br><span class="line">	while (l &lt; r) &#123;</span><br><span class="line">		swap(s[l], s[r]); l++; r--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	string s;</span><br><span class="line">	getline(cin,s);//gets(char* bufer)；</span><br><span class="line">	reverse(s, 0, s.size() - 1);</span><br><span class="line">	for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">		if (s[i] == &apos; &apos;)continue;</span><br><span class="line">		int j = i;</span><br><span class="line">		while (j &lt; s.size() &amp;&amp; s[j] != &apos; &apos;)j++; </span><br><span class="line">		reverse(s, i, j - 1);</span><br><span class="line">		i = j-1;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; s;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="另一种思路：一个单词一个单词的读取，然后倒着打印即可！"><a href="#另一种思路：一个单词一个单词的读取，然后倒着打印即可！" class="headerlink" title="另一种思路：一个单词一个单词的读取，然后倒着打印即可！"></a>另一种思路：一个单词一个单词的读取，然后倒着打印即可！</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;string&gt; v;</span><br><span class="line">	string s;</span><br><span class="line">	while (cin&gt;&gt;s) &#123;//&lt;ctrl+Z&gt;组合键然后按&lt;Enter&gt;键的方式告诉系统已经到了EOF</span><br><span class="line">		v.push_back(s);</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = v.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">		cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四章-入门篇（2）——算法初步"><a href="#第四章-入门篇（2）——算法初步" class="headerlink" title="第四章 入门篇（2）——算法初步"></a>第四章 入门篇（2）——算法初步</h2><h3 id="4-1-PAT-Ranking"><a href="#4-1-PAT-Ranking" class="headerlink" title="4.1 PAT Ranking"></a>4.1 PAT Ranking</h3><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.1Ranking.png" alt></p>
<p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.1Ranking2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">struct Student &#123;</span><br><span class="line">	char id[15];		//准考证号</span><br><span class="line">	int score;			//分数</span><br><span class="line">	int location_number;//考场号</span><br><span class="line">	int local_rank;		//考场内排名</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(const Student &amp;a, const Student &amp;b) &#123;</span><br><span class="line">	if(a.score!=b.score) return a.score &gt; b.score;	//先按分数从高到底排序</span><br><span class="line">	else return strcmp(a.id, b.id) &lt; 0;				//分数相同按准考证号从小到大排序</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, k, num;//num为总考生人数</span><br><span class="line">	vector&lt;Student&gt; stu;</span><br><span class="line">	Student tmp;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; k;</span><br><span class="line">		vector&lt;Student&gt; stuLocal;</span><br><span class="line">		for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">			cin &gt;&gt; tmp.id &gt;&gt; tmp.score;</span><br><span class="line">			tmp.location_number = i;</span><br><span class="line">			stuLocal.push_back(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		sort(stuLocal.begin(), stuLocal.end(), cmp);</span><br><span class="line">		stuLocal[0].local_rank = 1;</span><br><span class="line">		for (int i = 1; i &lt; stuLocal.size(); i++) &#123;</span><br><span class="line">			if (stuLocal[i].score == stuLocal[i - 1].score) stuLocal[i].local_rank = stuLocal[i - 1].local_rank;</span><br><span class="line">			else stuLocal[i].local_rank = i + 1;</span><br><span class="line">		&#125;</span><br><span class="line">		stu.insert(stu.end(), stuLocal.begin(), stuLocal.end());</span><br><span class="line">	&#125;</span><br><span class="line">	sort(stu.begin(), stu.end(),cmp);</span><br><span class="line">	int fin_rank = 1;</span><br><span class="line">	for (int i = 0; i &lt; stu.size(); i++) &#123;</span><br><span class="line">		if (i!=0&amp;&amp;stu[i].score != stu[i - 1].score) fin_rank = i + 1;</span><br><span class="line">		cout &lt;&lt; stu[i].id &lt;&lt; &quot; &quot; &lt;&lt; fin_rank &lt;&lt; &quot; &quot; &lt;&lt; stu[i].location_number &lt;&lt; &quot; &quot; &lt;&lt; stu[i].local_rank &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-散列"><a href="#4-2-散列" class="headerlink" title="4.2 散列"></a>4.2 散列</h3><ul>
<li><p><strong>将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素</strong>。转换函数称为<strong>哈希函数H，</strong>元素转换前为<strong>key</strong>，那么转换后就是一个<strong>整数H(key)</strong>。</p>
</li>
<li><p><strong>常用的散列函数</strong>有直接定址法（即H(key)=key）、平方取中法（取key的平方的中间若干位作为哈希值，很少用）、除留余数法等。</p>
<p><strong>除留余数法</strong>是指把key除以一个数mod得到的余数作为hash值的方法，即<strong>H(key) =key % mod</strong>，当mod是一个素数时，H(key)能尽可能覆盖[0,mod) 范围内的每一个数。</p>
</li>
<li><p>解决法系冲突的方法有：开放定址法（线性探测法、平方探测法、二次哈希法）、链地址法或称拉链法。</p>
<p>链地址法不重新计算新的hash值，而是把所有H(key)相同的key；连接成一条链表，此时可以遍历这条链表来寻找所有H(key) = h的key。</p>
</li>
</ul>
<h4 id="例子：如何将一个二维整点P的坐标映射为一个整数，使得整点P可以由该整数唯一地代表。"><a href="#例子：如何将一个二维整点P的坐标映射为一个整数，使得整点P可以由该整数唯一地代表。" class="headerlink" title="例子：如何将一个二维整点P的坐标映射为一个整数，使得整点P可以由该整数唯一地代表。"></a>例子：如何将一个二维整点P的坐标映射为一个整数，使得整点P可以由该整数唯一地代表。</h4><p>假设一个整点P的坐标是(x,y)，其中0≤x，y≤Range，那么可以令hash函数为H(P) =x*Rang+y，这样对数据范围内的任意两个整点P1与P2，H(P1)都不会等于H(P2)，就可以用H(P)来唯一代表该整点P，接着便可以通过整数hash的方法来进一步映射到较小的范围。</p>
<h4 id="例子：字符串hash——将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S。"><a href="#例子：字符串hash——将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S。" class="headerlink" title="例子：字符串hash——将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S。"></a>例子：字符串hash——将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S。</h4><p>先假设字符串S均由大写字母A-Z组成。不妨把A-Z视为0-25，这样26个大写字母就对应到二十六进制中。接着将二十六进制转换为十进制的思路，由进制转的结论课主，在进制转换过程中，得到的十进制肯定是唯一的，由此便可实现将字符串映射为整数的需求（注意：转换成的整数最大为26^len -1，其中len为字符串长度）。</p>
<p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.3字符串hash值.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const int maxn = 100;</span><br><span class="line">char S[maxn][5], tmp[5];</span><br><span class="line">int hashFunc(char *S, int len) &#123;//S=&quot;abc&quot;</span><br><span class="line">	int id = 0;</span><br><span class="line">	for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">		id = id * 26 + (S[i] - &apos;A&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	return id;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	int hashTable[26 * 26 * 26 + 10] = &#123; 0 &#125;;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; S[i];</span><br><span class="line">		int id = hashFunc(S[i], 3);</span><br><span class="line">		hashTable[id]++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;请输入要查找的字符串:\n&quot;;</span><br><span class="line">	for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		int id = hashFunc(tmp, 3);</span><br><span class="line">		cout &lt;&lt; hashTable[id] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-递归"><a href="#4-3-递归" class="headerlink" title="4.3 递归"></a>4.3 递归</h3><h4 id="4-3-1-全排列"><a href="#4-3-1-全排列" class="headerlink" title="4.3.1 全排列"></a>4.3.1 全排列</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.3.1permutation.png" alt></p>
<p>使用P容器放置当前排列的数，visited容器记录整数i是否已在P中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void Permutation(int pos,int &amp;n,vector&lt;int&gt; &amp;P,vector&lt;bool&gt;&amp; visited) &#123;</span><br><span class="line">	if (pos == n + 1) &#123;</span><br><span class="line">		for (int i = 0; i &lt; n; i++)</span><br><span class="line">			cout &lt;&lt; P[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		if (!visited[i]) &#123;</span><br><span class="line">			visited[i] = true;</span><br><span class="line">			P.push_back(i);</span><br><span class="line">			Permutation(pos + 1, n, P, visited);</span><br><span class="line">			P.pop_back();</span><br><span class="line">			visited[i] = false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt; P;//存储当前排列</span><br><span class="line">	vector&lt;bool&gt; visited(n + 1, false);//记录整数i是否已经在P中</span><br><span class="line">	Permutation(1, n, P, visited);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-n皇后问题"><a href="#4-3-2-n皇后问题" class="headerlink" title="4.3.2 n皇后问题"></a>4.3.2 n皇后问题</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.3.2nQueens.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void Permutation(int pos,int &amp;n,vector&lt;int&gt; &amp;P,vector&lt;bool&gt;&amp; visited,int &amp;res) &#123;</span><br><span class="line">	if (pos == n) &#123;</span><br><span class="line">		int flag = true;</span><br><span class="line">		for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">			for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">				if (abs(i - j) == abs(P[i] - P[j])) &#123;//如果在一条对角线上</span><br><span class="line">					flag = false;//不合法</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (flag) res++;//若当前方案合法，则结果自增1</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		if (!visited[i]) &#123;</span><br><span class="line">			visited[i] = true;</span><br><span class="line">			P.push_back(i);</span><br><span class="line">			Permutation(pos + 1, n, P, visited,res);</span><br><span class="line">			P.pop_back();</span><br><span class="line">			visited[i] = false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, res = 0;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt; P;//存储当前排列</span><br><span class="line">	vector&lt;bool&gt; visited(n + 1, false);//记录整数i是否已经在P中</span><br><span class="line">	Permutation(0, n, P, visited,res);</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述枚举所有情况然后判断是否合法的做法是非常朴素的（暴力法）。一般来说，如果到达递归边界的某层，由于一些事实导致已经不需要往任何一个子问题递归，就可直接返回上一层，一般把这种做法称为回溯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//将n列皇后所在的行号依次写出 比如24135</span><br><span class="line">void Permutation(int pos/*pos从0开始记*/,int &amp;n,vector&lt;int&gt; &amp;P,vector&lt;bool&gt;&amp; visited,int &amp;res) &#123;</span><br><span class="line">	if (pos == n) &#123;</span><br><span class="line">		res++;return;//能到达这里一定是合法的</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;//放置第i行</span><br><span class="line">		if (!visited[i]) &#123;//第i行没有皇后</span><br><span class="line">			bool flag = true;</span><br><span class="line">			for (int j = 0; j &lt; pos; j++) &#123;//遍历之前的皇后</span><br><span class="line">				//第pos列皇后的行号为i，第j列皇后的行号为P[j]</span><br><span class="line">				if (abs(pos - j) == abs(i - P[j])) &#123;</span><br><span class="line">					flag = false; break;//与之前的皇后在一条对角线上，冲突</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (flag) &#123;//如果可以把皇后放在第i行</span><br><span class="line">				visited[i] = true;//第i行已被占</span><br><span class="line">				P.push_back(i);//把第pos列皇后的行号为i</span><br><span class="line">				Permutation(pos + 1, n, P, visited, res);//递归处理第pos+1列皇后</span><br><span class="line">				P.pop_back();</span><br><span class="line">				visited[i] = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, res = 0;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt; P;//存储当前排列</span><br><span class="line">	vector&lt;bool&gt; visited(n + 1, false);//记录整数i是否已经在P中</span><br><span class="line">	Permutation(0, n, P, visited,res);</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="orangered">小结：这种做法和leetCode上的解法略不同，leetCode上是在一个二维数组中记录皇后在每行每列中的位置，而上述题目使用P记录每列的皇后所在的行号，并用visited记录该行是否已经有皇后！！！</font>

<h3 id="4-4-贪心"><a href="#4-4-贪心" class="headerlink" title="4.4 贪心"></a>4.4 贪心</h3><p><strong>总是考虑当前状态下局部最优的策略，来使全局的结果达到最优。</strong></p>
<h4 id="4-4-1-月饼"><a href="#4-4-1-月饼" class="headerlink" title="4.4.1 月饼"></a>4.4.1 月饼</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.4月饼.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct moonCake &#123;</span><br><span class="line">	int store;</span><br><span class="line">	double sell;</span><br><span class="line">	double price;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(moonCake &amp;a, moonCake &amp;b) &#123;</span><br><span class="line">	return a.price &gt; b.price;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	double D;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; D;</span><br><span class="line">	vector&lt;moonCake&gt; cake(n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; cake[i].store;</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; cake[i].sell;</span><br><span class="line">		cake[i].price = cake[i].sell / cake[i].store;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(cake.begin(), cake.end(), cmp);</span><br><span class="line">	double profit = 0;</span><br><span class="line">	int curW = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (curW + cake[i].store &lt;= D) &#123;</span><br><span class="line">			profit += cake[i].sell;</span><br><span class="line">			curW += cake[i].store;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			profit += cake[i].price*(D - curW);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; profit;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-组个最小数"><a href="#4-4-2-组个最小数" class="headerlink" title="4.4.2 组个最小数"></a>4.4.2 组个最小数</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.4组个最小数.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;int&gt; num(10, 0);</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	int i = 1;</span><br><span class="line">	while (num[i] == 0) i++;//找到第一个个数大于0的非0整数，作为最高位</span><br><span class="line">	int res = i; num[i]--;</span><br><span class="line">	for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">		while (num[i]) &#123;</span><br><span class="line">			res = res * 10 + i; num[i]--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-3-区间不相交问题"><a href="#4-4-3-区间不相交问题" class="headerlink" title="4.4.3 区间不相交问题"></a>4.4.3 区间不相交问题</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.4区间不相交问题.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct interval &#123;</span><br><span class="line">	int x, y;//区间左右端点</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(interval &amp;a, interval &amp;b) &#123;</span><br><span class="line">	if(a.x!=b.x) return a.x &gt; b.x;//根据左端点从大到小排序</span><br><span class="line">	else return a.y &lt; b.y;//左端点相同按右端点从小到大的顺序</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	vector&lt;interval&gt; I(n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; I[i].x &gt;&gt; I[i].y;</span><br><span class="line">	sort(I.begin(), I.end(), cmp);</span><br><span class="line">	int res = 1, lastX = I[0].x;//lastX记录上一个被选中区间的左端点</span><br><span class="line">	for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">		if (I[i].y &lt;= lastX) &#123;</span><br><span class="line">			res++; lastX = I[i].x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：总时先选择右端点最小的区间的策略也是可行的！</p>
<h4 id="4-4-4-区间覆盖问题"><a href="#4-4-4-区间覆盖问题" class="headerlink" title="4.4.4 区间覆盖问题"></a>4.4.4 区间覆盖问题</h4><p>问题描述：第一行输入n，L，接下来n行输入n个闭区间[x,y]，求覆盖[0,L]区间需要的最少区间个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">struct interval</span><br><span class="line">&#123;</span><br><span class="line">	int x, y;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp(interval&amp; a, interval&amp; b) &#123;</span><br><span class="line">	if(a.x!=b.x) return a.x &lt; b.x;//按照区间左端点从小到大排列</span><br><span class="line">	else return a.y &gt; b.y;//若左端点相同，则根据右端点从大到小顺序排列</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n, L;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; L;</span><br><span class="line">	vector&lt;interval&gt; I(n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; I[i].x &gt;&gt; I[i].y;</span><br><span class="line">	sort(I.begin(), I.end(), cmp);</span><br><span class="line">	if (I[0].x &gt; 0) &#123; cout &lt;&lt; -1; return 0; &#125;</span><br><span class="line">	int res = 1, left = 0, lastY = 0;//left表示已覆盖区间的右端点，lastY为尝试覆盖区间的右端点 </span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		if (I[i].x &lt;= left) &#123;</span><br><span class="line">			if (I[i].y &gt; lastY) &#123;</span><br><span class="line">				lastY = I[i].y;</span><br><span class="line">				if (lastY &gt;= L) break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (I[i].x &lt;= lastY) &#123;</span><br><span class="line">				if (I[i].y &gt; lastY) &#123;</span><br><span class="line">					left = lastY;</span><br><span class="line">					lastY = I[i].y;</span><br><span class="line">					res++;</span><br><span class="line">					if (lastY &gt;= L) break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				cout &lt;&lt; -1; return 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>动态规划解法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	int n, L;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; L;</span><br><span class="line">	vector&lt;interval&gt; I(n);</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		cin &gt;&gt; I[i].x &gt;&gt; I[i].y;</span><br><span class="line">	vector&lt;int&gt; dp(L + 1, n + 1);</span><br><span class="line">	dp[0] = 0;</span><br><span class="line">	//区间[0,L]</span><br><span class="line">	for (int i = 1; i &lt;= L; ++i) &#123;</span><br><span class="line">		for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">			if (I[j].x &lt; i&amp;&amp;I[j].y &gt;= i) &#123;</span><br><span class="line">				dp[i] = min(dp[I[j].x] + 1, dp[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-二分"><a href="#4-5-二分" class="headerlink" title="4.5 二分"></a>4.5 二分</h3><h4 id="4-5-1-二分查找"><a href="#4-5-1-二分查找" class="headerlink" title="4.5.1 二分查找"></a>4.5.1 二分查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//A为严格递增序列，left为二分下界，right为二分上界，x为欲查询的数</span><br><span class="line">int binarySearch(vector&lt;int&gt; &amp;A, int left, int right, int x) &#123;</span><br><span class="line">	int mid;</span><br><span class="line">	while (left &lt; right) &#123;</span><br><span class="line">		mid = left + (right - left) &gt;&gt; 1;</span><br><span class="line">		if (A[mid] == x) return mid;</span><br><span class="line">		else if (A[mid] &gt; x) right = mid - 1;</span><br><span class="line">		else left = mid + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;//查找失败 返回-1</span><br><span class="line">&#125;</span><br><span class="line">//若递增序列A中的元素可能重复，求出序列中第一个大于等于x的元素的位置L</span><br><span class="line">int lower_bound(vector&lt;int&gt; &amp;A, int left, int right, int x) &#123;</span><br><span class="line">	int mid;</span><br><span class="line">	while (left &lt; right) &#123;</span><br><span class="line">		mid = left + (right - left) &gt;&gt; 1;</span><br><span class="line">		if (A[mid] &gt;= x) right = mid;//第一个大于等于x的元素的位置&lt;=mid</span><br><span class="line">		else left = mid + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br><span class="line">//若递增序列A中的元素可能重复，求出序列中第一个大于x的元素的位置L</span><br><span class="line">int upper_bound(vector&lt;int&gt; &amp;A, int left, int right, int x) &#123;</span><br><span class="line">	int mid;</span><br><span class="line">	while (left &lt; right) &#123;</span><br><span class="line">		mid = left + (right - left) &gt;&gt; 1;</span><br><span class="line">		if (A[mid] &gt; x) right = mid;</span><br><span class="line">		else left = mid + 1;</span><br><span class="line">	&#125;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-2-二分拓展"><a href="#4-5-2-二分拓展" class="headerlink" title="4.5.2 二分拓展"></a>4.5.2 二分拓展</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.5二分拓展.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const double PI = acos(-1.0);</span><br><span class="line">const double eps = 1e-5;//精度为10^-5</span><br><span class="line">double f(double R, double h) &#123;</span><br><span class="line">	double alpha = 2 * acos((R - h) / R);</span><br><span class="line">	double L = 2 * sqrt(R*R - (R - h)*(R - h));</span><br><span class="line">	double S1 = alpha * R*R / 2 - L * (R - h) / 2;</span><br><span class="line">	double S2 = PI * R*R / 2;</span><br><span class="line">	return S1 / S2;</span><br><span class="line">&#125;</span><br><span class="line">double solve(double R, double r) &#123;</span><br><span class="line">	double left = 0, right = R, mid;</span><br><span class="line">	while (right - left &gt; eps) &#123;</span><br><span class="line">		mid = (left + right) / 2;</span><br><span class="line">		if (f(R, mid) &gt; r) right = mid;</span><br><span class="line">		else left = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-5-3-快速幂"><a href="#4-5-3-快速幂" class="headerlink" title="4.5.3 快速幂"></a>4.5.3 快速幂</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.5快速幂.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef long long LL;</span><br><span class="line">LL binaryPow(LL a, LL b, LL m) &#123;</span><br><span class="line">	if (b == 0) return 1;</span><br><span class="line">	if (b &amp; 1) return a * binaryPow(a, b-1, m) % m;</span><br><span class="line">	else &#123;</span><br><span class="line">		LL mul = binaryPow(a, b / 2, m);</span><br><span class="line">		return mul * mul%m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-two-pointers"><a href="#4-6-two-pointers" class="headerlink" title="4.6 two pointers"></a>4.6 two pointers</h3><h4 id="4-6-1-归并排序"><a href="#4-6-1-归并排序" class="headerlink" title="4.6.1 归并排序"></a>4.6.1 归并排序</h4><p>归并排序是一种基于“归并”思想的排序方法，本节主要介绍其中最基本的2-路归并排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const int maxn = 100;</span><br><span class="line">void merge(vector&lt;int&gt; &amp;A, int L, int mid, int R) &#123;</span><br><span class="line">	int i = L, j = mid + 1, idx = 0;//i指向A[L1],j指向A[L2]</span><br><span class="line">	vector&lt;int&gt; tmp(maxn, 0);</span><br><span class="line">	while (i &lt;= mid&amp;&amp;j &lt;= R) &#123;</span><br><span class="line">		if (A[i] &lt; A[j]) tmp[idx++] = A[i++];</span><br><span class="line">		else tmp[idx++] = A[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	while(i&lt;=mid) tmp[idx++] = A[i++];</span><br><span class="line">	while (j &lt;= R)tmp[idx++] = A[j++];</span><br><span class="line">	for (int i = 0; i &lt; idx; i++) &#123;</span><br><span class="line">		A[L + i] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void mergeSort(vector&lt;int&gt;&amp; A, int left, int right) &#123;</span><br><span class="line">	if (left &lt; right) &#123;</span><br><span class="line">		int mid = (left + right) / 2;</span><br><span class="line">		mergeSort(A, left, mid);</span><br><span class="line">		mergeSort(A, mid + 1, right);</span><br><span class="line">		merge(A, left, mid, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-2-快速排序"><a href="#4-6-2-快速排序" class="headerlink" title="4.6.2 快速排序"></a>4.6.2 快速排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int partition(vector&lt;int&gt;&amp; A, int left, int right) &#123;</span><br><span class="line">	int tmp = A[left];</span><br><span class="line">	while (left &lt; right) &#123;</span><br><span class="line">		while (left &lt; right&amp;&amp;A[right] &gt; tmp) right--;</span><br><span class="line">		A[left] = A[right];</span><br><span class="line">		while (left &lt; right&amp;&amp;A[left] &lt;= tmp) left++;</span><br><span class="line">		A[right] = A[left];</span><br><span class="line">	&#125;</span><br><span class="line">	A[left] = tmp;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br><span class="line">void quickSort(vector&lt;int&gt;&amp; A, int left, int right) &#123;</span><br><span class="line">	if (left &lt; right) &#123;</span><br><span class="line">		int pos = partition(A, left, right);</span><br><span class="line">		quickSort(A, left, pos - 1);</span><br><span class="line">		quickSort(A, pos + 1, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-其他高效技巧与算法"><a href="#4-7-其他高效技巧与算法" class="headerlink" title="4.7 其他高效技巧与算法"></a>4.7 其他高效技巧与算法</h3><h4 id="4-7-1-打表"><a href="#4-7-1-打表" class="headerlink" title="4.7.1 打表"></a>4.7.1 打表</h4><p><strong>打表是一种典型的用空间换时间的技巧，一般指将所欲可能需要用到的结果事先计算出来，这样后面需要用到时就可以直接查表获得，打表常见的用法有如下几种：</strong></p>
<p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.7打表.png" alt></p>
<h4 id="4-7-2-活用递推——有几个PAT"><a href="#4-7-2-活用递推——有几个PAT" class="headerlink" title="4.7.2 活用递推——有几个PAT"></a>4.7.2 活用递推——有几个PAT</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.7有几个PAT.png" alt></p>
<p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.7有几个PAT2.png" alt></p>
<font color="orangered">下面将给出两种解决方案，当然上述思路最佳，空间复杂度较小，而另一种dfs则是使用了动态规划的思想。</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">const int maxn = 100010;</span><br><span class="line">const int MOD = 1000000007;</span><br><span class="line">int dp[maxn][3];//第一种解法所用空间</span><br><span class="line">int leftNumP[maxn] = &#123; 0 &#125;;//第二种解法所用空间</span><br><span class="line">/*</span><br><span class="line">dp[i][0]:从下标i开始出现T的个数</span><br><span class="line">dp[i][1]:从下标i开始出现AT的个数</span><br><span class="line">dp[i][2]:从下标i开始出现PAT的个数</span><br><span class="line">*/</span><br><span class="line">void dfs(string&amp; s, int pos) &#123;</span><br><span class="line">	if (pos &lt; 0) return;</span><br><span class="line">	if (s[pos] == &apos;T&apos;) &#123;</span><br><span class="line">		if (pos == s.size() - 1) dp[pos][0] = 1;</span><br><span class="line">		else &#123;</span><br><span class="line">			dp[pos][0] = dp[pos + 1][0] + 1;//更新T</span><br><span class="line">			dp[pos][1] = dp[pos + 1][1];//AT不变</span><br><span class="line">			dp[pos][2] = dp[pos + 1][2];//PAT不变</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (s[pos] == &apos;A&apos;) &#123;</span><br><span class="line">		if (pos &lt; s.size() - 1) &#123;</span><br><span class="line">			dp[pos][0] = dp[pos + 1][0];//T不变</span><br><span class="line">			dp[pos][1] = dp[pos + 1][0]+dp[pos+1][1];//AT更新为：上一位置的T的个数+上一位置AT的个数</span><br><span class="line">			dp[pos][2] = dp[pos + 1][2];//PAT个数不变</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		if (pos &lt; s.size() - 1) &#123;</span><br><span class="line">			dp[pos][0] = dp[pos + 1][0];//T个数不变</span><br><span class="line">			dp[pos][1] = dp[pos + 1][1];//AT个数不变</span><br><span class="line">			dp[pos][2] = (dp[pos + 1][1]+dp[pos+1][2])%MOD;//PAT更新为：上一位置的AT的个数+上一位置PAT的个数</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//cout &lt;&lt; &quot;pos:&quot; &lt;&lt; pos &lt;&lt; &quot;  &quot; &lt;&lt; dp[pos][0] &lt;&lt; &quot;,&quot; &lt;&lt; dp[pos][1] &lt;&lt; &quot;,&quot; &lt;&lt; dp[pos][2] &lt;&lt; endl;</span><br><span class="line">	dfs(s, pos - 1);</span><br><span class="line">&#125;</span><br><span class="line">int solve(string &amp;s) &#123;</span><br><span class="line">	//计算左边P的个数</span><br><span class="line">	for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">		if (i &gt; 0) leftNumP[i] = leftNumP[i - 1];</span><br><span class="line">		if (s[i] == &apos;P&apos;) leftNumP[i]++;</span><br><span class="line">	&#125;</span><br><span class="line">	int res = 0, rightNumT=0;</span><br><span class="line">	for (int i = s.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">		if (s[i] == &apos;T&apos;) rightNumT++;</span><br><span class="line">		else if (s[i] == &apos;A&apos;) &#123;</span><br><span class="line">			res += leftNumP[i] * rightNumT;</span><br><span class="line">			res %= MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin &gt;&gt; s;</span><br><span class="line">	dfs(s, s.size() - 1);</span><br><span class="line">	cout &lt;&lt; dp[0][2] &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; solve(s) &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-7-3-随机选择算法"><a href="#4-7-3-随机选择算法" class="headerlink" title="4.7.3 随机选择算法"></a>4.7.3 随机选择算法</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\4.7随机选择算法.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int randPartition(vector&lt;int&gt;&amp; A, int left, int right) &#123;</span><br><span class="line">	int tmp = A[left];</span><br><span class="line">	while (left &lt; right) &#123;</span><br><span class="line">		while (left&lt;right&amp;&amp;A[right]&gt;tmp) right -- ;</span><br><span class="line">		A[left] = A[right];</span><br><span class="line">		while (left &lt; right&amp;&amp;A[left] &lt;= tmp) left++;</span><br><span class="line">		A[right] = A[left];</span><br><span class="line">	&#125;</span><br><span class="line">	A[left] = tmp;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br><span class="line">int randSelect(vector&lt;int&gt;&amp; A, int left, int right, int K) &#123;</span><br><span class="line">	if (left == right) return A[left];//边界</span><br><span class="line">	int p = randPartition(A, left, right);</span><br><span class="line">	int M = p - left + 1;//A[p]是A[left,right]中的第M大</span><br><span class="line">	if (M == K) return A[p];//找到第K大数字</span><br><span class="line">	else if (M &gt; K) &#123;//第K大的数在主元左侧</span><br><span class="line">		return randSelect(A, left, p - 1, K);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;//第K大的数在主元右侧</span><br><span class="line">		return randSelect(A, p + 1, right, K - M);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;int&gt; A = &#123; 12,34,3,5,7,2,76,35,10 &#125;;</span><br><span class="line">	cout &lt;&lt; randSelect(A, 0, A.size() - 1, 5);//res:10</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第五章-入门篇（3）——数学问题"><a href="#第五章-入门篇（3）——数学问题" class="headerlink" title="第五章 入门篇（3）——数学问题"></a>第五章 入门篇（3）——数学问题</h2><h3 id="5-1-简单数学——数字黑洞"><a href="#5-1-简单数学——数字黑洞" class="headerlink" title="5.1 简单数学——数字黑洞"></a>5.1 简单数学——数字黑洞</h3><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\5.1数字黑洞.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(int a, int b) &#123;</span><br><span class="line">	return a &gt; b;//非递增排序</span><br><span class="line">&#125;</span><br><span class="line">void to_Array(int n, vector&lt;int&gt;&amp; A) &#123;//int整数转成int数组</span><br><span class="line">	for (int i = 3; i &gt;= 0&amp;&amp;n; i--) &#123;</span><br><span class="line">		A[i] = n % 10;</span><br><span class="line">		n /= 10;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int to_int(vector&lt;int&gt;&amp; A) &#123;//int数组转成int整数</span><br><span class="line">	int res = 0;</span><br><span class="line">	for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">		res = res * 10 + A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;int&gt; A(4,0);</span><br><span class="line">	int n; cin &gt;&gt; n;</span><br><span class="line">	int a, b;</span><br><span class="line">	while (1) &#123;</span><br><span class="line">		to_Array(n, A);</span><br><span class="line">		sort(A.begin(), A.end());//非递减排序</span><br><span class="line">		b = to_int(A);</span><br><span class="line">		sort(A.begin(),A.end(), cmp);</span><br><span class="line">		a = to_int(A);</span><br><span class="line">		n = a - b;</span><br><span class="line">		printf(&quot;%04d-%04d=%04d\n&quot;, a, b, n);</span><br><span class="line">		if (n == 0 || n == 6174) break;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-最大公约数和最小公倍数"><a href="#5-2-最大公约数和最小公倍数" class="headerlink" title="5.2 最大公约数和最小公倍数"></a>5.2 最大公约数和最小公倍数</h3><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\5.2辗转相除法.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b) &#123;</span><br><span class="line">	return !b ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-分数的四则运算"><a href="#5-3-分数的四则运算" class="headerlink" title="5.3 分数的四则运算"></a>5.3 分数的四则运算</h3><p><strong>分数的表示：</strong>对于一个分数来说，最简洁的方式就是写成假分数的形式，即无论分子比坟墓大或小，都保留其原数，因此可以用一个结构体存储这种只有分子和分母的分数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Fraction &#123;//分数</span><br><span class="line">	long long up, down;//分子、分母</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-素数"><a href="#5-4-素数" class="headerlink" title="5.4 素数"></a>5.4 素数</h3><h4 id="5-4-1-素数的判断"><a href="#5-4-1-素数的判断" class="headerlink" title="5.4.1 素数的判断"></a>5.4.1 素数的判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool isPrime(int n) &#123;</span><br><span class="line">	if (n &lt; 2) return false;//特判</span><br><span class="line">	int sqr = (int)sqrt(1.0*n);//只需要判断n能够被2,3,...sqrt(n)整数即可</span><br><span class="line">	for (int i = 2; i &lt;= sqr; i++) &#123;</span><br><span class="line">		if (n%i) return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-2-素数表的获取——质数筛"><a href="#5-4-2-素数表的获取——质数筛" class="headerlink" title="5.4.2 素数表的获取——质数筛"></a>5.4.2 素数表的获取——质数筛</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int Era_prime(int n,vector&lt;int&gt;&amp; prime,vector&lt;bool&gt;&amp; isPrime) &#123;//埃筛</span><br><span class="line">	for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">		if (isPrime[i]) &#123;</span><br><span class="line">			prime.push_back(i);</span><br><span class="line">			for (int j = 2 * i; j &lt;= n; j += i)</span><br><span class="line">				isPrime[j] = false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return prime.size();</span><br><span class="line">&#125;//时间复杂度为O(nloglogn) 存在重复筛除</span><br><span class="line">int Euler_prime(int n, vector&lt;int&gt;&amp; prime, vector&lt;bool&gt;&amp; isPrime) &#123;//欧拉筛</span><br><span class="line">	for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">		if (isPrime[i]) prime.push_back(i);</span><br><span class="line">		for (int j = 0; j &lt; prime.size(); j++) &#123;//遍历素数表</span><br><span class="line">			if (i*prime[j] &gt; n) break;//超过最大范围跳出</span><br><span class="line">			isPrime[i*prime[j]] = false;//将倍数i倍*某个质数 筛除</span><br><span class="line">			if (i%prime[j] == 0) break;//保证每个合数只会被它最小的因数筛掉 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return prime.size();</span><br><span class="line">&#125;//时间复杂度为O(n)</span><br><span class="line">int main() &#123;</span><br><span class="line">	int n; cin &gt;&gt; n;</span><br><span class="line">	vector&lt;int&gt; prime;//存储2-n之间的质数</span><br><span class="line">	vector&lt;bool&gt; isPrime(n + 1, true);</span><br><span class="line">	cout &lt;&lt; Era_prime(n, prime, isPrime) &lt;&lt; endl;</span><br><span class="line">	prime.clear();</span><br><span class="line">	cout &lt;&lt; Euler_prime(n, prime, isPrime) &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-5-7-暂时空"><a href="#5-5-5-7-暂时空" class="headerlink" title="5.5 - 5.7 暂时空"></a>5.5 - 5.7 暂时空</h3><h3 id="5-8-组合数"><a href="#5-8-组合数" class="headerlink" title="5.8 组合数"></a>5.8 组合数</h3><h4 id="5-8-1-关于n-的一个问题"><a href="#5-8-1-关于n-的一个问题" class="headerlink" title="5.8.1 关于n!的一个问题"></a>5.8.1 关于n!的一个问题</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\5.8n阶乘的问题.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n,int p) &#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	for (int i = 2; i &lt;= n; i++) &#123;//遍历2-n</span><br><span class="line">		int tmp = i;</span><br><span class="line">		while (tmp%p) &#123;//只要tmp是p的倍数</span><br><span class="line">			res++;</span><br><span class="line">			tmp /= p;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\5.8n阶乘的问题2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n, int p) &#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	while (n)</span><br><span class="line">	&#123;</span><br><span class="line">		res += n / p;//累加n/p^k</span><br><span class="line">		n /= p;//相当于分母多乘一个p</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-8-2-组合数的计算"><a href="#5-8-2-组合数的计算" class="headerlink" title="5.8.2 组合数的计算"></a>5.8.2 组合数的计算</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\5.8组合数计算.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">long long C(long long n, long long m) &#123;</span><br><span class="line">	long long ans = 1;</span><br><span class="line">	for (long long i = 1; i &lt;= n; i++)</span><br><span class="line">		ans *= i;</span><br><span class="line">	for (long long i = 1; i &lt;= m; i++)</span><br><span class="line">		ans /= i;</span><br><span class="line">	for (long long i = 1; i &lt;= n-m; i++)</span><br><span class="line">		ans /= i;</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\5.8组合数计算2.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long long C(long long n, long long m) &#123;</span><br><span class="line">	if (m == 0 || n == m) return 1;</span><br><span class="line">	return C(n - 1, m) + C(n - 1, m - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<font color="orangered">上述计算会产生另一个问题：重复计算。很多C(n,m)是曾经计算过的，不应该重复计算，因此不妨记录下已经计算过的C(n,m),这样下次再遇到就可以作为结果直接返回了。</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">long long res[67][67] = &#123; 0 &#125;;</span><br><span class="line">long long C(long long n, long long m) &#123;//记录中间结果</span><br><span class="line">	if (m == 0 || n == m) return 1;</span><br><span class="line">	if (!res[n][m]) return res[n][m];</span><br><span class="line">	return res[n][m] = C(n - 1, m) + C(n - 1, m - 1);</span><br><span class="line">&#125;</span><br><span class="line">const int n = 60;</span><br><span class="line">long long C2() &#123;//直接把整张表都计算出来的递推代码</span><br><span class="line">	for (int i = 0; i &lt;= n; i++) &#123;</span><br><span class="line">		res[i][0] = res[i][i] = 1;//初始化边界</span><br><span class="line">	&#125;</span><br><span class="line">	for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">		for (int j = 1; j &lt;= i / 2; j++) &#123;</span><br><span class="line">			res[i][j] = res[i - 1][j] + res[i - 1][j - 1];//递推计算C(i,j)</span><br><span class="line">			res[i][i - j] = res[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第六章-C-标准模板库介绍"><a href="#第六章-C-标准模板库介绍" class="headerlink" title="第六章 C++标准模板库介绍"></a>第六章 C++标准模板库介绍</h2><h3 id="6-1-vector的常见用法详解"><a href="#6-1-vector的常见用法详解" class="headerlink" title="6.1 vector的常见用法详解"></a>6.1 vector的常见用法详解</h3><h4 id="6-1-1-vector的定义：可变长数组"><a href="#6-1-1-vector的定义：可变长数组" class="headerlink" title="6.1.1 vector的定义：可变长数组"></a>6.1.1 vector的定义：可变长数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>/<span class="keyword">double</span>/<span class="keyword">char</span>/node&gt; name;<span class="comment">//node是结构体类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; name;<span class="comment">//typename是vector，当作两个维都可变长的二维数组理解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector数组的定义</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; Arrayname[ArraySize];<span class="comment">//一维数组长度已经固定为arraySize，另一维才是边长的 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;&gt; name(ArraySize,<span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;(Size));<span class="comment">//两个维度都固定了，方便初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="6-1-2-vector容器内元素的访问"><a href="#6-1-2-vector容器内元素的访问" class="headerlink" title="6.1.2 vector容器内元素的访问"></a>6.1.2 vector容器内元素的访问</h4><ul>
<li><p>下标访问，同普通数组一样，下标从0-v.size()-1</p>
</li>
<li><p>通过迭代器访问——<strong>v[i]和*(v.begin()+i)是等价的</strong></p>
</li>
</ul>
<h4 id="6-1-3-vector常用函数实例解析"><a href="#6-1-3-vector常用函数实例解析" class="headerlink" title="6.1.3 vector常用函数实例解析"></a>6.1.3 vector常用函数实例解析</h4><ul>
<li>push_back() 在vector后面添加一个元素</li>
<li>pop_back() 删除尾元素</li>
<li>size()获得vector中元素的个数，时间复杂度为O(1)，返回的是unsigned类型</li>
<li>clear()（等价于erase(v.begin(),v.end()) ）清空vector中所有元素，时间复杂度为O(N)，其中N为vector总元素个数</li>
<li>insert(it,x)用来向vector的任意迭代器it前插入一个元素x</li>
<li>erase()有两种用法：删除单个元素、删除一个区间内的所有元素。时间复杂度均为O(N)<ul>
<li>erase(it) 删除迭代器it处的元素</li>
<li>erase(first,last) 删除[first,,last)内的所有元素</li>
</ul>
</li>
</ul>
<h4 id="6-1-4-vector的常见用途"><a href="#6-1-4-vector的常见用途" class="headerlink" title="6.1.4 vector的常见用途"></a>6.1.4 vector的常见用途</h4><ul>
<li>储存数据</li>
<li>用邻接表存储图</li>
</ul>
<h3 id="6-2-set的常见用法详解"><a href="#6-2-set的常见用法详解" class="headerlink" title="6.2 set的常见用法详解"></a>6.2 set的常见用法详解</h3><p>set是一个内部自动有序且不含重复元素的容器。出现要去掉重复元素的情况，而且有可能因这些元素比较大或者类型不是int型而不能直接开散列表，这种情况下就可以用set来保留元素本身而不考虑它的个数。</p>
<h4 id="6-2-1-set的定义"><a href="#6-2-1-set的定义" class="headerlink" title="6.2.1 set的定义"></a>6.2.1 set的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;typername&gt; name;//int,double,char,node,etc.</span><br><span class="line">//set数组的定义和vector相同</span><br><span class="line">set&lt;typename&gt; Arrayname[arraySize];//Arrayname[0]~Arrayname[arraySize-1]中的每一个都是一个set容器</span><br></pre></td></tr></table></figure>
<h4 id="6-2-2-set容器内元素的访问——只能通过迭代器访问"><a href="#6-2-2-set容器内元素的访问——只能通过迭代器访问" class="headerlink" title="6.2.2 set容器内元素的访问——只能通过迭代器访问"></a>6.2.2 set容器内元素的访问——只能通过迭代器访问</h4><font color="orangered"><strong>除了vector和string外的STL容器都不支持*(it+i)的访问方式。</strong></font>

<h4 id="6-2-3-set常用函数解析"><a href="#6-2-3-set常用函数解析" class="headerlink" title="6.2.3 set常用函数解析"></a>6.2.3 set常用函数解析</h4><ul>
<li>insert(x) 将x插入set容器中，并自动递增排序和去重，时间复杂度O(logN)</li>
<li>find(val) 返回set中对应值val的迭代器，时间复杂度O(logN)</li>
<li><p>erase() 有两种用法：删除单个元素、删除一个区间内的所有元素</p>
<ul>
<li>st.erase(it)，it为所需要删除元素的迭代器，时间复杂度O(1),可结合find()来使用；st.erase(val)，val为所要删除元素的值,时间复杂度O(logN)。</li>
<li>st.erase(first,last) 删除[first,last)，其中first、last为迭代器</li>
</ul>
</li>
<li><p>size() 获取set内元素的个数</p>
</li>
<li>clear() 清空set内的元素</li>
</ul>
<h4 id="6-2-4-set的常见用途"><a href="#6-2-4-set的常见用途" class="headerlink" title="6.2.4 set的常见用途"></a>6.2.4 set的常见用途</h4><p>set最主要的作用是自动去重并按升序排列，因此碰到需要去重但是却不方便直接开数组的情况，可以尝试用set解决。</p>
<p>延申：set中元素是唯一的，如果需要处理不唯一的情况，则需要使用multiset。C++11标准中还增加了unordered_set，以散列代替set内部的红黑树，使其可以用来处理只去重但不排序的需求。</p>
<h3 id="6-3-string的常见用法详解"><a href="#6-3-string的常见用法详解" class="headerlink" title="6.3 string的常见用法详解"></a>6.3 string的常见用法详解</h3><h4 id="6-3-1-string的定义"><a href="#6-3-1-string的定义" class="headerlink" title="6.3.1 string的定义"></a>6.3.1 string的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line">string str=&quot;abc&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-2-string中内容的访问"><a href="#6-3-2-string中内容的访问" class="headerlink" title="6.3.2 string中内容的访问"></a>6.3.2 string中内容的访问</h4><ul>
<li>通过下标访问，若要读入/输出整个字符串，则只能用cin和cout</li>
<li>迭代器访问，同vector</li>
</ul>
<h4 id="6-3-3-string常用函数解析"><a href="#6-3-3-string常用函数解析" class="headerlink" title="6.3.3 string常用函数解析"></a>6.3.3 string常用函数解析</h4><ul>
<li>operator+=  这是string的加法，可以将两个string直接拼接起来。</li>
<li>compare operator 两个string类型可以直接使用==、!=、&lt;、≤、＞、≥比较大小，比较规则是字典序。</li>
<li>length()/size() 基本相同，返回存放的字符数，时间复杂度为O(1)。</li>
<li>insert()函数有很多种写法，这里给出几个常用的，时间复杂度为O(N)<ul>
<li>str.insert(pos,str2); 在pos中插入字符串str2</li>
<li>str.insert(it,it2,it3);it为str原字符串的欲插入位置，it2和it3为待插入字符串的首位迭代器，用来表示串[it2,it3)将被插入在it前面</li>
</ul>
</li>
<li><p>erase() 有两种用法：删除单个元素、删除一个区间内的所有元素</p>
<ul>
<li>str.erase(it) it为要删除元素的迭代器</li>
<li>str.erase(first,last)</li>
<li>str.erase(pos,length) pos为需要删除的起始位置，length为删除的字符个数</li>
</ul>
</li>
<li><p>clear() </p>
</li>
<li>substr(pos,len) 返回从pos号开始、长度为len的子串</li>
<li>string::npos 是一个常数，其本身的值为-1，但由于是unsigned_int类型，因此实际上认为是unsigned_int类型的最大值。作为find函数失败时的返回值</li>
<li><p>find() 时间复杂度为O(nm),其中n和m分别是str和str2的长度</p>
<ul>
<li>str.find(str2) 当str2是str的字串时，返回其在str中第一次出现的位置；如果str2不是str的子串，那么返回string::npos</li>
<li>str.find(str2,pos) 从str的pos号开始匹配str2，返回值与上相同</li>
</ul>
</li>
<li><p>replace() 时间复杂度为O(str.length())</p>
<ul>
<li>str.replace(pos,len,str2) 把str从pos号位开始、长度为len的子串替换为str2</li>
<li>str.replace(it1,it2,str2) 把str的迭代器[it1,it2]范围的子串替换为str2</li>
</ul>
</li>
</ul>
<h3 id="6-4-map常用用法详解"><a href="#6-4-map常用用法详解" class="headerlink" title="6.4 map常用用法详解"></a>6.4 map常用用法详解</h3><p>在定义数组时，其实就是定义了一个从int到int型的映射，比如a[0]=25,a[3]=52就分别将0映射到25，将3映射到52；一个double型数组则是将int型映射到double型，但是无论是什么类型，总是将int型映射到其他类型；这似乎表现出一个弊端，当需要其他类型作为关键字来做映射时，会不方便。这时就可以用到map，map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）。</p>
<h4 id="6-4-1-map的定义"><a href="#6-4-1-map的定义" class="headerlink" title="6.4.1 map的定义"></a>6.4.1 map的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt; mp;</span><br><span class="line">map&lt;string,int&gt; mp;//如果是字符串到整型的映射，必须使用string而不能用char数组</span><br><span class="line">map&lt;set&lt;int&gt;,string&gt; mp;//map的键和值也可以是STL容器，例如可以将一个set容器映射到一个字符串</span><br></pre></td></tr></table></figure>
<h4 id="6-4-2-map容器内元素的访问"><a href="#6-4-2-map容器内元素的访问" class="headerlink" title="6.4.2 map容器内元素的访问"></a>6.4.2 map容器内元素的访问</h4><ul>
<li><p>通过下标访问 mp[键]</p>
</li>
<li><p>迭代器访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;typename1,typename2&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<p>map迭代器的使用方式与其他STL容器的迭代器不同，因为map的每一对映射都有两个typename，这决定了必须通过一个it来同时访问键和值。it-&gt;first来访问键，it-&gt;second来访问值。</p>
<p><strong>map会以键从小到大的顺序自动排序。</strong></p>
</li>
</ul>
<h4 id="6-4-3-map常用函数实例解析"><a href="#6-4-3-map常用函数实例解析" class="headerlink" title="6.4.3 map常用函数实例解析"></a>6.4.3 map常用函数实例解析</h4><ul>
<li>find(key) 返回key映射的迭代器，时间复杂度O(logN),N为map中映射的个数</li>
<li><p>erase() 有两种用法：删除单个元素、删除一个区间内的所有元素。</p>
<ul>
<li>mp.erase(it); it为所需删除的元素的迭代器。时间复杂度为O(1)</li>
<li>mp.erase(key); key为欲删除的映射的键。时间复杂度为O(logN)</li>
<li>mp.erase(first,second); 其中first为需要删除的区间的起始迭代器，而last则为需要删除的区间的末尾迭代器的下一个地址,即删除左闭右开的区间[first,last)</li>
</ul>
</li>
<li><p>size() 获取map中映射的对数，时间复杂度为O(1)</p>
</li>
<li>clear() 清空map中的所有元素，复杂度为O(N)</li>
</ul>
<h4 id="6-4-4-map的常见用途"><a href="#6-4-4-map的常见用途" class="headerlink" title="6.4.4 map的常见用途"></a>6.4.4 map的常见用途</h4><ul>
<li>需要建立字符（或字符串）与整数之间映射的题目，使用map可以减少代码量</li>
<li>判断大整数或其他类型数据是否存在的题目，可以把map当bool数组用</li>
<li>字符串和字符串的映射也可能会遇到</li>
</ul>
<blockquote>
<p>map的键和值是唯一的，而如果一个键需要对应多个值，就只能用multimap。C++11标准中还增加了unordered_map，以散列代替map内部的红黑树实现，使其可以只用来处理映射而不按key排序的需求。</p>
</blockquote>
<h3 id="6-5-queue的常见用法详解"><a href="#6-5-queue的常见用法详解" class="headerlink" title="6.5 queue的常见用法详解"></a>6.5 queue的常见用法详解</h3><h4 id="6-5-1-queue的定义"><a href="#6-5-1-queue的定义" class="headerlink" title="6.5.1 queue的定义"></a>6.5.1 queue的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;typename&gt; name;//typename可以实任意基本类型或容器</span><br></pre></td></tr></table></figure>
<h4 id="6-5-2-queue容器内元素的访问"><a href="#6-5-2-queue容器内元素的访问" class="headerlink" title="6.5.2 queue容器内元素的访问"></a>6.5.2 queue容器内元素的访问</h4><ul>
<li>队列本身就是一种先进先出的限制性数据结构，因此在STL中<strong>只能通过font()来访问队首元素，或是通过back()来访问队尾元素</strong>。</li>
</ul>
<h4 id="6-5-3-queue常用函数实例解析"><a href="#6-5-3-queue常用函数实例解析" class="headerlink" title="6.5.3 queue常用函数实例解析"></a>6.5.3 queue常用函数实例解析</h4><ul>
<li><p>push() 入队 时间复杂度O(1)</p>
</li>
<li><p>front(), back() 获得队首和队尾元素，时间复杂度O(1)</p>
</li>
<li>pop() 令队首元素出队，时间复杂度O(1)</li>
<li>empty() 判断队列是否为空</li>
</ul>
<font color="orangered">注意：STL没有实现队列的清空，所以如果需要实现队列的清空，可以用一个while循环反复pop元素。</font>

<h4 id="6-5-4-queue-的常见用途"><a href="#6-5-4-queue-的常见用途" class="headerlink" title="6.5.4 queue 的常见用途"></a>6.5.4 queue 的常见用途</h4><p>当需要实现广度优先搜索时，可以不用自己手动实现一个队列，而是用queue代替。另外使用front和pop函数前，必须用empty()判断队列是否为空。</p>
<h3 id="6-6-priority-queue的常见用法详解"><a href="#6-6-priority-queue的常见用法详解" class="headerlink" title="6.6 priority_queue的常见用法详解"></a>6.6 priority_queue的常见用法详解</h3><p>优先队列，其底层是用堆实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。</p>
<h4 id="6-6-1-priority-queue-的定义"><a href="#6-6-1-priority-queue-的定义" class="headerlink" title="6.6.1 priority_queue 的定义"></a>6.6.1 priority_queue 的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;typename&gt; name;//typename可以实任意基本数据类型或容器</span><br></pre></td></tr></table></figure>
<h4 id="6-6-2-priority-queue容器内元素的访问"><a href="#6-6-2-priority-queue容器内元素的访问" class="headerlink" title="6.6.2 priority_queue容器内元素的访问"></a>6.6.2 priority_queue容器内元素的访问</h4><p>优先队列没有front()和back()函数，只能通过top()函数来访问队首元素，即优先级最高的元素。</p>
<h4 id="6-6-3-priority-queue常用函数实例解析"><a href="#6-6-3-priority-queue常用函数实例解析" class="headerlink" title="6.6.3 priority_queue常用函数实例解析"></a>6.6.3 priority_queue常用函数实例解析</h4><ul>
<li>push(x),将x入队，时间复杂度O(logN),其中N为当前优先队列中元素个数。</li>
<li>top()，获得队首元素，时间复杂度O(1)</li>
<li>pop() 令队首元素出队，时间复杂度O(logN)</li>
<li>empty()检测优先队列是否为空 O(1)</li>
<li>size() 返回优先队列内元素的个数 O(1)</li>
</ul>
<h4 id="6-6-4-priority-queue-内元素优先级的设置"><a href="#6-6-4-priority-queue-内元素优先级的设置" class="headerlink" title="6.6.4 priority_queue 内元素优先级的设置"></a>6.6.4 priority_queue 内元素优先级的设置</h4><ul>
<li><p>基本数据类型的优先级设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int&gt; q;//默认大顶堆，这两种定义是等价的</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;//插入数据进行堆化up：小于的话不交换</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; q;//小顶堆</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体的优先级设置</p>
<p>以水果为例，可以对水果的名称和价格建立一个结构体。希望按水果的价格高的为优先级高，就需要重载”&lt;”。重载是指对已有的运算符重新定义，可以改变小于号的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct fruit&#123;</span><br><span class="line">	string name;</span><br><span class="line">	int price;</span><br><span class="line">	friend bool operator&lt;(fruit f1,fruit f2)&#123;</span><br><span class="line">		return f1.price &lt; f2.price;</span><br><span class="line">		//f1价格小于f2价格的话，就不需要继续向上堆化了，保证价格高的在上面</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;fruit&gt; q;//其内部就是以价格高的水果为优先级高</span><br></pre></td></tr></table></figure>
<p>还有一种写法，把重载的函数写在结构体外面，同时将其用struct包装起来！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct cmp&#123;</span><br><span class="line">	bool operator()(fruit f1,fruit f2)&#123;</span><br><span class="line">		return f1.price &lt; f2.price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//在这种情况下，需要用到之前讲解的第二种定义方式来定义优先队列，只是把greater&lt;&gt;改成了cmp</span><br><span class="line">priority_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; q;</span><br></pre></td></tr></table></figure>
<font color="orangered">若结构体内的数据较为庞大（例如出现了字符串或数组），建议使用引用来提高效率，此时比较类的参数中需要加上const和&amp;。</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">friend bool operator&lt;(const fruit &amp;f1,const fruit &amp;f2)&#123;</span><br><span class="line">	return f1.price &lt; f2.price;</span><br><span class="line">&#125;</span><br><span class="line">bool operator()(const fruit &amp;f1,const fruit &amp;f2)&#123;</span><br><span class="line">	return f1.price &lt; f2.price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-6-5-priority-queue-的常见用途"><a href="#6-6-5-priority-queue-的常见用途" class="headerlink" title="6.6.5 priority_queue 的常见用途"></a>6.6.5 priority_queue 的常见用途</h4><p>可以解决一些贪心问题，也可以对Dijkstra算法进行优化。</p>
<h3 id="6-7-stack的常见用法详解——先进后出"><a href="#6-7-stack的常见用法详解——先进后出" class="headerlink" title="6.7 stack的常见用法详解——先进后出"></a>6.7 stack的常见用法详解——先进后出</h3><h4 id="6-7-1-stack的定义"><a href="#6-7-1-stack的定义" class="headerlink" title="6.7.1 stack的定义"></a>6.7.1 stack的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;typename&gt; name;//typename可以是任意基本数据类型或容器</span><br></pre></td></tr></table></figure>
<h4 id="6-7-2-stack容器内元素的访问"><a href="#6-7-2-stack容器内元素的访问" class="headerlink" title="6.7.2 stack容器内元素的访问"></a>6.7.2 stack容器内元素的访问</h4><p>只能通过top()函数访问栈顶元素。</p>
<h4 id="6-7-3-stack常用函数解析"><a href="#6-7-3-stack常用函数解析" class="headerlink" title="6.7.3 stack常用函数解析"></a>6.7.3 stack常用函数解析</h4><ul>
<li>push(x) 入栈，时间复杂度为O(1)</li>
<li>top() 取栈顶元素，时间复杂度为O(1)</li>
<li>pop() 出栈，时间复杂度为O(1)</li>
<li>empty() 检查栈内是否为空，时间复杂度为O(1)</li>
<li>size() 返回stack内元素的个数，时间复杂度为O(1)</li>
</ul>
<h4 id="6-7-4-stack的常见用途"><a href="#6-7-4-stack的常见用途" class="headerlink" title="6.7.4 stack的常见用途"></a>6.7.4 stack的常见用途</h4><p><strong>用来模拟一些递归，防止程序对栈内存的限制而导致程序运行出错。一般来说，程序的栈内存空间很小，对有些题目来说，如果用普通的函数递归，一旦递归层数过深，则会导致程序崩溃。如果用栈来模拟递归算法的实现，则可以避免这一方面的问题。</strong></p>
<h3 id="6-8-pair的常见用法详解"><a href="#6-8-pair的常见用法详解" class="headerlink" title="6.8 pair的常见用法详解"></a>6.8 pair的常见用法详解</h3><p>pair是个很实用的小东西，当想要将两个元素绑在一起作为一个合成元素、又不想因此定于结构体时，使用pair可以很方便地作为一个代替品。也就是说pair实际上可以看作一个内部有两个元素的结构体。</p>
<h4 id="6-8-1-pair的定义"><a href="#6-8-1-pair的定义" class="headerlink" title="6.8.1 pair的定义"></a>6.8.1 pair的定义</h4><p>使用pair应先添加头文件#include<utility>,并在添加using namespace std;然后就可以使用了。注意：由于map的内部实现中设计pair，因此添加map头文件时会自动添加utility头文件。</utility></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typename1,typename2&gt; name;</span><br><span class="line">pair&lt;string,int&gt; p(&quot;haha&quot;,5);//可以用括号直接初始化</span><br></pre></td></tr></table></figure>
<p>临时构建一个pair，有如下两种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string,int&gt;(&quot;haha&quot;,7);//1.直接用小括号</span><br><span class="line">make_pair(&quot;haha&quot;,7);//2.使用自带的make_pair函数</span><br></pre></td></tr></table></figure>
<h4 id="6-8-2-pair中元素的访问"><a href="#6-8-2-pair中元素的访问" class="headerlink" title="6.8.2 pair中元素的访问"></a>6.8.2 pair中元素的访问</h4><p>pair中只有两个元素，分别是first和second，只需按正常结构体的方式去访问即可。</p>
<h4 id="6-8-3-pair常用函数解析"><a href="#6-8-3-pair常用函数解析" class="headerlink" title="6.8.3 pair常用函数解析"></a>6.8.3 pair常用函数解析</h4><ul>
<li><p><strong>比较操作数</strong></p>
<p>两个pair类型数据可以直接使用==、!=、&lt;=、&gt;=、&gt;、&lt;比较大小，比较规则是现以first大戏哦啊作为标准，只有当first相等时才去判别second的大小。</p>
</li>
</ul>
<h4 id="6-8-4-pair的常见用途"><a href="#6-8-4-pair的常见用途" class="headerlink" title="6.8.4 pair的常见用途"></a>6.8.4 pair的常见用途</h4><ul>
<li><p>用来代替二元结构体及其构造函数，可以节省编码时间</p>
</li>
<li><p>作为map的键值对来进行插入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,int&gt; mp;</span><br><span class="line">mp.insert(make_pair(&quot;haha&quot;,3));</span><br><span class="line">mp.insert(pair&lt;string,int&gt;(&quot;haha&quot;,3));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-9-algorithm头文件下的常用函数"><a href="#6-9-algorithm头文件下的常用函数" class="headerlink" title="6.9 algorithm头文件下的常用函数"></a>6.9 algorithm头文件下的常用函数</h3><p>使用algorithm头文件，需要在头文件下加一行using namespace std;才能正常使用。</p>
<h4 id="6-9-1-max-、min-、abs"><a href="#6-9-1-max-、min-、abs" class="headerlink" title="6.9.1 max()、min()、abs()"></a>6.9.1 max()、min()、abs()</h4><p>abs(x)返回x的绝对值。注意：x必须是整数，浮点型的绝对值需要用math头文件下的fabs。</p>
<h4 id="6-9-2-swap"><a href="#6-9-2-swap" class="headerlink" title="6.9.2 swap()"></a>6.9.2 swap()</h4><h4 id="6-9-3-reverse"><a href="#6-9-3-reverse" class="headerlink" title="6.9.3 reverse()"></a>6.9.3 reverse()</h4><p>reverse(it1,it2)可以将数组指针在[it1,it2)之间的元素或容器的迭代器在[it1,it2)范围内的元素进行翻转。</p>
<h4 id="6-9-4-next-permutation-——给出一个序列在全排列中的下一个序列"><a href="#6-9-4-next-permutation-——给出一个序列在全排列中的下一个序列" class="headerlink" title="6.9.4 next_permutation()——给出一个序列在全排列中的下一个序列"></a>6.9.4 next_permutation()——给出一个序列在全排列中的下一个序列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	char a[] = &#123; &apos;A&apos;,&apos;B&apos;,&apos;C&apos; &#125;;</span><br><span class="line">	do &#123;</span><br><span class="line">		printf(&quot;%c %c %c\n&quot;, a[0], a[1], a[2]);</span><br><span class="line">	&#125; while (next_permutation(a, a + 3));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-9-5-fill"><a href="#6-9-5-fill" class="headerlink" title="6.9.5 fill()"></a>6.9.5 fill()</h4><p>可以把数组或容器中的某一段区间赋值为某个相同的值。和menset不同，这里的赋值可以实数组类型对应范围内的任意值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	char a[4] = &#123; &apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos; &#125;;</span><br><span class="line">	fill(a, a + 4, &apos;#&apos;);//将a[0]-a[3]均赋值为&apos;D&apos;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-9-6-sort"><a href="#6-9-6-sort" class="headerlink" title="6.9.6 sort()"></a>6.9.6 sort()</h4><p>sort在实现过程中规避了经典快速排序中可能出现的会导致实际复杂度退化到O(n^2)的极端情况。不推荐使用qsort()，用起来比较麻烦，涉及很多指针操作。</p>
<ul>
<li><p>如何使用sort函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(首元素地址(必填),尾元素地址的下一个地址(必填),比较函数(非必填));</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何实现比较函数cmp</p>
<ol>
<li><p><strong>基本数据类型数组的排序</strong>：默认升序，若要降序，需要重写cmp函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool cmp(int a,int b)&#123;</span><br><span class="line">	return a&gt;b;//当a&gt;b时（即返回为true时）不交换二者位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结构体数组的排序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct node&#123;</span><br><span class="line">	int x,y;</span><br><span class="line">&#125;ssd[10];</span><br><span class="line">//如果将ssd数组按照x从大到小排序（一级排序），那么可以这样写cmp函数</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	return a.x&gt;b,x;</span><br><span class="line">&#125;</span><br><span class="line">//如果想先按x从大到小排序，但当x相等的情况下，按照y的大小从小到大排序（即进行二级排序）</span><br><span class="line">bool cmp(node a,node b)&#123;</span><br><span class="line">	if(a.x=b.x) return a.x&gt;b.x;</span><br><span class="line">	else return a.y&lt;b.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>容器的排序：在STL容器中，只有vector、string、dequeue是可以使用sort的。</strong>因为map、set这种容器使用红黑树实现的，元素本身有序，故不允许使用sort排序。</p>
</li>
</ol>
</li>
</ul>
<h4 id="6-9-7-lower-bound-和upper-bound-时间复杂度O-log-last-first"><a href="#6-9-7-lower-bound-和upper-bound-时间复杂度O-log-last-first" class="headerlink" title="6.9.7 lower_bound()和upper_bound()  时间复杂度O(log(last-first))"></a>6.9.7 lower_bound()和upper_bound()  时间复杂度O(log(last-first))</h4><ul>
<li>lower_bound(first,last,val)用来寻找数组/容器的[first,last)范围内第一个大于等于cal的元素的位置，返回该位置的指针或迭代器</li>
<li>upper_bound(first,last,val)用来寻找数组/容器的[first,last)范围内第一个大于cal的元素的位置，返回该位置的指针或迭代器</li>
</ul>
<h2 id="第七章-提高篇（1）——数据结构专题（1）"><a href="#第七章-提高篇（1）——数据结构专题（1）" class="headerlink" title="第七章 提高篇（1）——数据结构专题（1）"></a>第七章 提高篇（1）——数据结构专题（1）</h2><h3 id="7-1-栈的应用"><a href="#7-1-栈的应用" class="headerlink" title="7.1 栈的应用"></a>7.1 栈的应用</h3><p><strong>栈顶指针：</strong>是始终指向栈的最上方元素的一个标记，当使用数组实现栈时，栈顶指针是一个int型的变量（数组下标从0开始），通常记为TOP，栈中没有元素时令TOP为-1；而当使用链表实现栈时，则是一个int*型的指针。</p>
<h4 id="7-1-1-简单计算器"><a href="#7-1-1-简单计算器" class="headerlink" title="7.1.1 简单计算器"></a>7.1.1 简单计算器</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\7.1简单计算器.png" alt></p>
<p><strong>计算中缀表达式，主要有两个步骤</strong></p>
<p><strong>步骤一：中缀转后缀提示：</strong></p>
<ol>
<li>操作符的优先级即它们计算的优先级，其中乘法==除法 &gt; 加法==减法，在具体实现中可以一个map建立操作符和优先级的映射，优先级可以用数字表示，乘除优先级为1，加减优先级为0</li>
<li>关于问什么当op高于栈顶时就压入操作符栈？</li>
<li>关于为什么当op等于栈顶时不能直接压入栈顶操作符栈？</li>
<li>本题没有出现括号，如果出现括号，处理方法也很简单，当遇到op操作符时，判断如果是左括号’(‘，就压入操作符栈；如果是右括号’)’，就把操作符栈里的元素不断弹出到后缀表达式直到碰到左括号。</li>
</ol>
<p><strong>步骤二：计算后缀表达式</strong></p>
<p>从左到右扫描后缀表达式，如果是操作数，就压入栈；如果是操作符，就连续弹出两个操作数（注意：后弹出的是第一操作数，先弹出的是第二操作数），然后进行操作符的操作，生成的新操作数压入栈中。反复直到后缀表达式扫描完毕，这时栈中只会存在一个数，就是最终的答案。</p>
<ul>
<li>注意除法可能导致浮点数，因此操作数类型要设成浮点型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">	double num;//操作数</span><br><span class="line">	char op;//操作符</span><br><span class="line">	bool flag;//true表示操作数，false表示操作符</span><br><span class="line">&#125;;</span><br><span class="line">stack&lt;node&gt; s;//操作符栈</span><br><span class="line">queue&lt;node&gt; q;//后缀表达式序列，用数组也可以</span><br><span class="line">map&lt;char, int&gt; op;//操作符优先级</span><br><span class="line">void change(string &amp;str) &#123;</span><br><span class="line">	node tmp;</span><br><span class="line">	for (int i = 0; i &lt; str.size();) &#123;</span><br><span class="line">		if (str[i] &gt;= &apos;0&apos;&amp;&amp;str[i] &lt;= &apos;9&apos;) &#123;//如果是数字</span><br><span class="line">			tmp.flag = true;//标记为操作数</span><br><span class="line">			tmp.num = str[i++] - &apos;0&apos;;</span><br><span class="line">			while (i &lt; str.size() &amp;&amp; str[i] &gt;= &apos;0&apos;&amp;&amp;str[i] &lt;= &apos;9&apos;) &#123;</span><br><span class="line">				tmp.num = tmp.num * 10 + str[i] - &apos;0&apos;;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			q.push(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		else//如果是操作符</span><br><span class="line">		&#123;</span><br><span class="line">			tmp.flag = false;</span><br><span class="line">			//只要栈顶元素大于等于该操作符，就把操作符栈顶元素弹出到后缀表达式的队列中</span><br><span class="line">			while (!s.empty() &amp;&amp; op[str[i]] &lt;= op[s.top().op]) &#123;</span><br><span class="line">				q.push(s.top());</span><br><span class="line">				s.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			tmp.op = str[i];</span><br><span class="line">			s.push(tmp);//把该操作符压入操作符栈中</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//如果操作符栈中还有操作符，就把它弹出到后缀表达式队列中</span><br><span class="line">	while (!s.empty()) &#123;</span><br><span class="line">		q.push(s.top()); s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">double Cal() &#123;</span><br><span class="line">	double tmp1, tmp2;</span><br><span class="line">	node cur,tmp;</span><br><span class="line">	while (!q.empty()) &#123;</span><br><span class="line">		cur = q.front(); q.pop();</span><br><span class="line">		if (cur.flag) s.push(cur);//如果是操作数，直接入栈</span><br><span class="line">		else &#123;//如果是操作符，从栈中弹出两个操作数</span><br><span class="line">			tmp2 = s.top().num; s.pop();//弹出第二操作数</span><br><span class="line">			tmp1 = s.top().num; s.pop();//弹出第一操作数</span><br><span class="line">			tmp.flag = true;</span><br><span class="line">			if (cur.op == &apos;+&apos;) tmp.num = tmp1 + tmp2;</span><br><span class="line">			else if (cur.op == &apos;-&apos;) tmp.num = tmp1 - tmp2;</span><br><span class="line">			else if (cur.op == &apos;*&apos;) tmp.num = tmp1 * tmp2;</span><br><span class="line">			else tmp.num = tmp1 / tmp2;</span><br><span class="line">			s.push(tmp);//把计算的结果压入栈</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return s.top().num;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	op[&apos;*&apos;] = op[&apos;/&apos;] = 1;</span><br><span class="line">	op[&apos;+&apos;] = op[&apos;-&apos;] = 0;</span><br><span class="line">	string str;//30/90-26+97-5-6-13/88*6+61/29+79*87+57*92   res:12178.6</span><br><span class="line">	cin &gt;&gt; str;</span><br><span class="line">	change(str);</span><br><span class="line">	cout &lt;&lt; Cal();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-队列的应用"><a href="#7-2-队列的应用" class="headerlink" title="7.2 队列的应用"></a>7.2 队列的应用</h3><p>队列总是从队尾加入元素，而从对位移除元素，并且满足先进先出的规则。一般来说，需要一个队首指针front来指向队首元素，而使用队尾指针rear来指向队尾元素的下一个位置。和栈类似，当使用数组来实现队列时，队首指针front和队尾指针rear为int变量（数组下标从0开始）；而当使用链表来实现队列时，则为int*型变量的指针。</p>
<h3 id="7-3-链表处理"><a href="#7-3-链表处理" class="headerlink" title="7.3 链表处理"></a>7.3 链表处理</h3><h4 id="7-3-1-链表概念"><a href="#7-3-1-链表概念" class="headerlink" title="7.3.1 链表概念"></a>7.3.1 链表概念</h4><p>线性表是一种很常见的数据结构，分为顺序表和链表。其中顺序表可以简单理解为前面介绍的“数组”，下面将介绍一下链表。</p>
<h4 id="7-3-2-使用malloc函数或new运算符为链表节点分配内存空间"><a href="#7-3-2-使用malloc函数或new运算符为链表节点分配内存空间" class="headerlink" title="7.3.2 使用malloc函数或new运算符为链表节点分配内存空间"></a>7.3.2 使用malloc函数或new运算符为链表节点分配内存空间</h4><ul>
<li><p>malloc函数是C语言中stdlib.h头文件下用于申请动态内存的函数，其返回类型是申请的同类型变量类型的指针。如果申请失败，则会返回空指针NULL。失败一般发生在使用malloc申请了较大的动态数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typename *p=(typename*)malloc(sizeof(typename));</span><br></pre></td></tr></table></figure>
</li>
<li><p>new是C++的写法，比malloc简洁许多，只需要“new+类型名”即可分配一块该类型的内存空间，并返回一个对应类型的指针。如果申请失败，则会启动C++异常机制处理而不是返回空指针NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typename *p=new typename;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内存泄漏——指new或malloc开辟出来的内存空间在使用过后没有释放，导致在其程序结束之前始终占据内存空间，这在一些较大的程序中很容易导致内存消耗过快以致最后无内存可分配。</p>
<ul>
<li>free函数，主要实现了两个效果：释放指针变量p所指向的内存空间；将指针变量p指向空地址NULL。可知，在free执行之后，指针变量p本身并没有消失，只不过它指向了空地址</li>
<li>delete运算符，与free一样new运算符和delete运算符必须成对出现，否则会容易产生内存泄漏。</li>
</ul>
</li>
</ul>
<h4 id="7-3-3-链表的基本操作"><a href="#7-3-3-链表的基本操作" class="headerlink" title="7.3.3 链表的基本操作"></a>7.3.3 链表的基本操作</h4><ul>
<li><strong>创建链表、查找元素、插入元素、删除元素</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;//链表结点</span><br><span class="line">	int data;//数据域</span><br><span class="line">	node* next;//指针域</span><br><span class="line">	node(int val) :data(val) &#123; next = NULL; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">//创建链表（关键函数），根据数组来创建</span><br><span class="line">node* creat(vector&lt;int&gt; &amp;Array) &#123;</span><br><span class="line">	node *head = new node(-1);//创建头节点</span><br><span class="line">	node *p = head, *tmp;</span><br><span class="line">	for (int i = 0; i &lt; Array.size(); i++) &#123;</span><br><span class="line">		tmp = new node(Array[i]);//创建新结点</span><br><span class="line">		p-&gt;next = tmp;//连接到链表中</span><br><span class="line">		p = p-&gt;next;//更新p结点为尾节点</span><br><span class="line">	&#125;</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line">//在以head为头结点的链表上计数元素x的个数</span><br><span class="line">int search(node* head, int x) &#123;</span><br><span class="line">	int res = 0;</span><br><span class="line">	node *p = head-&gt;next;//从第一个结点开始</span><br><span class="line">	while (p) &#123;</span><br><span class="line">		if (p-&gt;data == x) res++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line">//在以head为头结点的链表的第pos个位置上插入x</span><br><span class="line">void insert(node* head, int pos, int x) &#123;</span><br><span class="line">	node *p = head;</span><br><span class="line">	while(--pos) p = p-&gt;next;//找到插入位置的前一个结点</span><br><span class="line">	node *pnew = new node(x);</span><br><span class="line">	pnew-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = pnew;</span><br><span class="line">&#125;</span><br><span class="line">//删除以head为头结点的链表中所有数据域为x的结点</span><br><span class="line">void del(node *head, int x) &#123;</span><br><span class="line">	node *p = head-&gt;next;</span><br><span class="line">	node *pre = head;//用pre保存要删除结点的上一个结点</span><br><span class="line">	while (p) &#123;</span><br><span class="line">		if (p-&gt;data == x) &#123;</span><br><span class="line">			pre-&gt;next = p-&gt;next;</span><br><span class="line">			delete(p);</span><br><span class="line">			p = pre-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			pre = p;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void print(node* head) &#123;</span><br><span class="line">	node* p = head-&gt;next;</span><br><span class="line">	cout &lt;&lt; &quot;print list:\n&quot;;</span><br><span class="line">	while (p) &#123;</span><br><span class="line">		cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	vector&lt;int&gt; Array = &#123; 1,2,2,4,5,6,7 &#125;;</span><br><span class="line">	node *list=creat(Array);</span><br><span class="line">	print(list);</span><br><span class="line">	insert(list, 3, 222);</span><br><span class="line">	print(list);</span><br><span class="line">	del(list, 2);</span><br><span class="line">	print(list);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-3-4-静态链表"><a href="#7-3-4-静态链表" class="headerlink" title="7.3.4 静态链表"></a>7.3.4 静态链表</h4><p><img src="/2019/09/22/数据结构与算法/算法笔记1-7章/./AlgorithmNotes\7.3静态链表.png" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/21/数据结构与算法/算法笔记8-13章/" rel="next" title>
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/assets/img/avatar.jpg" alt="Chris">
            
              <p class="site-author-name" itemprop="name">Chris</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#AlgorithmNotes"><span class="nav-text">AlgorithmNotes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-入门篇（1）——入门模拟"><span class="nav-text">第三章 入门篇（1）——入门模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-挖掘机技术哪家强"><span class="nav-text">3.1 挖掘机技术哪家强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-说反话"><span class="nav-text">3.2 说反话</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#另一种思路：一个单词一个单词的读取，然后倒着打印即可！"><span class="nav-text">另一种思路：一个单词一个单词的读取，然后倒着打印即可！</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-入门篇（2）——算法初步"><span class="nav-text">第四章 入门篇（2）——算法初步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-PAT-Ranking"><span class="nav-text">4.1 PAT Ranking</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-散列"><span class="nav-text">4.2 散列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例子：如何将一个二维整点P的坐标映射为一个整数，使得整点P可以由该整数唯一地代表。"><span class="nav-text">例子：如何将一个二维整点P的坐标映射为一个整数，使得整点P可以由该整数唯一地代表。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子：字符串hash——将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S。"><span class="nav-text">例子：字符串hash——将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-递归"><span class="nav-text">4.3 递归</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-全排列"><span class="nav-text">4.3.1 全排列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-n皇后问题"><span class="nav-text">4.3.2 n皇后问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-贪心"><span class="nav-text">4.4 贪心</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-月饼"><span class="nav-text">4.4.1 月饼</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-组个最小数"><span class="nav-text">4.4.2 组个最小数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-区间不相交问题"><span class="nav-text">4.4.3 区间不相交问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-区间覆盖问题"><span class="nav-text">4.4.4 区间覆盖问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-二分"><span class="nav-text">4.5 二分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-二分查找"><span class="nav-text">4.5.1 二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-二分拓展"><span class="nav-text">4.5.2 二分拓展</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-3-快速幂"><span class="nav-text">4.5.3 快速幂</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-two-pointers"><span class="nav-text">4.6 two pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1-归并排序"><span class="nav-text">4.6.1 归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-2-快速排序"><span class="nav-text">4.6.2 快速排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-其他高效技巧与算法"><span class="nav-text">4.7 其他高效技巧与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1-打表"><span class="nav-text">4.7.1 打表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-2-活用递推——有几个PAT"><span class="nav-text">4.7.2 活用递推——有几个PAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-3-随机选择算法"><span class="nav-text">4.7.3 随机选择算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-入门篇（3）——数学问题"><span class="nav-text">第五章 入门篇（3）——数学问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-简单数学——数字黑洞"><span class="nav-text">5.1 简单数学——数字黑洞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-最大公约数和最小公倍数"><span class="nav-text">5.2 最大公约数和最小公倍数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-分数的四则运算"><span class="nav-text">5.3 分数的四则运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-素数"><span class="nav-text">5.4 素数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1-素数的判断"><span class="nav-text">5.4.1 素数的判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2-素数表的获取——质数筛"><span class="nav-text">5.4.2 素数表的获取——质数筛</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-5-7-暂时空"><span class="nav-text">5.5 - 5.7 暂时空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-8-组合数"><span class="nav-text">5.8 组合数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-8-1-关于n-的一个问题"><span class="nav-text">5.8.1 关于n!的一个问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-8-2-组合数的计算"><span class="nav-text">5.8.2 组合数的计算</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章-C-标准模板库介绍"><span class="nav-text">第六章 C++标准模板库介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-vector的常见用法详解"><span class="nav-text">6.1 vector的常见用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-vector的定义：可变长数组"><span class="nav-text">6.1.1 vector的定义：可变长数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-vector容器内元素的访问"><span class="nav-text">6.1.2 vector容器内元素的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-vector常用函数实例解析"><span class="nav-text">6.1.3 vector常用函数实例解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4-vector的常见用途"><span class="nav-text">6.1.4 vector的常见用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-set的常见用法详解"><span class="nav-text">6.2 set的常见用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-set的定义"><span class="nav-text">6.2.1 set的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-set容器内元素的访问——只能通过迭代器访问"><span class="nav-text">6.2.2 set容器内元素的访问——只能通过迭代器访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-set常用函数解析"><span class="nav-text">6.2.3 set常用函数解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4-set的常见用途"><span class="nav-text">6.2.4 set的常见用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-string的常见用法详解"><span class="nav-text">6.3 string的常见用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-string的定义"><span class="nav-text">6.3.1 string的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-string中内容的访问"><span class="nav-text">6.3.2 string中内容的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-string常用函数解析"><span class="nav-text">6.3.3 string常用函数解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-map常用用法详解"><span class="nav-text">6.4 map常用用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1-map的定义"><span class="nav-text">6.4.1 map的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-map容器内元素的访问"><span class="nav-text">6.4.2 map容器内元素的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-map常用函数实例解析"><span class="nav-text">6.4.3 map常用函数实例解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-4-map的常见用途"><span class="nav-text">6.4.4 map的常见用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-queue的常见用法详解"><span class="nav-text">6.5 queue的常见用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-1-queue的定义"><span class="nav-text">6.5.1 queue的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-2-queue容器内元素的访问"><span class="nav-text">6.5.2 queue容器内元素的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-3-queue常用函数实例解析"><span class="nav-text">6.5.3 queue常用函数实例解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-5-4-queue-的常见用途"><span class="nav-text">6.5.4 queue 的常见用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-priority-queue的常见用法详解"><span class="nav-text">6.6 priority_queue的常见用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-1-priority-queue-的定义"><span class="nav-text">6.6.1 priority_queue 的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-2-priority-queue容器内元素的访问"><span class="nav-text">6.6.2 priority_queue容器内元素的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-3-priority-queue常用函数实例解析"><span class="nav-text">6.6.3 priority_queue常用函数实例解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-4-priority-queue-内元素优先级的设置"><span class="nav-text">6.6.4 priority_queue 内元素优先级的设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-6-5-priority-queue-的常见用途"><span class="nav-text">6.6.5 priority_queue 的常见用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-7-stack的常见用法详解——先进后出"><span class="nav-text">6.7 stack的常见用法详解——先进后出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-1-stack的定义"><span class="nav-text">6.7.1 stack的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-2-stack容器内元素的访问"><span class="nav-text">6.7.2 stack容器内元素的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-3-stack常用函数解析"><span class="nav-text">6.7.3 stack常用函数解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-7-4-stack的常见用途"><span class="nav-text">6.7.4 stack的常见用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-8-pair的常见用法详解"><span class="nav-text">6.8 pair的常见用法详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-8-1-pair的定义"><span class="nav-text">6.8.1 pair的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-8-2-pair中元素的访问"><span class="nav-text">6.8.2 pair中元素的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-8-3-pair常用函数解析"><span class="nav-text">6.8.3 pair常用函数解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-8-4-pair的常见用途"><span class="nav-text">6.8.4 pair的常见用途</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-9-algorithm头文件下的常用函数"><span class="nav-text">6.9 algorithm头文件下的常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-1-max-、min-、abs"><span class="nav-text">6.9.1 max()、min()、abs()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-2-swap"><span class="nav-text">6.9.2 swap()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-3-reverse"><span class="nav-text">6.9.3 reverse()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-4-next-permutation-——给出一个序列在全排列中的下一个序列"><span class="nav-text">6.9.4 next_permutation()——给出一个序列在全排列中的下一个序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-5-fill"><span class="nav-text">6.9.5 fill()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-6-sort"><span class="nav-text">6.9.6 sort()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-9-7-lower-bound-和upper-bound-时间复杂度O-log-last-first"><span class="nav-text">6.9.7 lower_bound()和upper_bound()  时间复杂度O(log(last-first))</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-提高篇（1）——数据结构专题（1）"><span class="nav-text">第七章 提高篇（1）——数据结构专题（1）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-栈的应用"><span class="nav-text">7.1 栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-简单计算器"><span class="nav-text">7.1.1 简单计算器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-队列的应用"><span class="nav-text">7.2 队列的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-链表处理"><span class="nav-text">7.3 链表处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-链表概念"><span class="nav-text">7.3.1 链表概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-使用malloc函数或new运算符为链表节点分配内存空间"><span class="nav-text">7.3.2 使用malloc函数或new运算符为链表节点分配内存空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-3-链表的基本操作"><span class="nav-text">7.3.3 链表的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-4-静态链表"><span class="nav-text">7.3.4 静态链表</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chris</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>


<div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style="display:none">
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style="display:none">
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
