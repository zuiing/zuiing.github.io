<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分治]]></title>
    <url>%2F2019%2F04%2F02%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[给表达式加括号 241.Different Ways to Add Parentheses(Medium)Input: “2-1-1”.((2-1)-1) = 0(2-(1-1)) = 2Output : [0, 2] 题目描述：给出一个可能含有加减乘的表达式，让我们在任意位置添加括号，求出所有可能的表达式的值。 解题思路：以遇到的运算符为界，将表达式分为两部分，分别递归求解。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;input.size();i++)&#123; if(input[i]==&apos;+&apos;||input[i]==&apos;-&apos;||input[i]==&apos;*&apos;)&#123; vector&lt;int&gt; left=diffWaysToCompute(input.substr(0,i));//获得字符串input中从0开始长度为i的字符串 vector&lt;int&gt; right=diffWaysToCompute(input.substr(i+1));//默认时的长度是从开始到尾 for(int j=0;j&lt;left.size();j++)&#123; for(int k=0;k&lt;right.size();k++)&#123; if(input[i]==&apos;+&apos;) res.push_back(left[j]+right[k]); else if(input[i]==&apos;-&apos;) res.push_back(left[j]-right[k]); else res.push_back(left[j]*right[k]); &#125; &#125; &#125; &#125; //若res为空，说明传入的字符串为一个数字，直接将该数字存入结果即可 //c_str()函数返回一个指向正规C字符串的指针常量,atoi()的参数类型是const char* if(res.empty()) res.push_back(atoi(input.c_str())); return res; &#125;&#125;; 上述解法中的递归函数的参数没用指针，这样的话每次调用都要拷贝string对象，如果用指针的化就是直接引用，在leetcode上测试两种方法消耗的内存没差，可能是因为传入的对象本身就不大。 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; if(input.empty()) return &#123;&#125;; return helper(input,0,input.size()-1); &#125;private: vector&lt;int&gt; helper(string&amp; input,int l,int r)&#123; vector&lt;int&gt; res; for(int i=l;i&lt;=r;i++)&#123; if(input[i]==&apos;+&apos;||input[i]==&apos;-&apos;||input[i]==&apos;*&apos;)&#123; vector&lt;int&gt; left=helper(input,l,i-1);//获得字符串input中从0开始长度为i的字符串 vector&lt;int&gt; right=helper(input,i+1,r);//默认时的长度是从开始到尾 for(int j=0;j&lt;left.size();j++)&#123; for(int k=0;k&lt;right.size();k++)&#123; if(input[i]==&apos;+&apos;) res.push_back(left[j]+right[k]); else if(input[i]==&apos;-&apos;) res.push_back(left[j]-right[k]); else res.push_back(left[j]*right[k]); &#125; &#125; &#125; &#125; if(res.empty()) res.push_back(atoi(input.substr(l,r-l+1).c_str())); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心思想]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode%E5%88%B7%E9%A2%98%2F%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[分配饼干 455.Assign Cookies (Easy)Input: [1,2], [1,2,3]Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.You have 3 cookies and their sizes are big enough to gratify all of the children,You need to output 2. 题目描述：每个孩子都有一个满意度，每个饼干斗殴一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。 解题思路：先拿最小的Cookies给胃口最小的孩子，看能否满足，能的话，res自增1，然后再拿下一个Cookies去满足下一位小朋友；如果当前Cookies不能满足当前小朋友，那么就用下一块稍大一些的Cookies去尝试满足当前的小朋友。当Cookies发完了或小朋友都满足了就停止遍历。 123456789101112131415class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(),g.end()); sort(s.begin(),s.end()); int res=0,si=0; while(res&lt;g.size()&amp;&amp;si&lt;s.size())&#123; if(s[si]&gt;=g[res]) res++; si++; &#125; return res; &#125;&#125;; 不重叠的区间个数 435.Non-overlapping Intervals (Medium)Input: [ [1,2], [1,2], [1,2] ] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. 题目描述：计算让一组区间不重叠最少需要移除的区间个数。 解题思路：先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。 在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面的区间个数也就越大。 按区间的结尾进行排序，每次选择结尾最小并且和前一个区间不重叠的区间。 1234567891011121314151617181920212223242526/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: int eraseOverlapIntervals(vector&lt;Interval&gt;&amp; intervals) &#123; if(intervals.size()==0) return 0; sort(intervals.begin(),intervals.end(),[](Interval&amp; a,Interval&amp; b)&#123;return a.end&lt;b.end;&#125;); int res=1; int end=intervals[0].end; for(int i=1;i&lt;intervals.size();i++)&#123; if(intervals[i].start&lt;end) continue; end=intervals[i].end; res++; &#125; return intervals.size()-res; &#125;&#125;; 非递减数组665.Non-decreasing Array(Easy)Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 题目描述：最多有一次修改某个数字的机会，问是否能将数组变为非递减数组。 解题思路：看下面三个例子，4，2，3-1，4，2，32，3，4，2，5观察上面三个例子可以发现，当后面的数字小于前面的数字时，有时只需修改前面较大的数字(如前两个例子)，有时却要修改后面较小的数字(如第3个例子)，规律如下：判断较小的数字与再前面的数字的关系！ 如果再前面的数字不存在，如第一个例子，4前面没有数字了，就直接修改前面的数字为当前的数字2； 若再前面的数字存在，且小于当前数字时(-1&lt;2)，同样的，直接修改前面的数字为当前的数字2就好了； 若再前面的数字存在，但大于当前数字时(3&gt;2)，就需要修改当前的数字为前面的数字； 由于只有一次修改的机会，用一个变量flag，初始化为true，修改数字后变为false，当下次再需要修改时，若flag为false，就直接返回false；遍历结束后返回true。 123456789101112131415161718class Solution &#123;public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; bool flag=true; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i]&lt;nums[i-1])&#123; if(!flag) return false; if(i==1||nums[i]&gt;=nums[i-2]) nums[i-1]=nums[i]; else nums[i]=nums[i-1]; flag=false; &#125; &#125; return true; &#125;&#125;; 买入和售出股票的最大收益121.Best Time to Buy and Sell Stock(Easy)题目描述：只进行一次交易 解题思路：记录前面的最小价格，将这个价格作为买入价格，然后将当前的价格作为售出价格，判断当前收益是否为最大收益。 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0,buy=INT_MAX; for(int i=0;i&lt;prices.size();i++)&#123; buy=min(buy,prices[i]); res=max(res,prices[i]-buy); &#125; return res; &#125;&#125;; 122.Best Time to Buy and Sell Stock II(Easy)题目描述：可以交易无数次，一次股票交易包括买入和卖出，多个交易之间不能交叉。 解题思路：只需要从第二天开始，如果当前价格比昨天价格高，就把差值加入到收益，因为我们可以昨天买入，今天卖出，若明天价更高，还可以今天买入，明天卖出；以此类推。 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0; for(int i=1;i&lt;prices.size();i++)&#123; if(prices[i]&gt;prices[i-1]) res+=prices[i]-prices[i-1]; &#125; return res; &#125;&#125;; 还有股票3问题，需要用到动态规划，就先不写啦！ 子数组最大的和 53.Maximum Subarray(Easy)For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. O(n)时间复杂度解题思路：定义两个变量res和curSum，res保存要返回的结果，curSum保存当前为止求出的数组之和的最大值；每遍历一个数字nums[i],比较curSum+nums[i]和nums[i]中的较大值存入curSum，然后再比较res和curSum的较大值并存入res，以此类推，最后返回res。 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int res=INT_MIN,curSum=0; for(int num:nums)&#123; curSum=max(curSum+num,num); res=max(res,curSum); &#125; return res; &#125;&#125;; O(logn)时间复杂度解题思路：分治法求解，把数组分为两部分，分别求出左边和右边的最大数组之和；然后还要从中间向左右两边分别扫描，找出包含中间元素的最大数组之和；求出包含中间元素的最大值和左右两边得到的最大值中较大的那个。 1234567891011121314151617181920212223242526class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; return helper(nums,0,nums.size()-1); &#125;private: int helper(vector&lt;int&gt;&amp; nums,int l,int r)&#123; if(l&gt;=r) return nums[l]; int m=l+(r-l)/2; int lmax=helper(nums,l,m-1); int rmax=helper(nums,m+1,r); int mmax=nums[m],t=mmax; for(int i=m-1;i&gt;=l;i--)&#123; t+=nums[i]; mmax=max(mmax,t); &#125; t=mmax; for(int i=m+1;i&lt;=r;i++)&#123; t+=nums[i]; mmax=max(mmax,t); &#125; return max(mmax,max(lmax,rmax)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode%E5%88%B7%E9%A2%98%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[求开方 69.Sqrt (Easy)Input: 4Output: 2 Input: 8Output: 2Explanation: The square root of 8 is 2.82842…, and since we want to return an integer, the decimal part will be truncated. 解题思路：利用二分查找在0~x中查找sqrt。对于x=8，它的开方是2.82842…，最后返回2而不是3.再循环条件l&lt;=h并且循环退出时，h总是比l小，即h=2，l=3，因此最后的返回值应该是h而不是l。 1234567891011121314151617class Solution &#123;public: int mySqrt(int x) &#123; if(x==0||x==1) return x; int l=0,h=x; while(l&lt;=h)&#123; int mid=(l+h)&gt;&gt;1; if(mid==x/mid) return mid; else if(mid&gt;x/mid) h=mid-1; else l=mid+1; &#125; return h; &#125;&#125;; 大于给定元素的最小元素 744.Find Smallest Letter Greater Than Target (Easy)题目描述：给定一个有序数组和一个字符，要求找出letters中大于target的最小字符，如果找不到就返回第一个字符。 1234567891011121314class Solution &#123;public: char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; int l=0,h=letters.size()-1; while(l&lt;=h)&#123; int m=l+(h-l)/2; if(letters[m]&lt;=target) l=m+1; else h=m-1; &#125; return l&lt;letters.size()? letters[l]:letters[0]; &#125;&#125;; 有序数组中的单独元素 540.Single Element in a Sorted Array (Medium)Input: [1,1,2,3,3,4,4,8,8]Output: 2 Note: Your solution should run in O(log n) time and O(1) space. 题目描述：题目给了一个有序数组，所有的元素都出现了两次，除了一个元素，让我们找到这个元素。 解题思路： 设index为单独元素在数组中的位置。如果m为偶数，并且m+1&lt;index,那么nums[m]==nums[m+1];m+1&gt;index,那么nums[m]!=nums[m+1]. 从上面的规律可以看出，如果nums[m]==nums[m+1]，那么index所在数组位置为[m+2,h],此时令l=m+2;如果nums[m]!=nums[m+1]，那么index所在数组位置为[l,m],此时令h=m。 解释为什么可以直接取nums[m+1]的值，不用考虑越界？因为如果l与h相等就不会进入循环，所以m一定比h小，一定会有m+1存在。 12345678910111213141516class Solution &#123;public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int l=0,h=nums.size()-1; while(l&lt;h)&#123; int m=l+(h-l)/2; if(m&amp;1) m--;//保证l/m/h均为偶数 if(nums[m]==nums[m+1]) l=m+2; else h=m; &#125; return nums[l];//返回l或h均可 &#125;&#125;; 第一个错误的版本 278.First Bad Version题目描述：给定一个元素n代表有[1,2,3…n]版本，可以调用isBadversion(int x)知道某个版本是否错误，要求找到第一个错误的版本。 解题思路：如果第m个版本出错，则表示第一个错误的版本在[l,m]之间，令h=m；否则第一个错误的版本在[m+1,h]之间，令l=m+1.因为h的赋值表达式为h=m，因此循环条件为l&lt;h,不然可能会死循环。 1234567891011121314151617// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int l=0,h=n; while(l&lt;h)&#123; int m=l+(h-l)/2; if(isBadVersion(m)) h=m; else l=m+1; &#125; return l; &#125;&#125;; 旋转数字的最小数字 153.Find Minimum in Rotated Sorted Array (medium)Input: [3,4,5,1,2],Output: 1 解题思路：如果nums[m]&gt;nums[h],则最小的数字肯定在[m+1,h]之间，令l=m+1;否则，最小的数字在[l,m]之间，令h=m(若nums[m]&lt;nums[h],则m对应的数字肯定在最小数字的右边，即是和最小数字一起被旋转到数组后面的); 123456789101112131415class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int l=0,h=nums.size()-1; while(l&lt;h)&#123; int m=l+(h-l)/2; if(nums[m]&gt;nums[h]) l=m+1; else h=m; &#125; return nums[l]; &#125;&#125;; 查找区间 34.Find First and Last Position of Element in a Sorted Array (Medium)Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 解题思路：定义一个二分查找子函数。若nums[m]&gt;=target,h=m;否则l=m-1;该函数h初始值为nums.size(), 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int first=binarySearch(nums,target); int last=binarySearch(nums,target+1)-1; if(first==nums.size()||nums[first]!=target) return vector&lt;int&gt; &#123;-1,-1&#125;; else&#123; return vector&lt;int&gt; &#123;first,max(first,last)&#125;; &#125; &#125;private: int binarySearch(vector&lt;int&gt;&amp;nums,int target)&#123; int l=0,h=nums.size();//注意，h的初值 while(l&lt;h)&#123; int m=l+(h-l)/2; if(nums[m]&gt;=target) h=m; else l=m+1; &#125; return l; &#125;&#125;; 代码解释：return vector {first,max(first,last)};若改成return vector {first,last};若出现数组中只有一个元素时，会出错，如Input：[1]1Output：[0,-1]Expected：[0,0] 代码解释：int l=0,h=nums.size();若改成h=nums.size()-1;若找不到target时，返回的将是nums.size()-1的值，再减1之后值就不对了，该句代码主要是考虑到target为最后的元素的情况，如：Input:[2,2]2Output:[0,0]Expected:[0,1]]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双指针]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[有序数组的 167.Two Sum IIInput: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 题目描述：在有序数组中找出两个数，使它们的和为 target。 解题思路：使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 如果两个指针指向元素的和sum==target，即返回结果； 如果sum&gt;target，移动较大元素的指针； 如果sum&lt;target，移动较小元素的指针。 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int i=0,j=numbers.size()-1; while(i&lt;j)&#123; if(numbers[i]+numbers[j]==target) return vector&lt;int&gt; &#123;i+1,j+1&#125;; else if(numbers[i]+numbers[j]&lt;target) i++; else j--; &#125; return vector&lt;int&gt;&#123;&#125;; &#125;&#125;; 两数平方和 633.Sum of Square NumbersInput: 5Output: TrueExplanation: 1 1 + 2 2 = 5 题目描述：判断一个数是否为两个数的平方和。 12345678910111213141516class Solution &#123;public: bool judgeSquareSum(int c) &#123; int i=0,j=(int)sqrt(c); while(i&lt;=j)&#123; int powSum=i*i+j*j; if(powSum==c) return true; else if(powSum&lt;c) i++; else j--; &#125; return false; &#125;&#125;; 上述代码超时，无奈又去网上找了其他的解法： 方法二： 由于是求一个数能否由两个数平方之和组成，需要判断两次；从c的平方根开始；先判断如果i i==c,说明c是个平方数，再凑个0就是两数平方之和，返回true；如果不等，那么算出c-ii，如果这个差值也是个平方数的化，返回true；遍历结束后返回false。 123456789101112class Solution &#123;public: bool judgeSquareSum(int c) &#123; for(int i=sqrt(c);i&gt;=0;i--)&#123; if(i*i==c) return true; int t=c-i*i,j=sqrt(t); if(j*j==t) return true; &#125; return false; &#125;&#125;; 方法三： 使用集合set，对于每个i i,都加入集合set中，然后计算c-ii，如果这个差值在集合set中，则返回true，遍历结束返回false。1234567891011121314class Solution &#123;public: bool judgeSquareSum(int c) &#123; unordered_set&lt;int&gt; s; for(int i=0;i&lt;=sqrt(c);i++)&#123; s.insert(i*i); int t=c-i*i; if(s.find(t)!=s.end()) return true; &#125; return false; &#125;&#125;; 翻转字符串的元音字母 345.Reverse Vowels of a StrigGiven s = “leetcode”, return “leotcede”. 使用双指针指向待翻转的两个原因字符，一个从头向尾，一个指针从尾向头。 12345678910111213141516171819202122class Solution &#123;public: string reverseVowels(string s) &#123; int i=0,j=s.size()-1; char vowel[]=&#123;&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;,&apos;A&apos;,&apos;E&apos;,&apos;I&apos;,&apos;O&apos;,&apos;U&apos;&#125;; set&lt;char&gt; vowels(vowel,vowel+sizeof(vowel)/sizeof(char)); string res(s.size(),&apos;\0&apos;); while(i&lt;=j)&#123; if(vowels.find(s[i])==vowels.end()) res[i++]=s[i]; else if(vowels.find(s[j])==vowels.end()) res[j--]=s[j]; else&#123; res[i]=s[j]; res[j]=s[i]; i++;j--; &#125; &#125; return res; &#125;&#125;; 回文字符串 680.Valid PalindromeInput: “abca”Output: TrueExplanation: You could delete the character ‘c’. 题目描述：可以删除一个字符，判断是否能构成回文字符串。 解题思路：允许删除一个字符，当遇到不匹配的时候，要么删除左边的字符，要么删除右边的字符，都要遍历一遍，只要有一种能返回true，结果就返回true。可以写一个子函数来判断字符串中的某个范围内的子字符串是否为回文串。 123456789101112131415161718192021class Solution &#123;public: bool validPalindrome(string s) &#123; int i=0,j=s.size()-1; while(i&lt;j)&#123; if(s[i]!=s[j]) return isValid(s,i+1,j)||isValid(s,i,j-1); i++;j--; &#125; return true; &#125;private: bool isValid(string s,int i,int j)&#123; while(i&lt;j)&#123; if(s[i++]!=s[j--]) return false; &#125; return true; &#125;&#125;; 归并两个有序数组 88.Merge Sorted ArrayInput:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 题目描述：把归并结果存到第一个数组上。解题思路：题目中说了num1数组有足够的空间，不用resize数组，已知混合之后的数组的大小，这样从nums1和nums2数组的末尾开始一个一个比较，把较大的数按顺序从后往前加入混合之后的数组末尾。需要三个变量i、j、k，分别指向nums1、nums2和混合数组的末尾。进行while循环，如果i和j都大于0，再看如果nums1[i]&gt;nums[j],说明要先把nums1[i]先加入混合数组的末尾，加入后k和i均自减1；反之把nums2[j]加入混合数组末尾，加入后k和j均自减1。循环结束后，有可能i或j还大于0，若j大于0，则需要继续循环将nums2中的数组继续拷贝到nums1；若i大于0，那么就不用管了。 1234567891011121314class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i=m-1,j=n-1,k=m+n-1; while(i&gt;=0&amp;&amp;j&gt;=0)&#123; if(nums1[i]&gt;nums2[j]) nums1[k--]=nums1[i--]; else nums1[k--]=nums2[j--]; &#125; while(j&gt;=0) nums1[k--]=nums2[j--]; &#125;&#125;; 判断链表是否存在环 141.Linked List Circle使用快慢指针，一个指针移动一个节点，一个指针移动两个节点，若存在环，那么两指针一定相遇。12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head==NULL||head-&gt;next==NULL) return false; ListNode *slow=head,*fast=head; while(fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(fast==slow) return true; &#125; return false; &#125;&#125;; 判断是否为子序列 392.Is Subsequence(Medium)s = “abc”, t = “ahbgdc”Return true. 解题思路：两个指针分别指向字符串s和t，如果字符相等，则i和j自增1，否则j自增1，，看最后i是否等于s的长度；若等于说明s已经遍历完了，且字符都在t中出现过。123456789101112class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int i=0; for(int j=0;i&lt;s.size()&amp;&amp;j&lt;t.size();j++)&#123; if(s[i]==t[j]) i++; &#125; return i==s.size(); &#125;&#125;; 最长子序列 524.Longest Word in Dictionary through DeletingInput:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]Output:“apple” 题目描述：删除s中的一些字符，使得它构成的字符串列表d中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。解题思路：判断s删除一些字符后，是否存在于字典中，用i、j分别表示字符串和单词中某个字母的位置；遍历给定字符串，若遍历到单词中的某个字母，则j自增1，如果没有，则继续往下遍历。这样如果最后i和单词长度相等，则说明单词中所有的字母都按顺序出现在字符串s中！找出能构成的最长单词，需要遍历字典中的所有单词，找出长度最长的。 12345678910111213141516171819202122232425class Solution &#123;public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; string longestWord=&quot;&quot;; for(string target:d)&#123; int l1=longestWord.size(),l2=target.size(); if(l1&gt;l2||(l1==l2&amp;&amp;longestWord.compare(target)&lt;0)) continue; if(isValid(s,target)) longestWord=target; &#125; return longestWord; &#125;private: bool isValid(string s,string target)&#123; int i=0,j=0; while(i&lt;s.size()&amp;&amp;j&lt;target.size())&#123; if(s[i]==target[j]) j++; i++; &#125; return j==target.size(); &#125;&#125;; 补充：字典中的最长单词 720.Lonest Word in DIctionaryInput:words = [“w”,”wo”,”wor”,”worl”, “world”]Output: “world”Explanation:The word “world” can be built one character at a time by “w”, “wo”, “wor”, and “worl”. 解题思路：题目给了一个字符串数组，从单个字符开始拼，最长能构成什么单词，注意中间生成的字符串也要在字典中，而且当组成的单词长度一样时，返回字母序小的那个。使用BFS的做法，使用一个queue来辅助，先把所有长度为1的单词找出来放入queue中，当作初始的单词，然后进行循环，每次从队首取出一个元素，如果长度大于我们维护的最大值mxLen，则更新mxlen和结果，如果相等取字母序小的那个。然后试着增加长度，做法就是遍历26个字母，将每个字母都加到单词后面，然后看是否存在于字典中，存在的话，就入队，等待下一次遍历，增加长度之后记得要恢复原来的状态。 1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestWord(vector&lt;string&gt;&amp; words) &#123; string res=&quot;&quot;; int mxLen=0; unordered_set&lt;string&gt; s(words.begin(),words.end()); queue&lt;string&gt; q; for(string word:words)&#123; if(word.size()==1) q.push(word); &#125; while(!q.empty())&#123; string t=q.front(); q.pop(); if(t.size()&gt;mxLen)&#123; mxLen=t.size(); res=t; &#125;else if(t.size()==mxLen) res=min(res,t); for(char c=&apos;a&apos;;c&lt;=&apos;z&apos;;c++)&#123; t.push_back(c); if(s.find(t)!=s.end())//或者使用count函数 q.push(t); t.pop_back(); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.数学形态学运算]]></title>
    <url>%2F2019%2F03%2F25%2FComputerVision%2FOpenCV-ImageProcessing%2F3-Mathematical%20morphology%2F</url>
    <content type="text"><![CDATA[数学形态学运算–腐蚀、膨胀、开运算、闭运算数学形态学操作可以分为二值形态学和灰度形态学，灰度形态学由二值形态学扩展而来，数学形态学有两个基本的运算，腐蚀和膨胀，而腐蚀和膨胀又形成了开运算和闭运算。 二值形态学-通常用于二值图像腐蚀膨胀的作用： 消除噪声 分割出独立的图像元素，在图像中连接相邻的元素 寻找图像中明显的极大值区域或者极小值区域 求出图像的梯度 膨胀– 是图像中的高亮部分进行膨胀，效果图拥有比原图更大的高亮区域；腐蚀– 是原图中的高亮部分被腐蚀，效果图拥有比原图更小的高亮区域。从数学的角度来说腐蚀和膨胀操作就是将图像与核进行卷积，核可以是任意形状和大小的，核大则周围对其影响大，变化大，核小则周围对齐影响小，变化小。 更加高级的形态学变换 开运算–先腐蚀再膨胀，可以用来去掉目标外的孤立点，消除小物体，在纤细处分离物体，并且在平滑较大物体的边界的同时不明显改变其面积。 闭运算–先膨胀再腐蚀，能够去掉目标内的孔，排除小型黑洞。 形态学梯度–就是膨胀图与俯视图之差，用于保留物体的边缘轮廓。 顶帽–原图像与开运算之差，用于分离比邻近点亮一些的斑块。 黑帽–闭运算与原图像之差，用于分离比临近点暗一些的斑块。 1234567891011121314151617181920212223int main()&#123; Mat img = imread(&quot;alita.png&quot;); Mat out1, out2,out3,out4,out5; //MORPH_RECT表示矩形的卷积核，当然也可以选择椭圆形、交叉型的 Mat element = getStructuringElement(MORPH_RECT, Size(10, 10)); dilate(img, out1, element); erode(img, out2, element); //高级形态学处理，调用这个函数就可以了，具体选择哪种操作，直接修改第三个参数 morphologyEx(img, out3, MORPH_GRADIENT, element); morphologyEx(img, out4, MORPH_TOPHAT, element); morphologyEx(img, out5, MORPH_BLACKHAT, element); imshow(&quot;原图&quot;, img); imshow(&quot;膨胀操作&quot;, out1); imshow(&quot;腐蚀操作&quot;, out2); imshow(&quot;形态学梯度&quot;, out3); imshow(&quot;顶帽&quot;, out4); imshow(&quot;黑帽&quot;, out5); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>腐蚀</tag>
        <tag>膨胀</tag>
        <tag>开闭运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.Filter]]></title>
    <url>%2F2019%2F03%2F25%2FComputerVision%2FOpenCV-ImageProcessing%2F2-Filter%2F</url>
    <content type="text"><![CDATA[OpenCV基本滤波算法分类及作用 线性滤波 方框滤波：模糊图像 均值滤波：模糊图像 高斯滤波：信号的平滑处理，去除符合正态分布的噪声 非线性滤波 中值滤波：去除椒盐噪声 双边滤波：保边去噪 OpenCV中的函数调用1.方框滤波void boxFilter(InputArray src,OutputArray dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), boolnormalize=true, int borderType=BORDER_DEFAULT )用一个像素的领域像素值之和作为滤波结果，邻域即模板所覆盖的图像区域，此时模板的所有系数都为1. 源图像可以是彩色图或者是灰度图,因为图像处理的时候,通道是分开来处理的 目的图像的大小和通道数必须和源图像相同 int类型的ddepth，输出图像的深度，-1代表使用原图深度，即src.depth()。 Size类型（对Size类型稍后有讲解）的ksize，内核的大小 Point类型的anchor，表示锚点（即被平滑的那个点），注意它有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。 bool类型的normalize，默认值为true，一个标识符，表示内核是否被其区域归一化（normalized）了。 int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，我们一般不去管它。 其中f表示原图，h表示核，g表示目标图，当normalize=true的时候，方框滤波就变成了我们熟悉的均值滤波。也就是说，均值滤波是方框滤波归一化（normalized）后的特殊情况。其中，归一化就是把要处理的量都缩放到一个范围内,比如(0,1)，以便统一处理和直观量化. 2.均值滤波void blur(InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )均值滤波就是方框滤波的一个特殊情况，blur函数内部中其实就是调用了一下boxFilter,均值滤波的特点就是不能很好的保护细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊，不能很好的去除噪点。 src,输入图像。该函数对通道是独立处理的,且可以处理任意通道数的图片，但需要注意，待处理的图片深度应该为CV_8U, CV_16U, CV_16S, CV_32F 以及 CV_64F之一。 dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。 Size类型的ksize，内核的大小。一般这样写Size(w,h)来表示内核的大小(其中，w 为像素宽度,h为像素高度)。Size（3,3）就表示3x3的核大小，Size（5,5）就表示5x5的核大小 Point类型的anchor，表示锚点（即被平滑的那个点），注意他有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。 int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，一般不去管它。 3.高斯滤波void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT)高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。从数学的角度来看，图像的高斯模糊过程就是图像与正态分布做卷积。由于正态分布又叫作高斯分布，所以这项技术就叫作高斯模糊。 src，输入图像，即源图像，填Mat类的对象即可。它可以是单独的任意通道数的图片，但需要注意，图片深度应该为CV_8U,CV_16U, CV_16S, CV_32F 以及 CV_64F之一。 dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。 ksize，高斯内核的大小。其中ksize.width和ksize.height可以不同，但他们都必须为正数和奇数。或者，它们可以是零的，它们都是由sigma计算而来。 sigmaX，表示高斯核函数在X方向的的标准偏差。 sigmaY，表示高斯核函数在Y方向的的标准偏差。若sigmaY为零，就将它设为sigmaX，如果sigmaX和sigmaY都是0，那么就由ksize.width和ksize.height计算出来。 4.中值滤波void medianBlur(InputArray src, OutputArray dst, int ksize)基本思想就是用像素点的邻域灰度的中值来代替该像素点的灰度值，该方法在去除脉冲噪声、椒盐噪声的同时又能保留图像的细节，不会出现边缘模糊的情况。中值滤波跟均值滤波的思想看起来很相似，只是一个取平均值，一个取中位数而已 第一个参数，InputArray类型的src，函数的输入参数，填1、3或者4通道的Mat类型的图像；当ksize为3或者5的时候，图像深度需为CV_8U，CV_16U，或CV_32F其中之一，而对于较大孔径尺寸的图片，它只能是CV_8U。 第二个参数，OutputArray类型的dst，需要和源图片有一样的尺寸和类型。 第三个参数，int类型的ksize，孔径的线性尺寸（aperture linear size），注意这个参数必须是大于1的奇数，比如：3，5，7，9 … 中值滤波与均值滤波的比较：均值滤波中噪声成分会被加入到平均计算，所以输出是受到噪声的影响的。但是中值滤波中，由于噪声成分很难选上，所以基本不影响输出。当然好的性能也需要付出一点代价的，中值滤波花费的时间是均值滤波的5倍以上 5.双边滤波void bilateralFilter(InputArray src, OutputArray dst, int d,double sigmaColor,double sigmaSpace,int borderType=BORDER_DEFAULT )双边滤波的最大特点就是做边缘保护。 InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。 OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。.- int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。 double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值越大，表明该像素邻域内有越宽广的颜色会被混合到一起，产生较大的半相等颜色区域。 double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着颜色相近的较远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。当d&gt;0时，d指定了邻域大小且与sigmaSpace五官，否则d正比于sigmaSpace. int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT 123456789101112131415161718int mainfilter()&#123; Mat img = imread(&quot;alita.png&quot;); Mat out1,out2,out3,out4,out5; boxFilter(img, out1, -1, Size(3, 3)); blur(img, out2, Size(3, 3)); GaussianBlur(img, out3, Size(3, 3), 0, 0); medianBlur(img, out4, 5); bilateralFilter(img, out5, 25, 25 * 2, 25 / 2); imshow(&quot;原图&quot;, img); imshow(&quot;方框滤波&quot;, out1); imshow(&quot;均值滤波&quot;, out2); imshow(&quot;高斯滤波&quot;, out3); imshow(&quot;中值滤波&quot;, out4); imshow(&quot;双边滤波&quot;, out5); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>图像滤波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.imageBasicOperation]]></title>
    <url>%2F2019%2F03%2F24%2FComputerVision%2FOpenCV-ImageProcessing%2F1-imageBasicOperation%2F</url>
    <content type="text"><![CDATA[OpenCV Mat类型定义和赋值cv::Mat img(height,width,例：cv::Mat M(480,640,CV_8UC3，Scalar(255,0,0)); 表示定义了一个480行640列的矩阵，矩阵的每个单元的由三个(C3:3 Channel)8位无符号整形(U Unsigned U8 8位)构成,Scalar(255,0,0)表示给每个单元赋值。 123456789101112131415161718192021222324252627282930313233#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char **argv)&#123; //这些方式都是自己拥有独立的内存空间 Mat img1(3, 3, CV_8UC3, Scalar(255, 0, 0)); cout &lt;&lt; img1&lt;&lt;esndl; int sz[3] = &#123; 2, 2, 2 &#125;; Mat img2(3, 3, CV_8UC1, Scalar(200, 0, 255));//单通道的化只会赋值第一个值 cout &lt;&lt; img2 &lt;&lt; endl; Mat img3; img3.create(4, 4, CV_8UC3); cout &lt;&lt; img3 &lt;&lt; endl; Mat img4 = Mat::zeros(4, 4, CV_8UC3); Mat img5 = img4.clone(); Mat img6; img4.copyTo(img6); //clone和copyto函数，这是图像的深拷贝，相当于重新创建了一份一模一样的图像 //下面都是浅拷贝，指针指向同一个实例 Mat img7 = img6; Mat img8(img6); waitKey(0); return 0;&#125; 图像二值化操作threshold —— 简单的阈值操作def threshold(src, dst,thresh, maxval,thresholdType) thresh：Double类型的，具体的阈值 maxval：Double类型的，阈值的最大值 thresholdType: THRESH_BINARY 二进制阈值化 -&gt; 大于阈值为1 小于阈值为0 THRESH_BINARY_INV 反二进制阈值化 -&gt; 大于阈值为0 小于阈值为1 THRESH_TRUNC 截断阈值化 -&gt; 大于阈值为阈值，小于阈值不变 THRESH_TOZERO 阈值化为0 -&gt; 大于阈值的不变，小于阈值的全为0 THRESH_TOZERO_INV 反阈值化为0 -&gt; 大于阈值为0，小于阈值不变 adaptiveThreshold —— 自适应阈值操作def adaptiveThreshold(src,dst,maxValue,adaptiveMethod,thresholdType,blockSize,C) maxval：Double类型的，阈值的最大值 adaptiveMethod： ADAPTIVE_THRESH_MEAN_C（通过平均的方法取得平均值)ADAPTIVE_THRESH_GAUSSIAN_C(通过高斯取得高斯值) thresholdType同上 blockSize：Int类型的，这个值来决定像素的邻域块有多大（这里的blockSize的值要为奇数，否则会给出这样的提示：Assertion failed (blockSize % 2 == 1 &amp;&amp; blockSize &gt; 1) in cv::adaptiveThreshold ） C：偏移值调整量，计算adaptiveMethod用到的参数 总结： 在两种情况下，自适应阈值T(x, y)。通过计算每个像素周围bxb大小像素块的加权均值并减去常量C得到。其中，b由blockSize给出，大小必须为奇数；如果使用平均的方法，则所有像素周围的权值相同；如果使用高斯的方法，则（x,y）周围的像素的权值则根据其到中心点的距离通过高斯方程得到。 12345678910111213141516171819202122232425262728#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char **argv)&#123; Mat img = imread(&quot;groot.jpg&quot;, CV_LOAD_IMAGE_GRAYSCALE);//载入灰度图 if (img.empty())&#123; cout &lt;&lt; &quot;read img falied!\n&quot;; return -1; &#125; //全局二值化 int th = 150; Mat global; threshold(img, global, th, 255, CV_THRESH_BINARY); //局部二值化 int blockSize = 25; int constValue = 10; Mat local; adaptiveThreshold(img, local, 255, CV_ADAPTIVE_THRESH_MEAN_C, CV_THRESH_BINARY, blockSize, constValue); imshow(&quot;原图&quot;, img); imshow(&quot;全局二值化&quot;, global); imshow(&quot;局部二值化&quot;, local); waitKey(0); return 0;&#125; 运行结果如下： 访问图片中的像素①指针访问：最快 ②迭代器iterator：较慢，非常安全，指针访问可能出现越界问题 ③动态地址计算：更慢，通过at()实现。适用于访问具体某个第i行，j列的像素，而不适用遍历像素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;void visitByPointer(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); int rows = dstImg.rows; int cols = dstImg.cols*dstImg.channels(); for (int i = 0; i &lt; rows; i++) &#123; uchar *data = dstImg.ptr&lt;uchar&gt;(i);//获取第i行地址 for (int j = 0; j &lt; cols; j++)&#123; data[j] += 10; //add code 处理每一个像素 &#125; &#125;&#125;void visitByIterator(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); const int chanels = dstImg.channels(); switch (chanels) &#123; case 1:&#123; Mat_&lt;uchar&gt;::iterator it = dstImg.begin&lt;uchar&gt;(); Mat_&lt;uchar&gt;::iterator itend = dstImg.end&lt;uchar&gt;(); for (; it != itend;it++) &#123; *it += 10;//处理每个像素 &#125;break; &#125; case 3:&#123; Mat_&lt;Vec3d&gt;::iterator it3 = dstImg.begin&lt;Vec3d&gt;(); Mat_&lt;Vec3d&gt;::iterator it3end = dstImg.end&lt;Vec3d&gt;(); for (; it3 != it3end;it3++) &#123; (*it3)[0] += 10; (*it3)[1] -= 10; (*it3)[2] -= 10; &#125;break; &#125; default: break; &#125;&#125;void visitByAt(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); int rows = dstImg.rows; int cols = dstImg.cols; int channels = dstImg.channels(); switch (channels) &#123; case 1:&#123; for (int i = 0; i &lt; rows;i++) &#123; for (int j = 0; j &lt; cols;j++) &#123; dstImg.at&lt;uchar&gt;(i, j) += 10; &#125; &#125;break; &#125; case 3:&#123; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; dstImg.at&lt;Vec3d&gt;(i, j)[0] += 10; dstImg.at&lt;Vec3d&gt;(i, j)[1] -= 10; dstImg.at&lt;Vec3d&gt;(i, j)[2] -= 10; &#125; &#125;break; &#125; default: break; &#125;&#125;int main(int argc, char **argv)&#123; Mat img = imread(&quot;Lena.png&quot;); Mat dstImg1,dstImg2,dstImg3; visitByPointer(img, dstImg1); visitByIterator(img, dstImg2); //visitByAt(img, dstImg3); imshow(&quot;原图&quot;, img); imshow(&quot;指针访问&quot;, dstImg1); imshow(&quot;迭代器访问&quot;, dstImg2); //imshow(&quot;at访问&quot;, dstImg3); waitKey(0); return 0;&#125; 常用的数据结构12345678910111213141516171819202122232425262728293031323334353637int main(int argc,char** argv)&#123; Mat m1(3, 3, CV_8UC3, Scalar(255, 0, 0));//其中宏的解释：CV_[位数][带符号与否][类型前缀]C[通道数] cout &lt;&lt; m1 &lt;&lt; endl;//输出的就是3*9的矩阵 //或者利用IplImage指针来初始化，将IplImage*转化为Mat IplImage* img = cvLoadImage(&quot;Lena.png&quot;); Mat m2 = cvarrToMat(img); //Mat转IplImage IplImage img2 = IplImage(m2); Mat m3; m3.create(3, 3, CV_8UC(2)); cout &lt;&lt; m3 &lt;&lt; endl; //点的表示 Point p1; p1.x = 1; p1.y = 1; //或者 Point p2(1, 1); //颜色的表示：Scalar(b,g,r) Scalar(1, 1, 1) ; //尺寸的表示：Size Size(2,3);//宽和高 //矩形的表示：Rect，成员变量有x、y、width、height Rect r1(0, 0, 100, 200); Rect r2(10, 10, 100, 200); Rect r3 = r1 | r2;//两个矩形求交集 Rect r4 = r1 &amp; r2;//两个矩形求并集 waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>Mat初始化</tag>
        <tag>访问像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径中斜杠和反斜杠的区别]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9A%8F%E7%AC%94%2F%E8%B7%AF%E5%BE%84%E4%B8%AD%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8F%8D%E6%96%9C%E6%9D%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Unix使用斜杠/ 作为路径分隔符，而web应用最新使用在Unix系统上面，所以目前所有的网络地址都采用斜杠/ 作为分隔符; Windows由于使用斜杠/作为DOS命令提示符的参数标志了，为了不混淆，所以采用反斜杠\作为路径分隔符。所以目前Windows系统上的文件目录结构都是用反斜杠\作为路径分隔符。随着发展，DOS系统已经被淘汰了，命令提示符用的很少，斜杠和反斜杠在大多数情况下可以互换。 总结: 浏览器地址栏网址使用斜杠/ Windows文件目录结构地址使用反斜杠\ 出现heml url()属性中的路径，指定的路径是网络路径，所以必须用斜杠/ 出现在普通字符串中的路径，如果代表的是Windows文件路径，则使用斜杠和反斜杠是一样的，如果代表的是网络文件路径，则必须使用斜杠/ 上面提到斜杠/是url地址中用到的分隔符；对应的，双斜杠//用在网络域名访问中，是协议和主机名或IP地址之间的分隔符，以双斜杠//开头的是一俩url是依赖协议的url表示形式，URL格式：协议://域名或IP/请求文件路径/文件名；如百度的网址：https://www.baidu.com/ 。URL默认以斜杠/结尾，而没有给出文件名的情况下，URL引用路径中最后一个目录中的默认文件(通常对应于主页). 反斜杠是Windows系统文件目录结构使用的分隔符，如：D:\allDream(用反斜杠也可以，但是双斜杠或双反斜杠不行)。对应的，双反斜杠\在Windows里表示绝对地址的第一项，后面跟IP地址或计算机名，就是需要打开这个IP地址或计算机名对应主机的网络共享资源。]]></content>
      <tags>
        <tag>Node</tag>
        <tag>路径分隔符/&amp;\</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-TwoSum]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode%E5%88%B7%E9%A2%98%2FLeetCode-TwoSum%2F</url>
    <content type="text"><![CDATA[1.Two Sum (1)Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解题思路 定义一个unordered_map变量record，用于保存遍历过的元素的下标； 遍历数组的每一个元素，如果target减去nums[i]的值在record中，则直接返回两个下标，否则将该元素插入到record中，继续循环； 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; record; for(int i=0;i&lt;nums.size();i++)&#123; int complement=target-nums[i]; if(record.find(complement)!=record.end())&#123; int res[]=&#123;record[complement],i&#125;; return vector&lt;int&gt; &#123;res,res+2&#125;; &#125; record[nums[i]]=i; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; Two Sum II (167)这道题目和剑指offer上”和为s的两个数字”是一样的。 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice.Example: Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 解法一：暴力+二分搜索给定的数组有序，而且题目中限定一定有解，那么可以使用两层循环进行暴力求解，外层循环遍历数组，作为第一个元素，然后内层循环使用二分法来搜索target-numbers[i]即可。时间复杂度为O(nlogn).12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; for(int i=0;i&lt;numbers.size();i++)&#123; int t=target-numbers[i],left=i+1,right=numbers.size()-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(numbers[mid]==t) return vector&lt;int&gt; &#123;i+1,mid+1&#125;; else if(numbers[mid]&lt;t) left=mid+1; else right=mid-1; &#125; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 解法二：对撞指针需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加刚好等于target，直接返回两个指针的位置，若小于target，左指针右移，若大于target，有指针左移，以此类推直到两个指针相遇停止。时间复杂度为O(n).123456789101112131415161718// 对撞指针// Time：O(n)// Space:O(1)class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int i=0,j=numbers.size()-1; while(i&lt;j)&#123; if(numbers[i]+numbers[j]==target) return vector&lt;int&gt; &#123;i+1,j+1&#125;; else if(numbers[i]+numbers[j]&lt;target) i++; else j--; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 和为s的连续正整数序列要求计算出9~16的和,写出正确答案是100。究竟有多少种连续的正数序列的和为100(至少包括两个数)。另一组连续正数和为100的序列:18,19,20,21,22。现有问题如下,能不能也很快的找出所有和为S的连续正数序列? 输出所有和为S的正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。 方法一：暴力求解——滑动窗口思想将序列(1, 2)作为初始序列，small表示序列的第一个，big表示序列的最后一个。如果序列中和小于所求值，序列的big往前走一个从而把一个更大的数包括到序列中；如果序列中和小于所求值，small往前走一个把原来序列中最小的数排除出去。如果相等，打印出当前序列，big继续往前走一个，来寻找新的序列。一直到big大于等于所求和的一半了，遍历就停止了。 整个思路就像模拟了一个窗口在变化，这种方法本质上依然是贪心，不过是首位双指针的贪心。123456789101112131415161718192021222324252627282930313233//牛客网上的解决方案class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(sum&lt;3) return res; int small=1,big=2; int mid=(1+sum)&gt;&gt;1; int curSum=small+big; while(small&lt;mid)&#123; if(curSum==sum) InsertRes(small,big,res); while(curSum&gt;sum&amp;&amp;small&lt;mid)&#123; curSum-=small; small++; if(curSum==sum)&#123; InsertRes(small,big,res); &#125; &#125; big++; curSum+=big; &#125; return res; &#125;private: void InsertRes(int begin,int end,vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123; vector&lt;int&gt; temp; for(int i = begin;i&lt;=end;i++) temp.push_back(i); res.push_back(temp); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>窗口思想</tag>
        <tag>中位数法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法小结]]></title>
    <url>%2F2019%2F03%2F22%2FMarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MarkDown修改字体颜色用代码进行更改字体颜色，还可以修改字体大小、字体格式等 。1234567891011121314&lt;font 更改语法&gt; 你的内容 &lt;/font&gt;更改语法有: color=#0099ff 更改字体颜色face=&quot;黑体&quot; 更改字体size= 7 更改字体大小 &lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 常用颜色表：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145颜色名 十六进制颜色值 颜色AliceBlue #F0F8FF rgb(240, 248, 255)AntiqueWhite #FAEBD7 rgb(250, 235, 215)Aqua #00FFFF rgb(0, 255, 255)Aquamarine #7FFFD4 rgb(127, 255, 212)Azure #F0FFFF rgb(240, 255, 255)Beige #F5F5DC rgb(245, 245, 220)Bisque #FFE4C4 rgb(255, 228, 196)Black #000000 rgb(0, 0, 0)BlanchedAlmond #FFEBCD rgb(255, 235, 205)Blue #0000FF rgb(0, 0, 255)BlueViolet #8A2BE2 rgb(138, 43, 226)Brown #A52A2A rgb(165, 42, 42)BurlyWood #DEB887 rgb(222, 184, 135)CadetBlue #5F9EA0 rgb(95, 158, 160)Chartreuse #7FFF00 rgb(127, 255, 0)Chocolate #D2691E rgb(210, 105, 30)Coral #FF7F50 rgb(255, 127, 80)CornflowerBlue #6495ED rgb(100, 149, 237)Cornsilk #FFF8DC rgb(255, 248, 220)Crimson #DC143C rgb(220, 20, 60)Cyan #00FFFF rgb(0, 255, 255)DarkBlue #00008B rgb(0, 0, 139)DarkCyan #008B8B rgb(0, 139, 139)DarkGoldenRod #B8860B rgb(184, 134, 11)DarkGray #A9A9A9 rgb(169, 169, 169)DarkGreen #006400 rgb(0, 100, 0)DarkKhaki #BDB76B rgb(189, 183, 107)DarkMagenta #8B008B rgb(139, 0, 139)DarkOliveGreen #556B2F rgb(85, 107, 47)Darkorange #FF8C00 rgb(255, 140, 0)DarkOrchid #9932CC rgb(153, 50, 204)DarkRed #8B0000 rgb(139, 0, 0)DarkSalmon #E9967A rgb(233, 150, 122)DarkSeaGreen #8FBC8F rgb(143, 188, 143)DarkSlateBlue #483D8B rgb(72, 61, 139)DarkSlateGray #2F4F4F rgb(47, 79, 79)DarkTurquoise #00CED1 rgb(0, 206, 209)DarkViolet #9400D3 rgb(148, 0, 211)DeepPink #FF1493 rgb(255, 20, 147)DeepSkyBlue #00BFFF rgb(0, 191, 255)DimGray #696969 rgb(105, 105, 105)DodgerBlue #1E90FF rgb(30, 144, 255)Feldspar #D19275 rgb(209, 146, 117)FireBrick #B22222 rgb(178, 34, 34)FloralWhite #FFFAF0 rgb(255, 250, 240)ForestGreen #228B22 rgb(34, 139, 34)Fuchsia #FF00FF rgb(255, 0, 255)Gainsboro #DCDCDC rgb(220, 220, 220)GhostWhite #F8F8FF rgb(248, 248, 255)Gold #FFD700 rgb(255, 215, 0)GoldenRod #DAA520 rgb(218, 165, 32)Gray #808080 rgb(128, 128, 128)Green #008000 rgb(0, 128, 0)GreenYellow #ADFF2F rgb(173, 255, 47)HoneyDew #F0FFF0 rgb(240, 255, 240)HotPink #FF69B4 rgb(255, 105, 180)IndianRed #CD5C5C rgb(205, 92, 92)Indigo #4B0082 rgb(75, 0, 130)Ivory #FFFFF0 rgb(255, 255, 240)Khaki #F0E68C rgb(240, 230, 140)Lavender #E6E6FA rgb(230, 230, 250)LavenderBlush #FFF0F5 rgb(255, 240, 245)LawnGreen #7CFC00 rgb(124, 252, 0)LemonChiffon #FFFACD rgb(255, 250, 205)LightBlue #ADD8E6 rgb(173, 216, 230)LightCoral #F08080 rgb(240, 128, 128)LightCyan #E0FFFF rgb(224, 255, 255)LightGoldenRodYellow #FAFAD2 rgb(250, 250, 210)LightGrey #D3D3D3 rgb(211, 211, 211)LightGreen #90EE90 rgb(144, 238, 144)LightPink #FFB6C1 rgb(255, 182, 193)LightSalmon #FFA07A rgb(255, 160, 122)LightSeaGreen #20B2AA rgb(32, 178, 170)LightSkyBlue #87CEFA rgb(135, 206, 250)LightSlateBlue #8470FF rgb(132, 112, 255)LightSlateGray #778899 rgb(119, 136, 153)LightSteelBlue #B0C4DE rgb(176, 196, 222)LightYellow #FFFFE0 rgb(255, 255, 224)Lime #00FF00 rgb(0, 255, 0)LimeGreen #32CD32 rgb(50, 205, 50)Linen #FAF0E6 rgb(250, 240, 230)Magenta #FF00FF rgb(255, 0, 255)Maroon #800000 rgb(128, 0, 0)MediumAquaMarine #66CDAA rgb(102, 205, 170)MediumBlue #0000CD rgb(0, 0, 205)MediumOrchid #BA55D3 rgb(186, 85, 211)MediumPurple #9370D8 rgb(147, 112, 216)MediumSeaGreen #3CB371 rgb(60, 179, 113)MediumSlateBlue #7B68EE rgb(123, 104, 238)MediumSpringGreen #00FA9A rgb(0, 250, 154)MediumTurquoise #48D1CC rgb(72, 209, 204)MediumVioletRed #C71585 rgb(199, 21, 133)MidnightBlue #191970 rgb(25, 25, 112)MintCream #F5FFFA rgb(245, 255, 250)MistyRose #FFE4E1 rgb(255, 228, 225)Moccasin #FFE4B5 rgb(255, 228, 181)NavajoWhite #FFDEAD rgb(255, 222, 173)Navy #000080 rgb(0, 0, 128)OldLace #FDF5E6 rgb(253, 245, 230)Olive #808000 rgb(128, 128, 0)OliveDrab #6B8E23 rgb(107, 142, 35)Orange #FFA500 rgb(255, 165, 0)OrangeRed #FF4500 rgb(255, 69, 0)Orchid #DA70D6 rgb(218, 112, 214)PaleGoldenRod #EEE8AA rgb(238, 232, 170)PaleGreen #98FB98 rgb(152, 251, 152)PaleTurquoise #AFEEEE rgb(175, 238, 238)PaleVioletRed #D87093 rgb(216, 112, 147)PapayaWhip #FFEFD5 rgb(255, 239, 213)PeachPuff #FFDAB9 rgb(255, 218, 185)Peru #CD853F rgb(205, 133, 63)Pink #FFC0CB rgb(255, 192, 203)Plum #DDA0DD rgb(221, 160, 221)PowderBlue #B0E0E6 rgb(176, 224, 230)Purple #800080 rgb(128, 0, 128)Red #FF0000 rgb(255, 0, 0)RosyBrown #BC8F8F rgb(188, 143, 143)RoyalBlue #4169E1 rgb(65, 105, 225)SaddleBrown #8B4513 rgb(139, 69, 19)Salmon #FA8072 rgb(250, 128, 114)SandyBrown #F4A460 rgb(244, 164, 96)SeaGreen #2E8B57 rgb(46, 139, 87)SeaShell #FFF5EE rgb(255, 245, 238)Sienna #A0522D rgb(160, 82, 45)Silver #C0C0C0 rgb(192, 192, 192)SkyBlue #87CEEB rgb(135, 206, 235)SlateBlue #6A5ACD rgb(106, 90, 205)SlateGray #708090 rgb(112, 128, 144)Snow #FFFAFA rgb(255, 250, 250)SpringGreen #00FF7F rgb(0, 255, 127)SteelBlue #4682B4 rgb(70, 130, 180)Tan #D2B48C rgb(210, 180, 140)Teal #008080 rgb(0, 128, 128)Thistle #D8BFD8 rgb(216, 191, 216)Tomato #FF6347 rgb(255, 99, 71)Turquoise #40E0D0 rgb(64, 224, 208)Violet #EE82EE rgb(238, 130, 238)VioletRed #D02090 rgb(208, 32, 144)Wheat #F5DEB3 rgb(245, 222, 179)White #FFFFFF rgb(255, 255, 255)WhiteSmoke #F5F5F5 rgb(245, 245, 245)Yellow #FFFF00 rgb(255, 255, 0)YellowGreen #9ACD32 rgb(154, 205, 50)]]></content>
      <tags>
        <tag>Node</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法_递归]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[1.如何理解”递归”？当你在电影院看电影时忘记自己是在第几排，电影院里面太黑看不清，没法数，于是就问前面的人他是第几排，你想只要在他的数字上加1，就知道自己是在哪一排了；但是前面的人也看不清啊，所以他也问他前面的人…就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排把数字传回来，于是你就知道答案了。这就是一个非常标准的递归求解问题的分解过程，去的过程叫”递”，回来的过程叫”归”。基本上，所有的递归问题都可以用递推公式来表示。12f(n)=f(n-1)+1 其中，f(1)=1 2.递归需要满足的三个条件2.1 一个问题的解可以分解为几个子问题的解子问题就是数据规模更小的问题。比如，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。 2.2 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样你在求解“自己在哪一排”的思路，和前一排的人求解“自己在哪一排”的思路是一模一样的。 2.3 存在递归终止条件写递归代码最关键的是写出递推公式，找到终止条件。举个例子：假如这里有n个台阶，每次可以跨1个台阶或2个台阶，请问走完这n个台阶有多少种走法？可以这样思考：走到第n个台阶的走法有两类，第一类是从第n-1阶走了1个台阶，另一类是从n-2阶走了2个台阶。所以n个台阶的走法就等于:(走n-1阶的走法，再走1个台阶)+(走n-2阶的走法，再走2个台阶)，用公式表示就是：1f(n)=f(n-1)+f(n-2) 来看终止条件：当有一个台阶时，就只有一种走法 ，所以f(1)=1。如果递归终止条件只有f(1)=1一个，那f(2)就没法求解了，所以我们可以把f(2)=2作为另一个终止条件。123f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2) 最终的递归代码：12345int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; return f(n-1) + f(n-2);&#125; 总结： 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 3.递归代码要警惕堆栈溢出函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完返回时，才出栈。系统栈或则虚拟机栈空间一般都不大，如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。 4.递归代码要警惕重复计算上述第二个递归例子，如果把整个过程分解一下，如图所示：从图中可以发现，计算f(5)时，要先计算f(4)和f(3),而计算f(4)时还需要计算f(3),因此f(3)被计算了很多次，这就是重复计算问题。重复子问题可以用数组保存中间值的方法来优化，之后动态规划问题会用到这类思想。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——把数组排成最小的数]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。时间限制：1秒 空间限制：32768K 解题思路 将数组中的整数数组转换成字符串数组； 自定义一个比较大小的函数，比较两个字符串s1和s2大小的时候，先将它们拼起来，比较s1+s2和s2和s1哪个大，如果s1+s2大，说明s2应该放前面，根据这个规则将所有的字符换排序； 拼接所有的字符串数组中的元素。 123456789101112131415161718class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string res; vector&lt;string&gt; str; for(int i=0;i&lt;numbers.size();i++) str.push_back(to_string(numbers[i])); sort(str.begin(),str.end(),myCompare); for(int i=0;i&lt;str.size();i++) res+=str[i]; return res; &#125;private: static bool myCompare(string &amp;s1,string &amp;s2)&#123; return s1+s2 &lt; s2+s1; &#125;&#125;; tips：1. sort()函数的第三个参数自定义的比较函数返回值类型应该是static bool，不然会报错,但是在其他编译器中只要自定义函数返回的是bool类型的就可以了，没必要是静态函数。 ./solution.h:8:36: error: reference to non-static member function must be calledsort(str.begin(),str.end(),myCompare); 2. 深究STL的sort()函数以前在自定义比较函数时一直都有个疑问，当什么情况下会进行升序排列、什么情况下又进行降序排列呢？传入的两个参数应该如何进行比较？在这里推荐直接看C++技术文档 comp函数返回值：返回一个bool类型的值，这个值表示了在上升序列中第一个参数是否位于第二个参数之前。 如果comp返回true，sort根据返回值将第一个参数排在第二个参数前面； 如果comp返回false，sort根据返回值将第一个参数排在第二个参数后面。 本题中，当s1+s2 &lt; s2+s1时，s1应该排在s2前面，即排序结果能够使数据最小。 总结sort函数根据comp函数的返回值，对comp函数的两个参数排序：如果comp返回true，排序为 参数1、参数2，否则排序为 参数2、参数1。升序排列，则return para1para2]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>数组</tag>
        <tag>sort函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——二维数组中的查找]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。时间限制：1秒 空间限制：32768K 解题思路利用二维数组从上到下、从左到右递增的规律，选取右上角或左下角的元素a[i][j]与target比较： 当target小于元素a[i][j]时，那么target必定在元素a[i][j]所在行的左边，即j–； 当target大于元素a[i][j]时，那么target必定在元素a[i][j]所在列的下边，即i++。 1234567891011121314151617class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row=array.size(); int col=array[0].size(); int i=0,j=col-1;//坐标定在右上角 while( i&lt;row &amp;&amp; j&gt;=0)&#123; if(target==array[i][j]) return true; else if(target&lt;array[i][j]) j--;//遇小左移 else i++;//遇大下移 &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>数组</tag>
        <tag>元素查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——数组：为什么很多编程语言中数组都从0开始编号？]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前言在每一种编程语言中，基本都会有数组这种数据类型。但它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。大部分编程语言中，数组都是从0开始编号的，但你是否下意识的想过，为什么数组要从0开始编号，而不是从1开始呢？ 从1开始不是更符合人类的思维习惯吗？ 如何实现随机访问？数组(Array)是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。 接下来分两个角度来理解。 第一个是线性表 线性表就是数据拍成向一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈也是线性表结构。 与之对应的是非线性表 。如二叉树、堆、图等，在非线性表中，数据之间并不是简单的前后关系。 第二个是连续的内存空间和相同类型的数据。 因为这两个限制它才有了随机访问的特性，但也让数组的删除、插入变得非常低效，为了保证连续性，就需要做大量的数据搬移工作。 数组是如何实现根据下标随机访问数组元素的呢？拿一个长度为10的int类型的数组int[] a=new int[10]来举例。计算机给数组a分配一块连续内存空间1000-1039，其中内存块的首地址为base_address=1000。计算机通过地址来访问内存中的数据，当计算机需要访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：a[i]_address=base_address+i×data_type_size 面试的时候，经常会问数组和链表的区别，很多人回答说“链表适合插入删除，时间复杂度为O(1)；数组适合查找，查找时间为O(1)”。这种描述是不准确的。数组是适合查找，但是查找的时间复杂度并不为O(1).即使是排好序的数组，用二分查找，时间的复杂度也是O(logn)，所以正确的描述应该是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。 低效的插入和删除数组为了保证内存数据的连续性，会导致插入、删除操作比较低效。现在我们来讨论一下，究竟为什么会导致低效？又有哪些改进方法？ 插入操作假设数组长度为n，现在需要将一个数据插入到数组中的第k个位置，须将k~n这部分的元素都顺序的往后挪一位，平均情况时间复杂度为O(n)。如果数组中的数据是有序的，我们在某个位置插入一个新元素时，就必须安装刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，，在这种情况下，要将某个元素插入到第k个位置，为避免大规模的数据搬移，有一个简单的办法就是直接将第k为的数据搬移到数组元素的最后，把新的元素直接放到第k个位置。这种处理技巧，在特性场景下，在第k个位置插入一个元素的时间复杂度就会降到O(1)。这个处理思想在快排中也会用到。 删除操作和插入类似，如果删除数组末尾的数据，最好情况时间复杂度为O(1),如果删除开头的数据，则最坏情况时间复杂度为O(n),平均情况时间复杂度为O(n)。实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多！例如，数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在要依次删除a,b,c三个元素。为避免多次数据搬移，我们可以先记录下已经删除的数据。每次的删除操作并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 解答开篇问题从数组储存的内存模型来看，“下标”最确切的定义应该是“偏移”，根据前面讲到的寻址公式，如果数组从1开始计数，那么我们计算数组元素a[i]的内存地址就会变成： a[i]_address=base_address+i×data_type_size对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的操作，效率的优化就要尽可能做到极致。数组选择从0开始，而不是从1开始，最主要的原因可能是历史原因。## 相关思考题目### JVM的标记清楚垃圾回收算法的核心理念大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。不足：- 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时效率较高。- 空间问题。会产生不连续的内存空间碎片。### 二维数组的内存寻址公式假设二维数组大小为m*n,则a[i][j]的地址为：a[i][j]_address=base_address+(i×m+j)×data_type_size]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——二进制中1的个数 & 整数中1出现的次数]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20%26%20%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述：二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解法一基本思路： 先判断整数二进制表示中最右边是不是为1，如果是则计数器自增1；接着把输入的整数右移一位，继续判断二进制表示中最右边是否为1，直到整个数变为0为止。代码如下所示，case通过率0.00%，超时引起的，是因为如果输入的是负数，右移时，为保证移位后是一个负数，因此移位后的最高为会设1.如果一直做右移，那么这个数字最终会变为0xFFFFFFFF而陷入死循环。若n=n&gt;&gt;1;改为n/=2;通过率为55.56%，还没找到是什么原因？ 12345678910111213class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n)&#123; if(n&amp;1) res++; n=n&gt;&gt;1; &#125; return res; &#125;&#125;; 解法二基本思路： 为避免死循环，不右移输入的数字，而是定义一个无符号整型变量flag，让flag返回左移，与输入的数字进行与运算，如下：然鹅case通过率为11.11%，看书写的代码，我也不清楚为什么这样！！ 1234567891011121314class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; unsigned int flag=1; while(flag)&#123; if(n&amp;&amp;flag) res++; flag=flag&lt;&lt;1; &#125; return res; &#125;&#125;; 解法三基本思路： 这种解法就厉害了，整数的二进制表示中有几个1就执行几次循环，步骤：把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变为0. 123456789101112class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n)&#123; res++; n=(n-1)&amp;n; &#125; return res; &#125;&#125;; Tips:位运算左移右移计算机表示数字正负不是用+、-号来表示，而是用最高位数字来表示，0表示正，1表示负。 1.有符号右移&gt;&gt;（若正数，高位补0，若负数，高位补1）正数：4&gt;&gt;2 右移两位，高为补0(0000 0000 0000 0000 0000 0000 0000 0100)&gt;&gt;(000000 0000 0000 0000 0000 0000 0000 01)结果为1，即4/(2^2) 负数：-4&gt;&gt;2 (-4的二进制为4的原码取反再加1，如下)右移两位，高位补1(1111 1111 1111 1111 1111 1111 1111 1100)&gt;&gt;(1111 1111 1111 1111 1111 1111 1111 1111)根据上述得到的补码求出源码才是我们所求的结果，保留符号位，然后按位取反再加1，为(100000 0000 0000 0000 0000 0000 0000 01),结果为-1，即-4/(2^2)。 2.无符号右移&gt;&gt;&gt;(无论正负，高位均补0)正数：4&gt;&gt;&gt;2 与4&gt;&gt;2的运算结果相同，结果也是1 负数：-4&gt;&gt;&gt;2(1111 1111 1111 1111 1111 1111 1111 1100)&gt;&gt;&gt;(0011 1111 1111 1111 1111 1111 1111 1111)结果为1073741823 3.左移&lt;&lt;(不区分有符号和无符号)分析num&lt;&lt;n 相当于num(num的二进制)向左移动n位； 左边(高位)溢出部分直接舍弃；右边(低位)移入部分全部补0； 移位结果：若左移时舍弃的高位不包括1，则没左移一位，就相当于该数乘以2.(左移有可能导致符号变化) 题目描述：整数中1出现的次数求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解法一：暴力解决累加1~n中每个正数1的个数。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int res=0; for(int i=1;i&lt;=n;i++)&#123; res+=numberOf1(i); &#125; return res; &#125;private: int numberOf1(unsigned int i)&#123; int res=0; while(i)&#123; if(i%10==1) res++; i/=10; &#125; return res; &#125;&#125;; 解法二：找规律1的数目： 如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定（若没有高位，视高位为0），等于更高位数字X当前位数的权重10^(i-1); 如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响（若没有低位，视低位为0），等于更高位数字X当前位数的权重10^i-1+（低位数字+1）; 如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），等于（更高位数字+1）X当前位数的权重10i-1。 X的数目：这里的X∈[1,9],因为X=0不符合下列规律，需单独计算。首先直到以下的规律： 从1-10，在它们的个位数中，任意的X都出现了1次； 从1-100，在它们的十位数中，任意的X都出现了10次； 从1-1000，在它们的百位数中，任意的X都出现了100次； 依次类推，从1-10^i,在他们的左边第二位(右数第i位)中，任意的X都出现了10^i-1次。 接下来以n=2593，X=5为例来解释如何得到数学公式。从1至2593中，数字 5 总计出现了 813 次，其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。 首先是个位。从 1 至 2590 中，包含了 259 个 10，因此任意的 X 都出现了 259 次。最后剩余的三个数 2591, 2592 和 2593，因为它们最大的个位数字 3 &lt; X，因此不会包含任何 5。（也可以这么看，3&lt;X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字（259）X10^(1-1)=259）； 然后是十位。从 1 至 2500 中，包含了 25 个 100，因此任意的 X 都出现了 25×10=250 次。剩下的数字是从 2501 至 2593，它们最大的十位数字 9 &gt; X，因此会包含全部 10 个 5。最后总计 250 + 10 = 260。（也可以这么看，9&gt;X，则十位上可能出现的X的次数仅由更高位决定，等于更高位数字（25+1）X10^(2-1)=260）； 接下来是百位。从 1 至 2000 中，包含了 2 个 1000，因此任意的 X 都出现了 2×100=200 次。剩下的数字是从 2001 至 2593，它们最大的百位数字 5 == X，这时情况就略微复杂，它们的百位肯定是包含 5 的，但不会包含全部 100 个。如果把百位是 5 的数字列出来，是从 2500 至 2593，数字的个数与百位和十位数字相关，是 93+1 = 94。最后总计 200 + 94 = 294。（也可以这么看，5==X，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，等于更高位数字（2）X10^(3-1)+（93+1）=294）； 最后是千位。现在已经没有更高位，因此直接看最大的千位数字 2 &lt; X，所以不会包含任何 5。（也可以这么看，2&lt;X，则千位上可能出现的X的次数仅由更高位决定，等于更高位数字（0）X10^(4-1)=0）。 总结一下以上的算法，可以看到，当计算右数第 i 位包含的 X 的个数时： 取第 i 位左边（高位）的数字，乘以 10^i−1 ，得到基础值 a 。 取第 i 位数字，计算修正值： 如果大于 X，则结果为 a+ 10^i−1 。 如果小于 X，则结果为 a 。 如果等 X，则取第 i 位右边（低位）数字，设为 b ，最后结果为 a+b+1 。 相应的代码非常简单，效率也非常高，时间复杂度只有 O(log_10^n) 。 123456789101112131415161718192021222324class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int res=0; int high,low,tmp,cur,i=1; high=n; while(high)&#123; high=n/(int)pow(10,i);//求第i位的高位 tmp=n%(int)pow(10,i); cur=tmp/(int)pow(10,i-1);//求第i位的值 low=tmp%(int)pow(10,i-1);//求第i位的低位 if(cur==1) res+=high*(int)pow(10,i-1)+low+1; else if(cur&lt;1) res+=high*(int)pow(10,i-1); else res+=(high+1)*(int)pow(10,i-1); i++; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>二进制</tag>
        <tag>数1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法(一)]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[操作系统做了什么看不下去了！！！]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——复杂度分析]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据结构与算法概念理解从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。狭义上讲，就是指某些著名的数据结构和算法。 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、回溯算法、分治算法、动态规划、字符串匹配算法。 上面最常用、最基础的20个数据结构与算法，要学习它们的”来历”、”特点”、”适合解决什么问题”以及”实际的应用场景”。 下面放一张数据结构和算法的知识图谱：数据结构是为算法服务的，算法要作用在特定的数据结构之上。 那么接下来就开始学习一个数据结构与算法中最重要的概念——复杂度分析。 复杂度分析(上)——如何分析、统计算法的执行效率和资源消耗事后统计法把代码跑一边，通过统计、监控就能得到算法执行的时间和占用的内存大小。但是这种统计法有非常大的局限性。 测试结果非常依赖测试环境 测试结果受数据规模的影响很大，比如对同一个算法，待排序的数据有序度不一样，排序的时间会有河大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作执行时间非常短。此外，测试数据规模小，测试结果无法真实的反应算法的性能。比如对于小规模的数据排序，插入排序可能回避快排要块！ 大O表示法 大O时间复杂度表示法T(n)=O(f(n))其中T(n)表示代码执行的时间，n表示数据规模大小，f(n)表示每行代码执行的次数总和。公式中的O表示代码的执行时间T(n)与f(n)表达式成正比。 时间复杂度分析 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度示例分析对于复杂度量级，可以粗略的分为多项式量级 和非多项式量级 。如下图： O(1)代码执行的时间不随n的增大而增大。算法中不存在循环递归语句，即使有千万行代码，其时间复杂度也是O(1)。 O(logn)、O(nlogn) 1234int i=1;while(i&lt;=n)&#123; i*=2; &#125; 归并排序、快速排序的时间复杂度就是O(nlogn)。 O(m+n)、O(m*n)代码的复杂度由两个数据的规模来决定。 空间复杂度常见的空间复杂度就是O(1)、O(n)、O(n^2)。 复杂度分析(下)——浅析最好、最坏、平均、均摊时间复杂度最好、最坏时间复杂度例如，在一个无序数组中查找变量x。如果数组中第一个元素就是要查找的变量x，那就不需要遍历剩下的n-1个数据了，最好时间复杂度为O(1)。但如果数组中不存在x，那就要把数组遍历一遍，最坏时间复杂度为O(n)。 平均情况时间复杂度依然分析查找变量x的例子：要查找的变量x在数组中的位置，有n+1中情况：在数组的0~n-1为之中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后除以n+1，就可以得到需要遍历的元素个数的平均值。上面的推导存在一个问题就是没有把各种情况发生的概率考虑进去。假设变量x在或不在数组中的概率都为1/2，要查找的数据出现在0~n-1这n个位置的概率也是一样的，为1/n。 均摊时间复杂度 // array 表示一个长度为 n 的数组 // 代码中的 array.length 就等于 n int[] array = new int[n]; int count = 0; void insert(int val) { if (count == array.length) { int sum = 0; for (int i = 0; i &lt; array.length; ++i) { sum = sum + array[i]; } array[0] = sum; count = 1; } array[count] = val; ++count; } 假设数组的长度为n，根据数据插入的位置的不同，可以分为n种情况，每种情况的时间复杂度都是O(1)。此外还有一种额外的情况，就是在数组没有空间时间时插入一个数据，这时时间复杂度为O(n)。而且，这n+1种情况发生的概率一样，都是1/(n+1)。所以根据加权平均的计算方法，求得的平均时间复杂度就是：对于insert()函数来说，O(1)时间的插入和O(n)时间的插入出现的频率是非常有规律的，而且有一定的前后时序关系，一个O(n)插入之后紧跟着n-1个O(1)的插入操作，循环往复。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo及GitPage搭建博客]]></title>
    <url>%2F2019%2F03%2F20%2F%E4%BD%BF%E7%94%A8Hexo%E5%8F%8AGitPage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面刚开始使用GitHub，看到别人在git上搭建的博客很简洁优美，简直就是一片净土，于是自己也来试试！在搭建的过程中遇到了一些问题，再此做个记录。也算是自己的第一篇文章 :) 1.概述Git Pages本来是用于介绍托管在GitHub上的项目，不过，由于它的空间免费稳定，非常适合搭建一个博客。也可以认为是用户编写的、托管在GitHub上的静态网页。目前有两大静态博客主流框架：Jekyll和hexo。但是看到网上很多人吹捧hexo，于是直接放弃Jekyll，开始了hexo+GitHub搭建博客的第一步（在搭建的过程中，发现使用jekyll很简单，等会儿会提到我是如何偶遇它的）。hexo是一个快速、简洁且高效的博客框架，使用markdown解析文章，使用Node.js渲染界面( Hexo Themes上有很多主题以及各种功能，可参考博客我的个人博客之旅：从jekyll到hexo)。 2.搭建步骤2.1环境准备 安装Node.js,用来安装博客框架、渲染主题等。 安装Git，用来下载主题、提交、部署文章等。 2.2安装Hexo运行git bash，执行下面第一条命令安装hexo，第二条用于检查hexo安装的版本,第三条用于初始化hexo，hexo会自动下载一些文件到这个目录，包括node_modules。 $ npm install -g hexo-cli $ hexo -v $ hexo init 2.3建站及本地测试找一个合适的文件夹新建所需文件,第一条在指定文件夹创建所需文件(并初始化)，第三条安装所需组件.第四条开启服务器，访问localhost:4000(默认端口4000，ctrl+c关闭server)即可体验。 $ hexo init myBlog $ cd myBlog $ npm install $ hexo S 在hexo文件夹下执行命令： hexo generate 或者 hexo g //生成静态页面至public目录,public文件夹内的内容是要提交到GitHub上的 hexo server 或 hexo s //开启预览访问端口(开启本地服务) 2.4主题下载和配置使用命令下载主题，然后修改myBlog文件夹下的_config.yml(网站的配置文件，等会儿和github关联时也会修改改配置)。 $ cd themes $ git init $ git clone https://github.com/iissnan/hexo-theme-next.git 2.5将hexo和Git Pages关联起来2.5.1准备工作 注册GitHub账号https://github.com/，并设置Git的user name和email 配置ssh-key 代码库的设置：创建名为 “用户名.github.io” 的仓库，星号表示用户名，创建好之后访问https://zuiing.github.io 即可。插曲：以前我建立过一个git网页博客，但是今天配置hexo时不成功就删除又建了一个，但是域名变为https://zuiing.github.io/zuiing.github.io，如果访问https://zuiing.github.io 出现下面的错误：表示域名已经能够解析到，但是还需要配置，进入仓库zuiing.github.io-&gt;Setting;我的操作是Rename一下，又点了Git Pages中的”Choose a theme”(在这里偶遇了yekyll)，然后就点开了下图中的网页博客链接,就神奇的好了，而且还有了主题，惊喜！ 2.5.2正式开始部署，即设置deployment npm install hexo-deployer-git –save 在网站配置文件 _config.yml中有关deploy部分：修改仓库地址,需要特别注意的是冒号后面一定要有一个空格，以及这里使用的是ssh协议而不是http协议(刚开始我使用的http协议，执行hexo d之后一直关联不成功，估计和协议有关系)，前提是确保在Github上已经添加了公钥。 执行 hexo d 即可发布到Github仓库，其实我的过程远不像上面写的那么简单，在经历了千辛万苦之后总算成功了，这简直就是今天最开心的事儿了！还有，有网友建议每次都按下面的执行顺序来： hexo clean hexo generate hexo deploy 新增或修改主题之后请执行 hexo clean &amp;&amp; hexo d 清理缓存文件并部署。 2.6未知我知道现在才成功了一步，自己对git和hexo的了解还非常少，继续探索啦啦啦，做一个努力的小仙女儿！！！2019/03/20更 3.上传md文件图片无法显示的坑(下面是填坑过程)3.1问题介绍在sourse文件夹下建了一个img文件夹用于存储md插入图片，生成并上传到git之后，发现图片被存在了’用户名.github.io/img’文件夹下,如下图 打开博客网页却看不到图片，肯定是因为生成的index.html格式的文件图片路径不对，导致在GitHub上找不到图片,于是开始网上找解决方案，大部分说辞都差不多，例如hexo博客图片问题### 3.2开始动手1. 确认_config.yml中的post_asset_folder:true；Hexo提供了一种方便管理Asset的设定post_asset_folder，当设置为true后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，可以把该文章相关的所有资源都放到那个文件夹，这样便可以更方便的使用资源。2. 在Hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save3. 安装完成后用hexo创建文章时会发现_posts目录下面会多出一个和文章名字一样的文件夹，图片就放文件夹内即可。4. 接下来是测试图片的过程，图片插入格式如下图：5. hexo g生成之后先去本地public文件夹下看看index.yml中的路径，如下图：真是活见鬼，刚刚测试的时候在index.yml中第一张的路径是要比第二张的路径多一个testImg的(src=”/2019/03/20/testImg/testImg/test.JPG”),现在却都一样，而且在md文档中第二种写法没法直接预览图片，既然这样就是用第一种插入方法吧，anyway，图片插入的问题算是解决了。6. 在博客上查看结果如下： 4.上传md文件格式杂乱 md文档在本地格式正常，但上传到git上就很乱糟糟，如图： 很奇怪的是当我搞好图片显示问题之后，这个问题就自动好了，但我觉得二者之间没太大联系，可能是网页更新显示太慢的原因，如下图： 在用md写文档或插入代码的时候总出错，这里有篇还不错的博文，可以学习下markdown的语法 Markdown语法你都会了吗？,以及在markDown中输入数学公式。 在操作的过程中总是会遇到各种怪象，太菜啦，要被自己蠢哭了 :( 插入图片时，图片所在目录不要有中文，不然本地的markdown都找不到在哪 markdown文档名字与文档中title的名字最好一致，不然上传到gitpages之后文档中的格式会消失，这个问题搞了好几天才发现！！！2019/03/20更 5.hexo next主题配置我的博客配置参考了这篇文章，写的非常详细，效果也很美！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>hexo&amp;GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
