<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1.imageBasicOperation]]></title>
    <url>%2F2019%2F03%2F24%2FComputerVision%2FOpenCV-ImageProcessing%2F1-imageBasicOperation%2F</url>
    <content type="text"><![CDATA[OpenCV Mat类型定义和赋值cv::Mat img(height,width,例：cv::Mat M(480,640,CV_8UC3，Scalar(255,0,0)); 表示定义了一个480行640列的矩阵，矩阵的每个单元的由三个(C3:3 Channel)8位无符号整形(U Unsigned U8 8位)构成,Scalar(255,0,0)表示给每个单元赋值。 123456789101112131415161718192021222324252627282930313233#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char **argv)&#123; //这些方式都是自己拥有独立的内存空间 Mat img1(3, 3, CV_8UC3, Scalar(255, 0, 0)); cout &lt;&lt; img1&lt;&lt;esndl; int sz[3] = &#123; 2, 2, 2 &#125;; Mat img2(3, 3, CV_8UC1, Scalar(200, 0, 255));//单通道的化只会赋值第一个值 cout &lt;&lt; img2 &lt;&lt; endl; Mat img3; img3.create(4, 4, CV_8UC3); cout &lt;&lt; img3 &lt;&lt; endl; Mat img4 = Mat::zeros(4, 4, CV_8UC3); Mat img5 = img4.clone(); Mat img6; img4.copyTo(img6); //clone和copyto函数，这是图像的深拷贝，相当于重新创建了一份一模一样的图像 //下面都是浅拷贝，指针指向同一个实例 Mat img7 = img6; Mat img8(img6); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>mat初始化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径中斜杠和反斜杠的区别]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9A%8F%E7%AC%94%2F%E8%B7%AF%E5%BE%84%E4%B8%AD%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8F%8D%E6%96%9C%E6%9D%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Unix使用斜杠/ 作为路径分隔符，而web应用最新使用在Unix系统上面，所以目前所有的网络地址都采用斜杠/ 作为分隔符; Windows由于使用斜杠/作为DOS命令提示符的参数标志了，为了不混淆，所以采用反斜杠\作为路径分隔符。所以目前Windows系统上的文件目录结构都是用反斜杠\作为路径分隔符。随着发展，DOS系统已经被淘汰了，命令提示符用的很少，斜杠和反斜杠在大多数情况下可以互换。 总结: 浏览器地址栏网址使用斜杠/ Windows文件目录结构地址使用反斜杠\ 出现heml url()属性中的路径，指定的路径是网络路径，所以必须用斜杠/ 出现在普通字符串中的路径，如果代表的是Windows文件路径，则使用斜杠和反斜杠是一样的，如果代表的是网络文件路径，则必须使用斜杠/ 上面提到斜杠/是url地址中用到的分隔符；对应的，双斜杠//用在网络域名访问中，是协议和主机名或IP地址之间的分隔符，以双斜杠//开头的是一俩url是依赖协议的url表示形式，URL格式：协议://域名或IP/请求文件路径/文件名；如百度的网址：https://www.baidu.com/ 。URL默认以斜杠/结尾，而没有给出文件名的情况下，URL引用路径中最后一个目录中的默认文件(通常对应于主页). 反斜杠是Windows系统文件目录结构使用的分隔符，如：D:\allDream(用反斜杠也可以，但是双斜杠或双反斜杠不行)。对应的，双反斜杠\在Windows里表示绝对地址的第一项，后面跟IP地址或计算机名，就是需要打开这个IP地址或计算机名对应主机的网络共享资源。]]></content>
      <tags>
        <tag>Node</tag>
        <tag>路径分隔符/&amp;\</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-TwoSum]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode%E5%88%B7%E9%A2%98%2FLeetCode-TwoSum%2F</url>
    <content type="text"><![CDATA[1.Two Sum (1)Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解题思路 定义一个unordered_map变量record，用于保存遍历过的元素的下标； 遍历数组的每一个元素，如果target减去nums[i]的值在record中，则直接返回两个下标，否则将该元素插入到record中，继续循环； 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; record; for(int i=0;i&lt;nums.size();i++)&#123; int complement=target-nums[i]; if(record.find(complement)!=record.end())&#123; int res[]=&#123;record[complement],i&#125;; return vector&lt;int&gt; &#123;res,res+2&#125;; &#125; record[nums[i]]=i; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; Two Sum II (167)这道题目和剑指offer上”和为s的两个数字”是一样的。 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice.Example: Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 解法一：暴力+二分搜索给定的数组有序，而且题目中限定一定有解，那么可以使用两层循环进行暴力求解，外层循环遍历数组，作为第一个元素，然后内层循环使用二分法来搜索target-numbers[i]即可。时间复杂度为O(nlogn).12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; for(int i=0;i&lt;numbers.size();i++)&#123; int t=target-numbers[i],left=i+1,right=numbers.size()-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(numbers[mid]==t) return vector&lt;int&gt; &#123;i+1,mid+1&#125;; else if(numbers[mid]&lt;t) left=mid+1; else right=mid-1; &#125; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 解法二：对撞指针需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加刚好等于target，直接返回两个指针的位置，若小于target，左指针右移，若大于target，有指针左移，以此类推直到两个指针相遇停止。时间复杂度为O(n).123456789101112131415161718// 对撞指针// Time：O(n)// Space:O(1)class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int i=0,j=numbers.size()-1; while(i&lt;j)&#123; if(numbers[i]+numbers[j]==target) return vector&lt;int&gt; &#123;i+1,j+1&#125;; else if(numbers[i]+numbers[j]&lt;target) i++; else j--; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 和为s的连续正整数序列要求计算出9~16的和,写出正确答案是100。究竟有多少种连续的正数序列的和为100(至少包括两个数)。另一组连续正数和为100的序列:18,19,20,21,22。现有问题如下,能不能也很快的找出所有和为S的连续正数序列? 输出所有和为S的正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。 方法一：暴力求解——滑动窗口思想将序列(1, 2)作为初始序列，small表示序列的第一个，big表示序列的最后一个。如果序列中和小于所求值，序列的big往前走一个从而把一个更大的数包括到序列中；如果序列中和小于所求值，small往前走一个把原来序列中最小的数排除出去。如果相等，打印出当前序列，big继续往前走一个，来寻找新的序列。一直到big大于等于所求和的一半了，遍历就停止了。 整个思路就像模拟了一个窗口在变化，这种方法本质上依然是贪心，不过是首位双指针的贪心。123456789101112131415161718192021222324252627282930313233//牛客网上的解决方案class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(sum&lt;3) return res; int small=1,big=2; int mid=(1+sum)&gt;&gt;1; int curSum=small+big; while(small&lt;mid)&#123; if(curSum==sum) InsertRes(small,big,res); while(curSum&gt;sum&amp;&amp;small&lt;mid)&#123; curSum-=small; small++; if(curSum==sum)&#123; InsertRes(small,big,res); &#125; &#125; big++; curSum+=big; &#125; return res; &#125;private: void InsertRes(int begin,int end,vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123; vector&lt;int&gt; temp; for(int i = begin;i&lt;=end;i++) temp.push_back(i); res.push_back(temp); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>窗口思想</tag>
        <tag>中位数法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法小结]]></title>
    <url>%2F2019%2F03%2F22%2FMarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MarkDown修改字体颜色用代码进行更改字体颜色，还可以修改字体大小、字体格式等 。1234567891011121314&lt;font 更改语法&gt; 你的内容 &lt;/font&gt;更改语法有: color=#0099ff 更改字体颜色face=&quot;黑体&quot; 更改字体size= 7 更改字体大小 &lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 常用颜色表：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145颜色名 十六进制颜色值 颜色AliceBlue #F0F8FF rgb(240, 248, 255)AntiqueWhite #FAEBD7 rgb(250, 235, 215)Aqua #00FFFF rgb(0, 255, 255)Aquamarine #7FFFD4 rgb(127, 255, 212)Azure #F0FFFF rgb(240, 255, 255)Beige #F5F5DC rgb(245, 245, 220)Bisque #FFE4C4 rgb(255, 228, 196)Black #000000 rgb(0, 0, 0)BlanchedAlmond #FFEBCD rgb(255, 235, 205)Blue #0000FF rgb(0, 0, 255)BlueViolet #8A2BE2 rgb(138, 43, 226)Brown #A52A2A rgb(165, 42, 42)BurlyWood #DEB887 rgb(222, 184, 135)CadetBlue #5F9EA0 rgb(95, 158, 160)Chartreuse #7FFF00 rgb(127, 255, 0)Chocolate #D2691E rgb(210, 105, 30)Coral #FF7F50 rgb(255, 127, 80)CornflowerBlue #6495ED rgb(100, 149, 237)Cornsilk #FFF8DC rgb(255, 248, 220)Crimson #DC143C rgb(220, 20, 60)Cyan #00FFFF rgb(0, 255, 255)DarkBlue #00008B rgb(0, 0, 139)DarkCyan #008B8B rgb(0, 139, 139)DarkGoldenRod #B8860B rgb(184, 134, 11)DarkGray #A9A9A9 rgb(169, 169, 169)DarkGreen #006400 rgb(0, 100, 0)DarkKhaki #BDB76B rgb(189, 183, 107)DarkMagenta #8B008B rgb(139, 0, 139)DarkOliveGreen #556B2F rgb(85, 107, 47)Darkorange #FF8C00 rgb(255, 140, 0)DarkOrchid #9932CC rgb(153, 50, 204)DarkRed #8B0000 rgb(139, 0, 0)DarkSalmon #E9967A rgb(233, 150, 122)DarkSeaGreen #8FBC8F rgb(143, 188, 143)DarkSlateBlue #483D8B rgb(72, 61, 139)DarkSlateGray #2F4F4F rgb(47, 79, 79)DarkTurquoise #00CED1 rgb(0, 206, 209)DarkViolet #9400D3 rgb(148, 0, 211)DeepPink #FF1493 rgb(255, 20, 147)DeepSkyBlue #00BFFF rgb(0, 191, 255)DimGray #696969 rgb(105, 105, 105)DodgerBlue #1E90FF rgb(30, 144, 255)Feldspar #D19275 rgb(209, 146, 117)FireBrick #B22222 rgb(178, 34, 34)FloralWhite #FFFAF0 rgb(255, 250, 240)ForestGreen #228B22 rgb(34, 139, 34)Fuchsia #FF00FF rgb(255, 0, 255)Gainsboro #DCDCDC rgb(220, 220, 220)GhostWhite #F8F8FF rgb(248, 248, 255)Gold #FFD700 rgb(255, 215, 0)GoldenRod #DAA520 rgb(218, 165, 32)Gray #808080 rgb(128, 128, 128)Green #008000 rgb(0, 128, 0)GreenYellow #ADFF2F rgb(173, 255, 47)HoneyDew #F0FFF0 rgb(240, 255, 240)HotPink #FF69B4 rgb(255, 105, 180)IndianRed #CD5C5C rgb(205, 92, 92)Indigo #4B0082 rgb(75, 0, 130)Ivory #FFFFF0 rgb(255, 255, 240)Khaki #F0E68C rgb(240, 230, 140)Lavender #E6E6FA rgb(230, 230, 250)LavenderBlush #FFF0F5 rgb(255, 240, 245)LawnGreen #7CFC00 rgb(124, 252, 0)LemonChiffon #FFFACD rgb(255, 250, 205)LightBlue #ADD8E6 rgb(173, 216, 230)LightCoral #F08080 rgb(240, 128, 128)LightCyan #E0FFFF rgb(224, 255, 255)LightGoldenRodYellow #FAFAD2 rgb(250, 250, 210)LightGrey #D3D3D3 rgb(211, 211, 211)LightGreen #90EE90 rgb(144, 238, 144)LightPink #FFB6C1 rgb(255, 182, 193)LightSalmon #FFA07A rgb(255, 160, 122)LightSeaGreen #20B2AA rgb(32, 178, 170)LightSkyBlue #87CEFA rgb(135, 206, 250)LightSlateBlue #8470FF rgb(132, 112, 255)LightSlateGray #778899 rgb(119, 136, 153)LightSteelBlue #B0C4DE rgb(176, 196, 222)LightYellow #FFFFE0 rgb(255, 255, 224)Lime #00FF00 rgb(0, 255, 0)LimeGreen #32CD32 rgb(50, 205, 50)Linen #FAF0E6 rgb(250, 240, 230)Magenta #FF00FF rgb(255, 0, 255)Maroon #800000 rgb(128, 0, 0)MediumAquaMarine #66CDAA rgb(102, 205, 170)MediumBlue #0000CD rgb(0, 0, 205)MediumOrchid #BA55D3 rgb(186, 85, 211)MediumPurple #9370D8 rgb(147, 112, 216)MediumSeaGreen #3CB371 rgb(60, 179, 113)MediumSlateBlue #7B68EE rgb(123, 104, 238)MediumSpringGreen #00FA9A rgb(0, 250, 154)MediumTurquoise #48D1CC rgb(72, 209, 204)MediumVioletRed #C71585 rgb(199, 21, 133)MidnightBlue #191970 rgb(25, 25, 112)MintCream #F5FFFA rgb(245, 255, 250)MistyRose #FFE4E1 rgb(255, 228, 225)Moccasin #FFE4B5 rgb(255, 228, 181)NavajoWhite #FFDEAD rgb(255, 222, 173)Navy #000080 rgb(0, 0, 128)OldLace #FDF5E6 rgb(253, 245, 230)Olive #808000 rgb(128, 128, 0)OliveDrab #6B8E23 rgb(107, 142, 35)Orange #FFA500 rgb(255, 165, 0)OrangeRed #FF4500 rgb(255, 69, 0)Orchid #DA70D6 rgb(218, 112, 214)PaleGoldenRod #EEE8AA rgb(238, 232, 170)PaleGreen #98FB98 rgb(152, 251, 152)PaleTurquoise #AFEEEE rgb(175, 238, 238)PaleVioletRed #D87093 rgb(216, 112, 147)PapayaWhip #FFEFD5 rgb(255, 239, 213)PeachPuff #FFDAB9 rgb(255, 218, 185)Peru #CD853F rgb(205, 133, 63)Pink #FFC0CB rgb(255, 192, 203)Plum #DDA0DD rgb(221, 160, 221)PowderBlue #B0E0E6 rgb(176, 224, 230)Purple #800080 rgb(128, 0, 128)Red #FF0000 rgb(255, 0, 0)RosyBrown #BC8F8F rgb(188, 143, 143)RoyalBlue #4169E1 rgb(65, 105, 225)SaddleBrown #8B4513 rgb(139, 69, 19)Salmon #FA8072 rgb(250, 128, 114)SandyBrown #F4A460 rgb(244, 164, 96)SeaGreen #2E8B57 rgb(46, 139, 87)SeaShell #FFF5EE rgb(255, 245, 238)Sienna #A0522D rgb(160, 82, 45)Silver #C0C0C0 rgb(192, 192, 192)SkyBlue #87CEEB rgb(135, 206, 235)SlateBlue #6A5ACD rgb(106, 90, 205)SlateGray #708090 rgb(112, 128, 144)Snow #FFFAFA rgb(255, 250, 250)SpringGreen #00FF7F rgb(0, 255, 127)SteelBlue #4682B4 rgb(70, 130, 180)Tan #D2B48C rgb(210, 180, 140)Teal #008080 rgb(0, 128, 128)Thistle #D8BFD8 rgb(216, 191, 216)Tomato #FF6347 rgb(255, 99, 71)Turquoise #40E0D0 rgb(64, 224, 208)Violet #EE82EE rgb(238, 130, 238)VioletRed #D02090 rgb(208, 32, 144)Wheat #F5DEB3 rgb(245, 222, 179)White #FFFFFF rgb(255, 255, 255)WhiteSmoke #F5F5F5 rgb(245, 245, 245)Yellow #FFFF00 rgb(255, 255, 0)YellowGreen #9ACD32 rgb(154, 205, 50)]]></content>
      <tags>
        <tag>Node</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法_递归]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[1.如何理解”递归”？当你在电影院看电影时忘记自己是在第几排，电影院里面太黑看不清，没法数，于是就问前面的人他是第几排，你想只要在他的数字上加1，就知道自己是在哪一排了；但是前面的人也看不清啊，所以他也问他前面的人…就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排把数字传回来，于是你就知道答案了。这就是一个非常标准的递归求解问题的分解过程，去的过程叫”递”，回来的过程叫”归”。基本上，所有的递归问题都可以用递推公式来表示。12f(n)=f(n-1)+1 其中，f(1)=1 2.递归需要满足的三个条件2.1 一个问题的解可以分解为几个子问题的解子问题就是数据规模更小的问题。比如，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。 2.2 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样你在求解“自己在哪一排”的思路，和前一排的人求解“自己在哪一排”的思路是一模一样的。 2.3 存在递归终止条件写递归代码最关键的是写出递推公式，找到终止条件。举个例子：假如这里有n个台阶，每次可以跨1个台阶或2个台阶，请问走完这n个台阶有多少种走法？可以这样思考：走到第n个台阶的走法有两类，第一类是从第n-1阶走了1个台阶，另一类是从n-2阶走了2个台阶。所以n个台阶的走法就等于:(走n-1阶的走法，再走1个台阶)+(走n-2阶的走法，再走2个台阶)，用公式表示就是：1f(n)=f(n-1)+f(n-2) 来看终止条件：当有一个台阶时，就只有一种走法 ，所以f(1)=1。如果递归终止条件只有f(1)=1一个，那f(2)就没法求解了，所以我们可以把f(2)=2作为另一个终止条件。123f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2) 最终的递归代码：12345int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; return f(n-1) + f(n-2);&#125; 总结： 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 3.递归代码要警惕堆栈溢出函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完返回时，才出栈。系统栈或则虚拟机栈空间一般都不大，如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。 4.递归代码要警惕重复计算上述第二个递归例子，如果把整个过程分解一下，如图所示：从图中可以发现，计算f(5)时，要先计算f(4)和f(3),而计算f(4)时还需要计算f(3),因此f(3)被计算了很多次，这就是重复计算问题。重复子问题可以用数组保存中间值的方法来优化，之后动态规划问题会用到这类思想。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——二维数组中的查找]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。时间限制：1秒 空间限制：32768K 解题思路利用二维数组从上到下、从左到右递增的规律，选取右上角或左下角的元素a[i][j]与target比较： 当target小于元素a[i][j]时，那么target必定在元素a[i][j]所在行的左边，即j–； 当target大于元素a[i][j]时，那么target必定在元素a[i][j]所在列的下边，即i++。 1234567891011121314151617class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row=array.size(); int col=array[0].size(); int i=0,j=col-1;//坐标定在右上角 while( i&lt;row &amp;&amp; j&gt;=0)&#123; if(target==array[i][j]) return true; else if(target&lt;array[i][j]) j--;//遇小左移 else i++;//遇大下移 &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>数组</tag>
        <tag>元素查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——把数组排成最小的数]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。时间限制：1秒 空间限制：32768K 解题思路 将数组中的整数数组转换成字符串数组； 自定义一个比较大小的函数，比较两个字符串s1和s2大小的时候，先将它们拼起来，比较s1+s2和s2和s1哪个大，如果s1+s2大，说明s2应该放前面，根据这个规则将所有的字符换排序； 拼接所有的字符串数组中的元素。 123456789101112131415161718class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string res; vector&lt;string&gt; str; for(int i=0;i&lt;numbers.size();i++) str.push_back(to_string(numbers[i])); sort(str.begin(),str.end(),myCompare); for(int i=0;i&lt;str.size();i++) res+=str[i]; return res; &#125;private: static bool myCompare(string &amp;s1,string &amp;s2)&#123; return s1+s2 &lt; s2+s1; &#125;&#125;; tips：1. sort()函数的第三个参数自定义的比较函数返回值类型应该是static bool，不然会报错,但是在其他编译器中只要自定义函数返回的是bool类型的就可以了，没必要是静态函数。 ./solution.h:8:36: error: reference to non-static member function must be calledsort(str.begin(),str.end(),myCompare); 2. 深究STL的sort()函数以前在自定义比较函数时一直都有个疑问，当什么情况下会进行升序排列、什么情况下又进行降序排列呢？传入的两个参数应该如何进行比较？在这里推荐直接看C++技术文档 comp函数返回值：返回一个bool类型的值，这个值表示了在上升序列中第一个参数是否位于第二个参数之前。 如果comp返回true，sort根据返回值将第一个参数排在第二个参数前面； 如果comp返回false，sort根据返回值将第一个参数排在第二个参数后面。 本题中，当s1+s2 &lt; s2+s1时，s1应该排在s2前面，即排序结果能够使数据最小。 总结sort函数根据comp函数的返回值，对comp函数的两个参数排序：如果comp返回true，排序为 参数1、参数2，否则排序为 参数2、参数1。升序排列，则return para1para2]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>数组</tag>
        <tag>sort函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——数组：为什么很多编程语言中数组都从0开始编号？]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前言在每一种编程语言中，基本都会有数组这种数据类型。但它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。大部分编程语言中，数组都是从0开始编号的，但你是否下意识的想过，为什么数组要从0开始编号，而不是从1开始呢？ 从1开始不是更符合人类的思维习惯吗？ 如何实现随机访问？数组(Array)是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。 接下来分两个角度来理解。 第一个是线性表 线性表就是数据拍成向一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈也是线性表结构。 与之对应的是非线性表 。如二叉树、堆、图等，在非线性表中，数据之间并不是简单的前后关系。 第二个是连续的内存空间和相同类型的数据。 因为这两个限制它才有了随机访问的特性，但也让数组的删除、插入变得非常低效，为了保证连续性，就需要做大量的数据搬移工作。 数组是如何实现根据下标随机访问数组元素的呢？拿一个长度为10的int类型的数组int[] a=new int[10]来举例。计算机给数组a分配一块连续内存空间1000-1039，其中内存块的首地址为base_address=1000。计算机通过地址来访问内存中的数据，当计算机需要访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：a[i]_address=base_address+i×data_type_size 面试的时候，经常会问数组和链表的区别，很多人回答说“链表适合插入删除，时间复杂度为O(1)；数组适合查找，查找时间为O(1)”。这种描述是不准确的。数组是适合查找，但是查找的时间复杂度并不为O(1).即使是排好序的数组，用二分查找，时间的复杂度也是O(logn)，所以正确的描述应该是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。 低效的插入和删除数组为了保证内存数据的连续性，会导致插入、删除操作比较低效。现在我们来讨论一下，究竟为什么会导致低效？又有哪些改进方法？ 插入操作假设数组长度为n，现在需要将一个数据插入到数组中的第k个位置，须将k~n这部分的元素都顺序的往后挪一位，平均情况时间复杂度为O(n)。如果数组中的数据是有序的，我们在某个位置插入一个新元素时，就必须安装刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，，在这种情况下，要将某个元素插入到第k个位置，为避免大规模的数据搬移，有一个简单的办法就是直接将第k为的数据搬移到数组元素的最后，把新的元素直接放到第k个位置。这种处理技巧，在特性场景下，在第k个位置插入一个元素的时间复杂度就会降到O(1)。这个处理思想在快排中也会用到。 删除操作和插入类似，如果删除数组末尾的数据，最好情况时间复杂度为O(1),如果删除开头的数据，则最坏情况时间复杂度为O(n),平均情况时间复杂度为O(n)。实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多！例如，数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在要依次删除a,b,c三个元素。为避免多次数据搬移，我们可以先记录下已经删除的数据。每次的删除操作并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 解答开篇问题从数组储存的内存模型来看，“下标”最确切的定义应该是“偏移”，根据前面讲到的寻址公式，如果数组从1开始计数，那么我们计算数组元素a[i]的内存地址就会变成： a[i]_address=base_address+i×data_type_size对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的操作，效率的优化就要尽可能做到极致。数组选择从0开始，而不是从1开始，最主要的原因可能是历史原因。## 相关思考题目### JVM的标记清楚垃圾回收算法的核心理念大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。不足：- 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时效率较高。- 空间问题。会产生不连续的内存空间碎片。### 二维数组的内存寻址公式假设二维数组大小为m*n,则a[i][j]的地址为：a[i][j]_address=base_address+(i×m+j)×data_type_size]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——二进制中1的个数 & 整数中1出现的次数]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20%26%20%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述：二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解法一基本思路： 先判断整数二进制表示中最右边是不是为1，如果是则计数器自增1；接着把输入的整数右移一位，继续判断二进制表示中最右边是否为1，直到整个数变为0为止。代码如下所示，case通过率0.00%，超时引起的，是因为如果输入的是负数，右移时，为保证移位后是一个负数，因此移位后的最高为会设1.如果一直做右移，那么这个数字最终会变为0xFFFFFFFF而陷入死循环。若n=n&gt;&gt;1;改为n/=2;通过率为55.56%，还没找到是什么原因？ 12345678910111213class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n)&#123; if(n&amp;1) res++; n=n&gt;&gt;1; &#125; return res; &#125;&#125;; 解法二基本思路： 为避免死循环，不右移输入的数字，而是定义一个无符号整型变量flag，让flag返回左移，与输入的数字进行与运算，如下：然鹅case通过率为11.11%，看书写的代码，我也不清楚为什么这样！！ 1234567891011121314class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; unsigned int flag=1; while(flag)&#123; if(n&amp;&amp;flag) res++; flag=flag&lt;&lt;1; &#125; return res; &#125;&#125;; 解法三基本思路： 这种解法就厉害了，整数的二进制表示中有几个1就执行几次循环，步骤：把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变为0. 123456789101112class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n)&#123; res++; n=(n-1)&amp;n; &#125; return res; &#125;&#125;; Tips:位运算左移右移计算机表示数字正负不是用+、-号来表示，而是用最高位数字来表示，0表示正，1表示负。 1.有符号右移&gt;&gt;（若正数，高位补0，若负数，高位补1）正数：4&gt;&gt;2 右移两位，高为补0(0000 0000 0000 0000 0000 0000 0000 0100)&gt;&gt;(000000 0000 0000 0000 0000 0000 0000 01)结果为1，即4/(2^2) 负数：-4&gt;&gt;2 (-4的二进制为4的原码取反再加1，如下)右移两位，高位补1(1111 1111 1111 1111 1111 1111 1111 1100)&gt;&gt;(1111 1111 1111 1111 1111 1111 1111 1111)根据上述得到的补码求出源码才是我们所求的结果，保留符号位，然后按位取反再加1，为(100000 0000 0000 0000 0000 0000 0000 01),结果为-1，即-4/(2^2)。 2.无符号右移&gt;&gt;&gt;(无论正负，高位均补0)正数：4&gt;&gt;&gt;2 与4&gt;&gt;2的运算结果相同，结果也是1 负数：-4&gt;&gt;&gt;2(1111 1111 1111 1111 1111 1111 1111 1100)&gt;&gt;&gt;(0011 1111 1111 1111 1111 1111 1111 1111)结果为1073741823 3.左移&lt;&lt;(不区分有符号和无符号)分析num&lt;&lt;n 相当于num(num的二进制)向左移动n位； 左边(高位)溢出部分直接舍弃；右边(低位)移入部分全部补0； 移位结果：若左移时舍弃的高位不包括1，则没左移一位，就相当于该数乘以2.(左移有可能导致符号变化) 题目描述：整数中1出现的次数求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解法一：暴力解决累加1~n中每个正数1的个数。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int res=0; for(int i=1;i&lt;=n;i++)&#123; res+=numberOf1(i); &#125; return res; &#125;private: int numberOf1(unsigned int i)&#123; int res=0; while(i)&#123; if(i%10==1) res++; i/=10; &#125; return res; &#125;&#125;; 解法二：找规律1的数目： 如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定（若没有高位，视高位为0），等于更高位数字X当前位数的权重10^(i-1); 如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响（若没有低位，视低位为0），等于更高位数字X当前位数的权重10^i-1+（低位数字+1）; 如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），等于（更高位数字+1）X当前位数的权重10i-1。 X的数目：这里的X∈[1,9],因为X=0不符合下列规律，需单独计算。首先直到以下的规律： 从1-10，在它们的个位数中，任意的X都出现了1次； 从1-100，在它们的十位数中，任意的X都出现了10次； 从1-1000，在它们的百位数中，任意的X都出现了100次； 依次类推，从1-10^i,在他们的左边第二位(右数第i位)中，任意的X都出现了10^i-1次。 接下来以n=2593，X=5为例来解释如何得到数学公式。从1至2593中，数字 5 总计出现了 813 次，其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。 首先是个位。从 1 至 2590 中，包含了 259 个 10，因此任意的 X 都出现了 259 次。最后剩余的三个数 2591, 2592 和 2593，因为它们最大的个位数字 3 &lt; X，因此不会包含任何 5。（也可以这么看，3&lt;X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字（259）X10^(1-1)=259）； 然后是十位。从 1 至 2500 中，包含了 25 个 100，因此任意的 X 都出现了 25×10=250 次。剩下的数字是从 2501 至 2593，它们最大的十位数字 9 &gt; X，因此会包含全部 10 个 5。最后总计 250 + 10 = 260。（也可以这么看，9&gt;X，则十位上可能出现的X的次数仅由更高位决定，等于更高位数字（25+1）X10^(2-1)=260）； 接下来是百位。从 1 至 2000 中，包含了 2 个 1000，因此任意的 X 都出现了 2×100=200 次。剩下的数字是从 2001 至 2593，它们最大的百位数字 5 == X，这时情况就略微复杂，它们的百位肯定是包含 5 的，但不会包含全部 100 个。如果把百位是 5 的数字列出来，是从 2500 至 2593，数字的个数与百位和十位数字相关，是 93+1 = 94。最后总计 200 + 94 = 294。（也可以这么看，5==X，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，等于更高位数字（2）X10^(3-1)+（93+1）=294）； 最后是千位。现在已经没有更高位，因此直接看最大的千位数字 2 &lt; X，所以不会包含任何 5。（也可以这么看，2&lt;X，则千位上可能出现的X的次数仅由更高位决定，等于更高位数字（0）X10^(4-1)=0）。 总结一下以上的算法，可以看到，当计算右数第 i 位包含的 X 的个数时： 取第 i 位左边（高位）的数字，乘以 10^i−1 ，得到基础值 a 。 取第 i 位数字，计算修正值： 如果大于 X，则结果为 a+ 10^i−1 。 如果小于 X，则结果为 a 。 如果等 X，则取第 i 位右边（低位）数字，设为 b ，最后结果为 a+b+1 。 相应的代码非常简单，效率也非常高，时间复杂度只有 O(log_10^n) 。 123456789101112131415161718192021222324class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int res=0; int high,low,tmp,cur,i=1; high=n; while(high)&#123; high=n/(int)pow(10,i);//求第i位的高位 tmp=n%(int)pow(10,i); cur=tmp/(int)pow(10,i-1);//求第i位的值 low=tmp%(int)pow(10,i-1);//求第i位的低位 if(cur==1) res+=high*(int)pow(10,i-1)+low+1; else if(cur&lt;1) res+=high*(int)pow(10,i-1); else res+=(high+1)*(int)pow(10,i-1); i++; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>二进制</tag>
        <tag>数1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法(一)]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[操作系统做了什么看不下去了！！！]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——复杂度分析]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据结构与算法概念理解从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。狭义上讲，就是指某些著名的数据结构和算法。 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、回溯算法、分治算法、动态规划、字符串匹配算法。 上面最常用、最基础的20个数据结构与算法，要学习它们的”来历”、”特点”、”适合解决什么问题”以及”实际的应用场景”。 下面放一张数据结构和算法的知识图谱：数据结构是为算法服务的，算法要作用在特定的数据结构之上。 那么接下来就开始学习一个数据结构与算法中最重要的概念——复杂度分析。 复杂度分析(上)——如何分析、统计算法的执行效率和资源消耗事后统计法把代码跑一边，通过统计、监控就能得到算法执行的时间和占用的内存大小。但是这种统计法有非常大的局限性。 测试结果非常依赖测试环境 测试结果受数据规模的影响很大，比如对同一个算法，待排序的数据有序度不一样，排序的时间会有河大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作执行时间非常短。此外，测试数据规模小，测试结果无法真实的反应算法的性能。比如对于小规模的数据排序，插入排序可能回避快排要块！ 大O表示法 大O时间复杂度表示法T(n)=O(f(n))其中T(n)表示代码执行的时间，n表示数据规模大小，f(n)表示每行代码执行的次数总和。公式中的O表示代码的执行时间T(n)与f(n)表达式成正比。 时间复杂度分析 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度示例分析对于复杂度量级，可以粗略的分为多项式量级 和非多项式量级 。如下图： O(1)代码执行的时间不随n的增大而增大。算法中不存在循环递归语句，即使有千万行代码，其时间复杂度也是O(1)。 O(logn)、O(nlogn) 1234int i=1;while(i&lt;=n)&#123; i*=2; &#125; 归并排序、快速排序的时间复杂度就是O(nlogn)。 O(m+n)、O(m*n)代码的复杂度由两个数据的规模来决定。 空间复杂度常见的空间复杂度就是O(1)、O(n)、O(n^2)。 复杂度分析(下)——浅析最好、最坏、平均、均摊时间复杂度最好、最坏时间复杂度例如，在一个无序数组中查找变量x。如果数组中第一个元素就是要查找的变量x，那就不需要遍历剩下的n-1个数据了，最好时间复杂度为O(1)。但如果数组中不存在x，那就要把数组遍历一遍，最坏时间复杂度为O(n)。 平均情况时间复杂度依然分析查找变量x的例子：要查找的变量x在数组中的位置，有n+1中情况：在数组的0~n-1为之中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后除以n+1，就可以得到需要遍历的元素个数的平均值。上面的推导存在一个问题就是没有把各种情况发生的概率考虑进去。假设变量x在或不在数组中的概率都为1/2，要查找的数据出现在0~n-1这n个位置的概率也是一样的，为1/n。 均摊时间复杂度 // array 表示一个长度为 n 的数组 // 代码中的 array.length 就等于 n int[] array = new int[n]; int count = 0; void insert(int val) { if (count == array.length) { int sum = 0; for (int i = 0; i &lt; array.length; ++i) { sum = sum + array[i]; } array[0] = sum; count = 1; } array[count] = val; ++count; } 假设数组的长度为n，根据数据插入的位置的不同，可以分为n种情况，每种情况的时间复杂度都是O(1)。此外还有一种额外的情况，就是在数组没有空间时间时插入一个数据，这时时间复杂度为O(n)。而且，这n+1种情况发生的概率一样，都是1/(n+1)。所以根据加权平均的计算方法，求得的平均时间复杂度就是：对于insert()函数来说，O(1)时间的插入和O(n)时间的插入出现的频率是非常有规律的，而且有一定的前后时序关系，一个O(n)插入之后紧跟着n-1个O(1)的插入操作，循环往复。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo及GitPage搭建博客]]></title>
    <url>%2F2019%2F03%2F20%2F%E4%BD%BF%E7%94%A8Hexo%E5%8F%8AGitPage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面刚开始使用GitHub，看到别人在git上搭建的博客很简洁优美，简直就是一片净土，于是自己也来试试！在搭建的过程中遇到了一些问题，再此做个记录。也算是自己的第一篇文章 :) 1.概述Git Pages本来是用于介绍托管在GitHub上的项目，不过，由于它的空间免费稳定，非常适合搭建一个博客。也可以认为是用户编写的、托管在GitHub上的静态网页。目前有两大静态博客主流框架：Jekyll和hexo。但是看到网上很多人吹捧hexo，于是直接放弃Jekyll，开始了hexo+GitHub搭建博客的第一步（在搭建的过程中，发现使用jekyll很简单，等会儿会提到我是如何偶遇它的）。hexo是一个快速、简洁且高效的博客框架，使用markdown解析文章，使用Node.js渲染界面( Hexo Themes上有很多主题以及各种功能，可参考博客我的个人博客之旅：从jekyll到hexo)。 2.搭建步骤2.1环境准备 安装Node.js,用来安装博客框架、渲染主题等。 安装Git，用来下载主题、提交、部署文章等。 2.2安装Hexo运行git bash，执行下面第一条命令安装hexo，第二条用于检查hexo安装的版本,第三条用于初始化hexo，hexo会自动下载一些文件到这个目录，包括node_modules。 $ npm install -g hexo-cli $ hexo -v $ hexo init 2.3建站及本地测试找一个合适的文件夹新建所需文件,第一条在指定文件夹创建所需文件(并初始化)，第三条安装所需组件.第四条开启服务器，访问localhost:4000(默认端口4000，ctrl+c关闭server)即可体验。 $ hexo init myBlog $ cd myBlog $ npm install $ hexo S 在hexo文件夹下执行命令： hexo generate 或者 hexo g //生成静态页面至public目录,public文件夹内的内容是要提交到GitHub上的 hexo server 或 hexo s //开启预览访问端口(开启本地服务) 2.4主题下载和配置使用命令下载主题，然后修改myBlog文件夹下的_config.yml(网站的配置文件，等会儿和github关联时也会修改改配置)。 $ cd themes $ git init $ git clone https://github.com/iissnan/hexo-theme-next.git 2.5将hexo和Git Pages关联起来2.5.1准备工作 注册GitHub账号https://github.com/，并设置Git的user name和email 配置ssh-key 代码库的设置：创建名为 “用户名.github.io” 的仓库，星号表示用户名，创建好之后访问https://zuiing.github.io 即可。插曲：以前我建立过一个git网页博客，但是今天配置hexo时不成功就删除又建了一个，但是域名变为https://zuiing.github.io/zuiing.github.io，如果访问https://zuiing.github.io 出现下面的错误：表示域名已经能够解析到，但是还需要配置，进入仓库zuiing.github.io-&gt;Setting;我的操作是Rename一下，又点了Git Pages中的”Choose a theme”(在这里偶遇了yekyll)，然后就点开了下图中的网页博客链接,就神奇的好了，而且还有了主题，惊喜！ 2.5.2正式开始部署，即设置deployment npm install hexo-deployer-git –save 在网站配置文件 _config.yml中有关deploy部分：修改仓库地址,需要特别注意的是冒号后面一定要有一个空格，以及这里使用的是ssh协议而不是http协议(刚开始我使用的http协议，执行hexo d之后一直关联不成功，估计和协议有关系)，前提是确保在Github上已经添加了公钥。 执行 hexo d 即可发布到Github仓库，其实我的过程远不像上面写的那么简单，在经历了千辛万苦之后总算成功了，这简直就是今天最开心的事儿了！还有，有网友建议每次都按下面的执行顺序来： hexo clean hexo generate hexo deploy 新增或修改主题之后请执行 hexo clean &amp;&amp; hexo d 清理缓存文件并部署。 2.6未知我知道现在才成功了一步，自己对git和hexo的了解还非常少，继续探索啦啦啦，做一个努力的小仙女儿！！！2019/03/20更 3.上传md文件图片无法显示的坑(下面是填坑过程)3.1问题介绍在sourse文件夹下建了一个img文件夹用于存储md插入图片，生成并上传到git之后，发现图片被存在了’用户名.github.io/img’文件夹下,如下图 打开博客网页却看不到图片，肯定是因为生成的index.html格式的文件图片路径不对，导致在GitHub上找不到图片,于是开始网上找解决方案，大部分说辞都差不多，例如hexo博客图片问题### 3.2开始动手1. 确认_config.yml中的post_asset_folder:true；Hexo提供了一种方便管理Asset的设定post_asset_folder，当设置为true后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，可以把该文章相关的所有资源都放到那个文件夹，这样便可以更方便的使用资源。2. 在Hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save3. 安装完成后用hexo创建文章时会发现_posts目录下面会多出一个和文章名字一样的文件夹，图片就放文件夹内即可。4. 接下来是测试图片的过程，图片插入格式如下图：5. hexo g生成之后先去本地public文件夹下看看index.yml中的路径，如下图：真是活见鬼，刚刚测试的时候在index.yml中第一张的路径是要比第二张的路径多一个testImg的(src=”/2019/03/20/testImg/testImg/test.JPG”),现在却都一样，而且在md文档中第二种写法没法直接预览图片，既然这样就是用第一种插入方法吧，anyway，图片插入的问题算是解决了。6. 在博客上查看结果如下： 4.上传md文件格式杂乱 md文档在本地格式正常，但上传到git上就很乱糟糟，如图： 很奇怪的是当我搞好图片显示问题之后，这个问题就自动好了，但我觉得二者之间没太大联系，可能是网页更新显示太慢的原因，如下图： 在用md写文档或插入代码的时候总出错，这里有篇还不错的博文，可以学习下markdown的语法 Markdown语法你都会了吗？,以及在markDown中输入数学公式。 在操作的过程中总是会遇到各种怪象，太菜啦，要被自己蠢哭了 :( 插入图片时，图片所在目录不要有中文，不然本地的markdown都找不到在哪 markdown文档名字与文档中title的名字最好一致，不然上传到gitpages之后文档中的格式会消失，这个问题搞了好几天才发现！！！2019/03/20更 5.hexo next主题配置我的博客配置参考了这篇文章，写的非常详细，效果也很美！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>hexo&amp;GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
