<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数学]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode%E5%88%B7%E9%A2%98%2F%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[质数的个数 204.Count Primes(Easy)解题思路：需要一个长度为n-1的bool类型的数组来记录每个数字是否被标记过，初始化为true；从2开始遍历到n-1，先找到第一个质数2，然后将其所有的倍数全部标记出来，然后到下一个质数，标记其所有质数，以此类推。 12345678910111213141516class Solution &#123;public: int countPrimes(int n) &#123; int res=0; vector&lt;bool&gt; prime(n,true); for(int i=2;i&lt;n;i++)&#123; if(prime[i])&#123; res++; for(int j=i*2;j&lt;n;j+=i) prime[j]=false; &#125; &#125; return res; &#125;&#125;; 七进制 504.Base 7(Easy)1234567891011121314class Solution &#123;public: string convertToBase7(int num) &#123; if(num==0) return &quot;0&quot;; string res=&quot;&quot;; bool positive=num&gt;0; while(num)&#123; res=to_string(abs(num%7))+res; num/=7; &#125; return positive?res:&quot;-&quot;+res; &#125;&#125;; 16进制 405.Convert a Number to Hexadecimal(Easy)1234567891011121314class Solution &#123;public: string toHex(int num) &#123; string res=&quot;&quot;; for(int i=0;num&amp;&amp;i&lt;8;i++)&#123; int t=num&amp;0xf; if(t&gt;=10) res=char(&apos;a&apos;+t-10)+res; else res=char(&apos;0&apos;+t)+res; num&gt;&gt;=4; &#125; return (res.empty())?&quot;0&quot;:res; &#125;&#125;; 求excel列表名称 168.Excel Sheet Column Title(Easy)123456789101112class Solution &#123;public: string convertToTitle(int n) &#123; string res=&quot;&quot;; while(n)&#123; res+=--n%26+&apos;A&apos;; n/=26; &#125; return string(res.rbegin(),res.rend()); &#125;&#125;; 求阶乘末尾0的个数 172.Factorial Trailing Zeroes(Easy)解题思路：求一个数的阶乘末尾0的个数，即找乘数中10的个数，而10=2*5，其中2的数量又远大于5的数量，那么该题即为找出5的个数；需要注意的是，像25、125这样的数字不知含有一个额5. 123456789101112class Solution &#123;public: int trailingZeroes(int n) &#123; int res=0; while(n)&#123; res+=n/5; n/=5; &#125; return res; &#125;&#125;; 二进制加法 67.Add Binary(Easy)解题思路：用两个指针m和n分别指向两个字符串的末尾，然后每次取出一个字符，转换为数字，若无法取出字符则按0处理，进位carry初始化为0，将三者加起来，对2取余即为当前位的数字，对2取商即为当前进位的值。 12345678910111213141516class Solution &#123;public: string addBinary(string a, string b) &#123; string res=&quot;&quot;; int m=a.size()-1,n=b.size()-1,carry=0; while(carry||m&gt;=0||n&gt;=0)&#123; int p=m&gt;=0?a[m--]-&apos;0&apos;:0; int q=n&gt;=0?b[n--]-&apos;0&apos;:0; int sum=p+q+carry; res=to_string(sum%2)+res; carry=sum/2; &#125; return res; &#125;&#125;; 字符串加法 415.Add Strings(Easy)12345678910111213141516class Solution &#123;public: string addStrings(string num1, string num2) &#123; string res=&quot;&quot;; int m=num1.size()-1,n=num2.size()-1,carry=0; while(carry||m&gt;=0||n&gt;=0)&#123; int a=m&gt;=0?num1[m--]-&apos;0&apos;:0; int b=n&gt;=0?num2[n--]-&apos;0&apos;:0; int sum=a+b+carry; res=to_string(sum%10)+res; carry=sum/10; &#125; return res.empty()?&quot;0&quot;:res; &#125;&#125;; 最少移动次数使数组元素相等 453.Minimum Moves to Equal Array Elements(Easy)Input:[1,2,3] Output:3 Explanation:Only three moves are needed (remember each move increments two elements): [1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 题目描述：题目给我们一个长度为n的数组，每次可以对n-1个数字同时加1，问最少需要多少次这样的操作才能让数组中所有的数字相等。 解题思路：为了快速缩小差距，应该选择除了数组最大值的所有数字加1，这样能快速到达平衡状态。但是如果每次都找出最大值，然后给其他的数字加1，效果等同于让最大值减1，比如[1,2,3]，将除去最大值的其他数字加1，变为[2,3,3]，全体减1，并不影响数自减相对差异，变为[1,2,2],这个结果其实就是原始数组的最大值3自减为1，傲梦问题就转化为了：将所有数字都减小到最小值，这样难度就大大降低了，只需要先找到最小值，然后累加每个数跟最小值之间的差值即(给除了最大值外的每个数自增1，相当于给某个数自减1)。 12345678910class Solution &#123;public: int minMoves(vector&lt;int&gt;&amp; nums) &#123; int res=0,mn=INT_MAX; for(int i=0;i&lt;nums.size();i++) mn=min(mn,nums[i]); for(int i=0;i&lt;nums.size();i++) res+=abs(nums[i]-mn); return res; &#125;&#125;; 解题思路：也可以求出数组的数字之和sum，然后减去最小值与数组长度的乘积。 123456789101112class Solution &#123;public: int minMoves(vector&lt;int&gt;&amp; nums) &#123; int mn=INT_MAX,sum=0; for(int i=0;i&lt;nums.size();i++)&#123; mn=min(mn,nums[i]); sum+=nums[i]; &#125; return sum-mn*nums.size(); &#125;&#125;; bug：先求和的话，会越界哦！如测试数据[1,2147483647] 最少移动次数使数组元素相等II [453.Minimum Moves to Equal Array Elements]Input:[1,2,3] Output:2 Explanation:Only two moves are needed (remember each move increments or decrements one element): [1,2,3] =&gt; [2,2,3] =&gt; [2,2,2] 题目描述：可以每次对任意一个数字加1或减1操作，用最少的次数让数组所有制相等。 解题思路：这题用到Best Meeting Point那道题的思想。首先给数组排序，那么我们最终需要变成的相等的数字就是中间的数，如果数组有奇数个，那么就是最中间的那个那个数字，如果是有偶数个，那么就是中间两个数的区间中的任意一个数字。而两端的数字变成中间的一个数字需要的步数其实就是两端数字的距离。 123456789101112class Solution &#123;public: int minMoves2(vector&lt;int&gt;&amp; nums) &#123; int res=0,i=0,j=nums.size()-1; sort(nums.begin(),nums.end()); while(i&lt;j)&#123; res+=nums[j--]-nums[i++]; &#125; return res; &#125;&#125;; 或者：123456789101112class Solution &#123;public: int minMoves2(vector&lt;int&gt;&amp; nums) &#123; int res=0,mid=nums.size()/2; sort(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size();i++)&#123; res+=abs(nums[i]-nums[mid]); &#125; return res; &#125;&#125;; 又或者：不需全部排序，用STL自带的nth_element求第n大值，并把它放在第n位置上。123456789101112class Solution &#123;public: int minMoves2(vector&lt;int&gt;&amp; nums) &#123; int res=0,mid=nums.size()/2; nth_element(nums.begin(),nums.begin()+mid,nums.end()); for(int i=0;i&lt;nums.size();i++)&#123; res+=abs(nums[i]-nums[mid]); &#125; return res; &#125;&#125;; 补充：最佳开会地点 [296.Best Meeting Point(Hard)]1234567891011121314A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.For example, given three people living at (0,0), (0,4), and (2,2):1 - 0 - 0 - 0 - 1| | | | |0 - 0 - 0 - 0 - 0| | | | |0 - 0 - 1 - 0 - 0The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.Hint:Try to solve it in one dimension first. How can this solution apply to the two dimension case? 解题思路：求最佳的开会地点，该地点需要到每个为1的点的曼哈顿距离之和最小，题目中给的提示是让我们先从一维的情况来分析，先看一维时有两个点A和B的情况，``` 1234可以发现，只要开会位置P在[A,B]区间内，不管在哪，距离之和都是A和B之间的距离，如果P不在[A,B]之间，那么距离之和就会大于A和B之间的距离,再加上两个点C、D： ```___C___A___P___B___D___``` 通过分析可以得出，P点的最佳位置就在[A,B]区间内，这样和四个点的距离之和就是AB距离加上CD距离。 因此只要给位置排好序，然后用最后一个坐标减去第一个坐标，倒数第二个坐标减去第二个坐标，直到中间为止,下面就直接贴大佬的代码好了。 class Solution { public: int minTotalDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;int&gt; rows, cols; for (int i = 0; i &lt; grid.size(); ++i) { for (int j = 0; j &lt; grid[i].size(); ++j) { if (grid[i][j] == 1) { rows.push_back(i); cols.push_back(j); } } } return minTotalDistance(rows) + minTotalDistance(cols); } int minTotalDistance(vector&lt;int&gt; v) { int res = 0; sort(v.begin(), v.end()); int i = 0, j = v.size() - 1; while (i &lt; j) res += v[j--] - v[i++]; return res; } }; 1234# 多数投票问题## 求众数 [169.Majority Element(Easy)](https://leetcode.com/problems/majority-element/description/)解题思路：摩尔投票法Moore Voting；先将第一个数假设为过半数，然后把计数器加1，比较下一个数和次数是否相等，若相等则计数器加1，反之则减1.然后看此时计数器的值，若为0，则将下一个值设为候选过半数。 class Solution { public: int majorityElement(vector&lt;int&gt;&amp; nums) { int res=0,cnt=0; for(int num:nums){ if(cnt==0){res=num;cnt++;} else{ num==res?cnt++:cnt--; } } return res; } }; 12或者： class Solution { public: int majorityElement(vector&lt;int&gt;&amp; nums) { int res=0,n=nums.size(); for(int i=0;i&lt;32;i++){ int ones=0,zeros=0; for(int num:nums){ if(ones&gt;n/2||zeros&gt;n/2) break; if((num&amp;(1&lt;&lt;i))!=0) ones++; else zeros++; } if(ones&gt;zeros) res|=(1&lt;&lt;i); } return res; } }; 1234## 检验完全平方数 [367.Valid Perfect Square(Easy)](https://leetcode.com/problems/valid-perfect-square/description/)解题思路：二分法，要查找的数为mid*mid. class Solution { public: bool isPerfectSquare(int num) { int l=0,r=num; while(l&lt;=r){ int mid=l+(r-l)/2,t=mid*mid;//求t时容易越界 if(t==num) return true; else if(t&lt;num) l=mid+1; else r=mid-1; } return false; } }; 1或者： class Solution { public: bool isPerfectSquare(int num) { for(int i=1;i&lt;=(int)sqrt(num);i++){ if(i*i==num) return true; } return false; } }; 123456789又或者：找数学规律求解，完全平方数就是一系列奇数之和： 1 = 1 4 = 1 + 3 9 = 1 + 3 + 5 16 = 1 + 3 + 5 + 7 25 = 1 + 3 + 5 + 7 + 9 36 = 1 + 3 + 5 + 7 + 9 + 11 .... 1+3+...+(2n-1) = (2n-1 + 1)n/2 = n*n class Solution { public: bool isPerfectSquare(int num) { int i=1; while(num&gt;0){ num-=i; i+=2; } return num==0; } }; 1234## 判断3的次方数 [326.Power of Three(Easy)](https://leetcode.com/problems/power-of-three/description/)解题思路：将n不停的除3，看最后的迭代商是否为1，需考虑输入的是负数和0的情况。 class Solution { public: bool isPowerOfThree(int n) { while(n&amp;&amp;n%3==0){ n/=3; } return n==1; } }; 1或者：由于输入的是int，整数范围是0~2^31，在该范围内允许的最大的3的次方数是3^19=1162261467,那么只要看这个数能够被n整数即可。 class Solution { public: bool isPowerOfThree(int n) { return n&gt;0&amp;&amp;(1162261467%n==0); } }; 123456## 出本身外的数组之积 [238.Product of Array Except Self(Medium)](https://leetcode.com/problems/product-of-array-except-self/description/)题目描述：给定一个数组，让我们返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，并且限制了时间复杂度O(n)，并且不能用除法。接替思路：对于一个数字，如果知道其前面所有数字的乘积，同时也知道后面所有的数乘积，那么二者相乘就是我们要的结果；因此需要分别创建出这两个数组，分贝从数组的两个方向遍历就可以分别创建出乘积累积数组。 class Solution { public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int n=nums.size(); vector&lt;int&gt; fwd(n,1),bwd(n,1),res(n); for(int i=0;i&lt;n-1;i++){ fwd[i+1]=fwd[i]*nums[i]; } for(int i=n-1;i&gt;0;i--) bwd[i-1]=bwd[i]*nums[i]; for(int i=0;i&lt;n;i++) res[i]=fwd[i]*bwd[i]; return res; } }; 1或者：不需要使用单独的数组，直接将乘积累积存入res中，先从前往后遍历，再从后往前遍历，需要用到一个临时变量right，初始化为1。 class Solution { public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int n=nums.size(); vector&lt;int&gt; res(n,1); for(int i=1;i&lt;n;i++) res[i]=res[i-1]*nums[i-1]; int right=1; for(int i=n-1;i&gt;=0;i--){ res[i]*=right; right*=nums[i]; } return res; } }; 123456## 三个数字的最大乘积 [628.Maximum Produc of Three Numbes(Easy)](https://leetcode.com/problems/maximum-product-of-three-numbers/description/)Input: [1,2,3,4] Output: 24解题思路：若全是正数，则排序后末尾三个数相乘即可；若全是负数，同样排序后末尾三个数相乘就是结果；若存在负数和整数，那么最好的情况肯定是两个最小的负数和一个最大的正数相乘，就可以得到最大的乘积。 class Solution { public: int maximumProduct(vector&lt;int&gt;&amp; nums) { int res=1,n=nums.size(); sort(nums.begin(),nums.end()); int t=nums[0]*nums[1]*nums[n-1]; return max(t,nums[n-1]*nums[n-2]*nums[n-3]); } }; `或者：找出3个最大的数和两个最小的数，来比较两种情况下的乘积，时间复杂度为O(n).]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>数学相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2019%2F04%2F06%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[验证变位词 242.Valid Anagram(Easy)s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. 解题思路：可以用哈希表映射字符和出现次数，然后比较两个字符串出现的字符数量是否相等，由于本题的字符串只包含26个小写字符，因此可以用长度为26的数组对字符串出现的字符次数进行统计。 12345678910111213class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.size()!=t.size()) return false; int m[26]=&#123;0&#125;; for(int i=0;i&lt;s.size();i++) m[s[i]-&apos;a&apos;]++; for(int i=0;i&lt;t.size();i++)&#123; if(--m[t[i]-&apos;a&apos;]&lt;0) return false; &#125; return true; &#125;&#125;; 最长回文串 409.Longest Palindrome(Easy)Input : “abccccdd”Output : 7Explanation : One longest palindrome that can be built is “dccaccd”, whose length is 7. 解题思路：题目给我们一个字符串，让找出可以组成的最长的回文串的长度，由于字符顺序可以打乱，所以问题就转化成了求偶数个字符的个数；回文串有两种形式，一种是左右完全对称的，比如noon，还有一种是以中间字符为中心左右对车，比如level，那么我们只需统计出所有偶数个字符的出现总和，然后如果有奇数个字符的话，就取出其最大偶数，然后最终的结果加1即可。123456789101112131415161718class Solution &#123;public: int longestPalindrome(string s) &#123; int res=0; bool odd=false; unordered_map&lt;char,int&gt; m; for(int i=0;i&lt;s.size();i++) m[s[i]]++; for(auto it=m.begin();it!=m.end();it++)&#123; res+=it-&gt;second; if(it-&gt;second%2)&#123; res-=1; odd=true; &#125; &#125; return odd?res+1:res; &#125;&#125;; 同构字符串 205.Isomorphic Strigns(Easy)Given “egg”, “add”, return true.Given “foo”, “bar”, return false.Given “paper”, “title”, return true. 题目描述：求同构字符串，就是说字符串中的每个字符可由另外一个字符替代，相同的字符一定要被同一个字符替代，且一个字符不能被多个字符替代，即不能出现一对多的映射。 解题思路：根据一对一映射的特点，可以用两个哈希表分别记录原字符串和目标字符串中字符出现情况；由于ASCII码只有256个字符，因此可以用一个大小为256的数组来代替哈希表，并初始化为0；遍历数组，分别从源字符串和目标字符串取出一个字符，然后分别在两个哈希表中查找值，若不相等，返回false，若相等，将其值更新为i+1；由于初始值为0，所以更新值为i+1，这样当i=0时，映射为1，如果不加1，就没法区分第一个字符是否被更新了。 12345678910111213class Solution &#123;public: bool isIsomorphic(string s, string t) &#123; int ms[256]=&#123;0&#125;,mt[256]=&#123;0&#125;; for(int i=0;i&lt;s.size();i++)&#123; if(ms[s[i]]!=mt[t[i]]) return false; ms[s[i]]=i+1; mt[t[i]]=i+1; &#125; return true; &#125;&#125;; 回文子字符串 647.Palindromic Substrings(Medium)Input: “aaa”Output: 6Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”. 解题思路：以字符串的每个字符当作回文串中间的位置，然后向两边扩展，每成功匹配左右两个相等的字符，res自增1，然后比较下一对；注意会问字符串有奇数和偶数两种形式，如果是奇数长度，那么位置i就是中间那个字符的位置，所以左右两边都从i开始遍历；如果是偶数长度的，那么i是最中间两个字符的左边那个，右边的就是i+1，这样就能找到所有的回文子字符串啦！ 123456789101112131415161718class Solution &#123;public: int countSubstrings(string s) &#123; if(s.size()==0) return 0; int res=0; for(int i=0;i&lt;s.size();i++)&#123; helper(s,i,i,res); helper(s,i,i+1,res); &#125; return res; &#125; void helper(string &amp;s,int i,int j,int &amp;res)&#123; while(i&gt;=0&amp;&amp;j&lt;=s.size()&amp;&amp;s[i]==s[j])&#123; i--;j++;res++; &#125; &#125;&#125;; 验证回文数字 9.Palindrome Number(Easy)解题思路：由于不能将数字转换为字符串，而是直接对整数进行操作，可以利用取整和取余求出前后的数字然后比较。1234567891011121314151617class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0) return false; int div=1; while(x/div&gt;=10) div*=10; while(x)&#123; int left=x/div; int right=x%10; if(left!=right) return false; x=(x%div)/10; div/=100; &#125; return true; &#125;&#125;; 统计二进制子字符串 696.Count Binary Substrings(Easy)Input: “00110011”Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1’s and 0’s: “0011”, “01”, “1100”, “10”, “0011”, and “01”. 题目描述：给我们一个二进制字符串，统计具有0和1的个数，且0和1搁在都群组在一起(即0和1不能交替出现)的自字符串的个数。 解题思路：看题目中的例子，00110011，当第一个1出现的时候，由于前面两个0，所以一定能组成01，再遇到下一个1时，组成0011；下一个遇到0时，此时0的个数重置为1，而前面1的个数有两个，一定能组成10，同理，下一个为0，能组成1100。可以发现，只要分别统计0和1的个数，如果当前遇到的是1，那么只要之前统计的0的个数大于等于当前1的个数，就一定有一个对应的子字符串，而一旦前一个数字和当前的数字不一样的时候，那么当前数字的计数要重置为1。遍历数组时，若是第一个数字，则对应的ones和zeros自增1，然后分情况讨论，若当前数字是1，然后判断如果前面数字也是1，则ones自增1，否则ones重置为1，如果zeros&gt;=ones，res自增1.反之同理。 123456789101112131415161718192021class Solution &#123;public: int countBinarySubstrings(string s) &#123; int ones=0,zeros=0,res=0; for(int i=0;i&lt;s.size();i++)&#123; if(i==0)&#123; (s[i]==&apos;1&apos;)?ones++:zeros++; &#125;else&#123; if(s[i]==&apos;1&apos;)&#123; ones= (s[i-1]==&apos;1&apos;)?ones+1:1 ; if(zeros&gt;=ones) res++; &#125;else&#123; zeros= (s[i-1]==&apos;0&apos;)?zeros+1:1; if(ones&gt;=zeros) res++; &#125; &#125; &#125; return res; &#125;&#125;; #补充 验证回文串 125.Valid Palindrome(Easy)Input: “A man, a plan, a canal: Panama”Output: true 题目描述：本题与单独验证一个单词是否是回文字符串的区别就是加入了空格和非字母数字的字符。 解题思路：建立两个指针i和j，分别从字符串的开头和结尾开始遍历整个字符串；如果遇到非字母数字的字符就跳过，继续往中间找，如果遇到大写字母就将其转为小写；当左右指针都找到字母数字时，可以进行比较时，如果相等则两个指针向中间移动，然后继续比较下面两个分别找到的字母数字，若不想等，直接返回false。 12345678910111213141516171819202122class Solution &#123;public: bool isPalindrome(string s) &#123; if(s.size()==0) return true; int i=0,j=s.size()-1; while(i&lt;j)&#123; if(!isLetterOrDigit(s[i])) i++; else if(!isLetterOrDigit(s[j])) j--; else&#123; if(s[i]&gt;=&apos;A&apos;&amp;&amp;s[i]&lt;=&apos;Z&apos;) s[i]+=32; if(s[j]&gt;=&apos;A&apos;&amp;&amp;s[j]&lt;=&apos;Z&apos;) s[j]+=32; if(s[i]!=s[j]) return false; i++;j--; &#125; &#125; return true; &#125; bool isLetterOrDigit(char c)&#123; return (c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)||(c&gt;=&apos;a&apos;&amp;&amp;c&lt;=&apos;z&apos;)||(c&gt;=&apos;A&apos;&amp;&amp;c&lt;=&apos;Z&apos;); &#125;&#125;; 分割回文串 131.Palindrome Partitioning(Medium)Input: “aab”Output:[ [“aa”,”b”], [“a”,”a”,”b”]] 题目描述：题目要求找到所有可能拆分成回文串的情况，那么肯定是所有的情况都要遍历到，对于每一个子字符串都要分别判断一次是不是回文数，因此需要一个判断回文数的子函数。 解题思路：将已经检测好的回文子串放到字符串数组out中，当s遍历完之后，将out加入结果res中。那么在递归函数中我们必须要知道当前遍历到的位置，用变量start表示，所以在递归函数中，如果start等于字符串s的长度，说明遍历完成，将out加入res中，并返回，否则就从start处开始遍历，即从start开始的一个字符、两个字符、三个字符…首先判断取出的字符串是否是回文串，若是回文串那么将其加入out，并调用递归函数判断剩下的字符串是否存在回文串，此时start传入i+1，之后还要恢复out的状态。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; if(s.size()==0) return &#123;&#125;; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; out; helper(s,0,out,res); return res; &#125; void helper(string &amp;s,int start,vector&lt;string&gt; &amp;out,vector&lt;vector&lt;string&gt;&gt; &amp;res)&#123; if(start==s.size()) &#123;res.push_back(out);return;&#125; for(int i=start;i&lt;s.size();i++)&#123; if(!isPalindrome(s,start,i)) continue; out.push_back(s.substr(start,i-start+1)); helper(s,i+1,out,res); out.pop_back(); &#125; &#125; bool isPalindrome(string &amp;s,int start,int end)&#123; if(start==end) return true; while(start&lt;end)&#123; if(s[start]!=s[end]) return false; start++;end--; &#125; return true; &#125;&#125;; 单词拆分 139.Word Break(Medium)Example 1: Input: s = “leetcode”, wordDict = [“leet”, “code”]Output: trueExplanation: Return true because “leetcode” can be segmented as “leet code”.Example 2: Input: s = “applepenapple”, wordDict = [“apple”, “pen”]Output: trueExplanation: Return true because “applepenapple” can be segmented as “apple pen apple”. Note that you are allowed to reuse a dictionary word.Example 3: Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]Output: false 题目分析：看给定的词句能否被拆分成字典里面的内容。 解题思路：看子字符串是否在字典中，首先要将给定的数组放到hashset中，然后开始给字符串分段，使用记忆数组memo[i]定义为范围为[0,i)的子字符串是否可以拆分，初始化为-1，表示没有计算过，如果可以拆分，则赋值为1，否则置0.用start标记分段的位置，这样递归函数中只需要从start的位置往后遍历即可，在递归函数更新记忆数组memo即可。 123456789101112131415161718class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(),wordDict.end()); vector&lt;int&gt; memo(s.size(),-1); return check(s,wordSet,0,memo); &#125; bool check(string &amp;s,unordered_set&lt;string&gt; &amp;wordSet,int start,vector&lt;int&gt; &amp;memo)&#123; if(start==s.size()) return true; if(memo[start]!=-1) return memo[start]; for(int i=start+1;i&lt;=s.size();i++)&#123; if(wordSet.count(s.substr(start,i-start))&amp;&amp;check(s,wordSet,i,memo)) return memo[start]=1; &#125; return memo[start]=0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[两数之和 1.Two Sum(Easy)解题思路：用map存储数组元素和索引的映射，在访问nums[i]时，判断map中是否存在target-nums[i],若存在说明target-nums[i]所在的索引和i就是要找的两个数。12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; record; for(int i=0;i&lt;nums.size();i++)&#123; int complement=target-nums[i]; if(record.find(complement)!=record.end())&#123; int res[]=&#123;record[complement],i&#125;; return vector&lt;int&gt; &#123;res,res+2&#125;; &#125; record[nums[i]]=i; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 是否包含重复值 217.Contains Duplicate(Easy)解题思路：使用一个哈希表，遍历整个数组，如果哈希表里存在，返回true，否则将其放入哈希表中，遍历结束返回false。12345678910111213class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; m; for(int i=0;i&lt;nums[i].size();i++)&#123; if(m.find(nums[i])!=m.end()) return true; m[nums[i]]++; &#125; return false; &#125;&#125;; 解题思路：先将数组排序，然后比较相邻两个数字是否相等。 12345678910class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); for(int i=1;i&lt;nums.size();i++) if(nums[i]==nums[i-1]) return true; return false; &#125;&#125;; 最长和谐子序列 594.Longest Harmonious Subsequence(Easy)Input: [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3]. 题目描述：题目给了一个数组，让找出最长的和谐子序列，和谐子序列就是序列中数组的最大最小值均为1。 解题思路：由于只是求长度，并不需要返回具体的子序列。因此可以对数组排序，找出相差为1的两个数的总共出现个数就是一个和谐子序列的长度了。可以建立一个数字和其出现次数之间的映射，利用map的自动排序特性，遍历map的时候就是从小到大开始遍历，从第二个映射开始，每次和前面的映射比较，若二者差值刚好为1，那么就把两个数字出现次数相加并更新res。 1234567891011121314151617class Solution &#123;public: int findLHS(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int res=0; map&lt;int,int&gt; m; for(int i=0;i&lt;nums.size();i++) m[nums[i]]++; for(auto it=next(m.begin());it!=m.end();it++)&#123; auto pre=prev(it); if(it-&gt;first==pre-&gt;first+1) res=max(res,it-&gt;second+pre-&gt;second); &#125; return res; &#125;&#125;; 最长连续序列 128.Longest Consecutive Sequence(Hard)Given [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. 解题思路：要求最长连续序列，并给定了O(n)复杂度限制。思路就是使用一个set集合存入所有的数字，然后遍历数组中的每个数字，并分别用两个变量pre和next算出其前一个数和后一个数是否在集合中存在，如果pre在集合中，那么将pre移除集合，然后pre自减1，直到pre不在集合中，对next采用同样的方法处理，那么next-pre-1就是当前数字的最长连续序列，再更新res即可。这里需注意，当遍历数组中的数字时，要移除该数字，是为了避免重复计算。比如题目中的例子，在遍历到4的时候，会向下遍历3，2，1，如果都不移除数字的话，遍历到1的时候，还会遍历2，3，4。同样，遍历到3的时候，向上遍历4，向下遍历2，1。如果数组中有大量的连续数字的话，那么就有大量的重复计算，十分的不高效，因此要从HashSet中移除数字。 1234567891011121314151617class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int res=0; unordered_set&lt;int&gt; s(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size();i++)&#123; if(s.find(nums[i])==s.end()) continue; s.erase(nums[i]); int pre=nums[i]-1,next=nums[i]+1; while(s.count(pre)) s.erase(pre--); while(s.count(next)) s.erase(next++); res=max(res,next-pre-1); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>哈希思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F04%2F04%2FLeetCode%E5%88%B7%E9%A2%98%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[找到两个链表的交点 160.Intersection of Two Linked Lists(Easy)A: a1 → a2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii ↘ iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii c1 → c2 → c3 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii ↗B: b1 → b2 → b3 解题思路：当访问A链表的指针访问到链表尾部时，令它从链表B的头部开始访问链表B；同样地，当访问B链表的指针访问到链表尾部时，令它从链表A的头部开始访问链表A；这样就能使两个指针同时访问到交点。 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode*l1=headA,*l2=headB; while(l1!=l2)&#123; if(l1==NULL) l1=headB; else l1=l1-&gt;next; if(l2==NULL) l2=headA; else l2=l2-&gt;next; &#125; return l1; &#125;&#125;; 链表翻转 206.Reverse Linked List(Easy)迭代解法解题思路：定义三个节点指针pRev,pCur,pNext，pRev初始化为NULL，pCur初始化为头节点，刚开始是pRev-&gt;pCur-&gt;pNext的顺序，只需将它们的指向反过来；然后更新pRev和pCur节点，重复此操作直到pCur为NULL为止。 1234567891011121314class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pCur=head,*pNext,*pRev=NULL; while(pCur)&#123; pNext=pCur-&gt;next; pCur-&gt;next=pRev; pRev=pCur; pCur=pNext; &#125; return pRev; &#125;&#125;; 解题思路：还有一种迭代方法就是头插法，需要定义一个dummy节点，每次将原链表的节点插入到dummy为头节点的新链表中。123456789101112131415class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *dummy=new ListNode(-1); while(head)&#123; ListNode *next=head-&gt;next; head-&gt;next=dummy-&gt;next; dummy-&gt;next=head; head=next; &#125; return dummy-&gt;next; &#125;&#125;; 解题思路：下面还有一种做法，也是头插，只不过每次将当前节点(head)的下一个节点采用头插法，插入到链表前面，当前节点head指向始终不变，直到head为最后一个节点，那么它就从第一个变成了最后一个节点。12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *dummy=new ListNode(-1); dummy-&gt;next=head; while(head-&gt;next)&#123;//注意这里判断head是否已经成为链表的末尾 ListNode *tmp=head-&gt;next; head-&gt;next=tmp-&gt;next; tmp-&gt;next=dummy-&gt;next; dummy-&gt;next=tmp; &#125; return dummy-&gt;next; &#125;&#125;; 递归解法解题思路：不断调用函数，直到head指向最后一个节点，因为head指向空或最后一个节点就直接返回了；newHead指向对head的下一个节点调用递归函数返回的头节点，此时newHead指向最后一个节点，而head的下一个节点的next指针应该指向head本身，但head之后的next还没断开，所以要再将head移动到末尾，最后返回newHead即可。 1234567891011class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *newHead=reverseList(head-&gt;next); head-&gt;next-&gt;next=head; head-&gt;next=NULL; return newHead; &#125;&#125;; 合并两个有序的链表 21.Merge Two Sorted Lists(Easy)解法一：与合并有序数组类似解题思路：新建一个链表，比较两个链表中的节点值，把较小的链入到新链表中，由于最终会有一个链表先完成插入所有的节点，则直接把另一个未完成的链表节点直接链入新链表的末尾。 1234567891011121314151617181920class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *dummy=new ListNode(-1); ListNode *t=dummy; while(l1&amp;&amp;l2)&#123; if(l1-&gt;val&lt;l2-&gt;val)&#123; t-&gt;next=l1; l1=l1-&gt;next; &#125;else&#123; t-&gt;next=l2; l2=l2-&gt;next; &#125; t=t-&gt;next; &#125; t-&gt;next=l1?l1:l2; return dummy-&gt;next; &#125;&#125;; 递归求解解题思路：当某个链表为空了，就返回另一个链表；若都不为空，就比较当前两个节点值大小，如果l1小，那么将l1的下一个节点和l2作为参数去调用，将将返回值赋值给l1-&gt;next，返回l1;否则就将l1和l2-&gt;next作为参数调用，将返回值赋值给l2-&gt;next,然后返回l2.123456789101112131415class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val&lt;l2-&gt;val)&#123; l1-&gt;next=mergeTwoLists(l1-&gt;next,l2); return l1; &#125;else&#123; l2-&gt;next=mergeTwoLists(l1,l2-&gt;next); return l2; &#125; &#125;&#125;; 从有序链表中删除重复节点 83.Remove Duplicates from Sorted List(East)Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 迭代求解123456789101112131415class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode *cur=head; while(cur&amp;&amp;cur-&gt;next)&#123; if(cur-&gt;val==cur-&gt;next-&gt;val)&#123; cur-&gt;next=cur-&gt;next-&gt;next; &#125;else cur=cur-&gt;next; &#125; return head; &#125;&#125;; 递归求解解题思路：首先判断知否至少有两个节点，若不是直接返回head。然后对head-&gt;next调用递归函数，并赋值给head-&gt;next,该步进行的操作实质上就是对head后面的节点调用递归函数，那么返回来的链表就已经没有重复项了，此时接到head节点后面；最后一句返回的时候，head先跟其后面的节点进行比较，如果值相同，返回后面的节点，这样就直接跳过了head节点，否则返回head。整个的执行过程就是递归一直到末尾节点，再不断的回溯回来，进行删除重复节点。 123456789class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return head; head-&gt;next=deleteDuplicates(head-&gt;next); return (head-&gt;val==head-&gt;next-&gt;val) ? head-&gt;next:head; &#125;&#125;; 删除链表倒数第n个节点 19.Remove Nth Node from End of List(Medium)Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 题目描述：n一定不会大于链表长度，并且希望遍历一次就能删除倒数第n个节点。 解题思路：使用两个指针pre和cur，均初始化为head，让cur先移动n步，若此时cur为空，则n为链表长度，则需要移除首元素，即返回head-&gt;next；若cur不为空，同时移动两个指针，直到cur指向最后一个元素，此时pre指向要移除元素的前一个元素，再修改指针跳过要移除的节点即可。 12345678910111213141516class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head-&gt;next==NULL) return NULL; ListNode *pre=head,*cur=head; for(int i=0;i&lt;n;i++) cur=cur-&gt;next; if(cur==NULL) return head-&gt;next; while(cur-&gt;next)&#123; cur=cur-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next=pre-&gt;next-&gt;next; return head; &#125;&#125;; 交换链表中的相邻节点 24.Swap Nodes in Pairs(Mediun)Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 迭代法解题思路：须建立一个dummy节点，dummy-&gt;next指向头节点。然后定义node1、node2、tmp节点，用于交换相邻两节点。 1234567891011121314151617181920212223class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *dummy=new ListNode(-1),*pre=dummy; dummy-&gt;next=head; ListNode *node1,*node2,*tmp; while(pre-&gt;next&amp;&amp;pre-&gt;next-&gt;next)&#123; node1=pre-&gt;next; node2=pre-&gt;next-&gt;next; tmp=node2-&gt;next; node2-&gt;next=node1; node1-&gt;next=tmp; pre-&gt;next=node2;//交换好node1和node2之后不要忘记将node2和前面的节点连起来，且这两句顺序不能变 pre=node1; &#125; ListNode *res=dummy-&gt;next; delete(dummy); return res; &#125;&#125;; 递归求解解题思路：利用回溯思想，递归遍历到链表结尾，然后交换末尾两个，再依次往前交换。1234567891011class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *tmp=head-&gt;next; head-&gt;next=swapPairs(head-&gt;next-&gt;next); tmp-&gt;next=head; return tmp; &#125;&#125;; 链表求和2.Add Two Numbers(Medium)Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 解题思路：新建一个链表，然后把输入的两个链表从头往后遍历，两两相加，添加一个新节点到新链表后面，为了避免两个输入两链表同时为空，最好建立一个dummy节点，将两个节点相加生成的新节点按顺序加到dummy节点后面。相加时需要处理进位问题。 1234567891011121314151617181920class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *dummy=new ListNode(-1),*cur=dummy;//注意，cur应该指向一个对象(dummy节点)，不能指向dummy-&gt;next int carry=0; while(l1||l2)&#123; int val1=l1?l1-&gt;val:0; int val2=l2?l2-&gt;val:0; int sum=val1+val2+carry; carry=sum/10; cur-&gt;next=new ListNode(sum%10); cur=cur-&gt;next; if(l1) l1=l1-&gt;next; if(l2) l2=l2-&gt;next; &#125; if(carry) cur-&gt;next=new ListNode(1);//最高位进位问题也要特殊处理 return dummy-&gt;next; &#125;&#125;; 455.Add Two Numbers II(Medium)Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 题目描述：这道题目的最高位在链表首位，且不能修改链表。 解法一：借助栈解题思路：利用栈保存所有的元素，然后利用栈先进后出的特点就能从后往前获取链表元素了。首先遍历两个链表，将所有元素压入s1和s2两个栈中；新建一个res节点，然后开始循环，两个栈不为空，就将栈顶元素加入到sum中，然后将res节点赋值为sum%10，再新建一个进位节点head，赋值为sum/10，将head指向res；循环退出后，判断res值是否为0，若为0返回res-&gt;next，否则返回res。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; stack&lt;int&gt; s1,s2; while(l1)&#123; s1.push(l1-&gt;val); l1=l1-&gt;next; &#125; while(l2)&#123; s2.push(l2-&gt;val); l2=l2-&gt;next; &#125; int sum=0; ListNode *res=new ListNode(0); while(!s1.empty()||!s2.empty())&#123; if(!s1.empty())&#123; sum+=s1.top(); s1.pop(); &#125; if(!s2.empty())&#123; sum+=s2.top();s2.pop(); &#125; res-&gt;val=sum%10; ListNode *head=new ListNode(sum/10); head-&gt;next=res; res=head; sum/=10; &#125; return res-&gt;val==0?res-&gt;next:res; &#125;&#125;; 回文链表 234.Palindrome Linked List(Easy)Input: 1-&gt;2-&gt;2-&gt;1Output: true 题目描述：要去O(n)时间复杂度以及O(1)空间复杂度。 解法一：忽略空间复杂度的要求，使用栈求解解题思路：使用两个指针，快指针走两步，慢指针走一步，快指针走完时，慢指针的位置就是中点；每次慢指针走一步，就将值存入栈，等到达中点时，链表的前半段都存入栈了，由于栈的前进后出的特点，就可以和后半段链表的值进行比较了。 12345678910111213141516171819202122class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head||!head-&gt;next) return true; ListNode *fast=head,*slow=head; stack&lt;int&gt; s; s.push(slow-&gt;val); while(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123; slow=slow-&gt;next; s.push(slow-&gt;val); fast=fast-&gt;next-&gt;next; &#125; if(!fast-&gt;next) s.pop();//此时链表节点为奇数，slow指向中间节点，须将中间结点出站后比较 while(slow-&gt;next)&#123; slow=slow-&gt;next; int t=s.top();s.pop(); if(slow-&gt;val!=t) return false; &#125; return true; &#125;&#125;; 解法二解题思路：用O(1)的空间，就不能用stack了，可以先找到中点，将后半段的链表翻转一下，然后按顺序比较就好啦！ 123456789101112131415161718192021222324252627class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head||!head-&gt;next) return true; ListNode *fast=head,*slow=head; while(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; &#125; ListNode *cur=slow-&gt;next; while(cur-&gt;next)&#123; ListNode *tmp=cur-&gt;next; cur-&gt;next=tmp-&gt;next; tmp-&gt;next=slow-&gt;next; slow-&gt;next=tmp; &#125;//结束后，slow-&gt;next为后半段链表的头部 //若链表长度为奇数，则slow为中间节点，否则slow为前半段链表的最后一个节点 ListNode *tmp=head; while(slow-&gt;next)&#123; slow=slow-&gt;next; if(tmp-&gt;val!=slow-&gt;val) return false; tmp=tmp-&gt;next; &#125; return true; &#125;&#125;; 分割链表 725.Split Linked List in Pairs(Medium)Input:root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. 题目描述：把链表分割成k部分，每部分的长度尽可能相同，排在前面的长度应该大于等于后面的。 解题思路：要想知道每个部分节点的个数，首先要统计链表中节点个数，然后除以k，得到的商ave就是平分的个数,余数mod就是包含多余节点的子链表的个数。用for循环，循环条件是i&lt;k且root存在，生成k个子链表，在循环中，先把头节点添加到res中，然后遍历该子链表的节点个数，节点个数size=ave+多余节点(前提是还有多余节点)；需注意j&lt;size-1，是因为我们希望移动到子链表的最后一个节点上，而不是移动到下一个子链表的头节点上；然后新建一个临时节点t指向下一个节点，即下一个子链表的头节点，然后将链表断开，再将root指向下一个子链表的头节点。 123456789101112131415161718192021class Solution &#123;public: vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123; vector&lt;ListNode*&gt; res(k); int len=0; for(ListNode *t=root;t;t=t-&gt;next) len++; int ave=len/k,mod=len%k; for(int i=0;i&lt;k&amp;&amp;root;i++)&#123; res[i]=root; int size=ave+(mod--&gt;0?1:0); for(int j=0;j&lt;size-1;j++)&#123; root=root-&gt;next; &#125; ListNode *t=root-&gt;next; root-&gt;next=NULL; root=t; &#125; return res; &#125;&#125;; 链表元素按奇偶聚集 328.Odd Even Linked List(Medium)Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.Note:The relative order inside both the even and odd groups should remain as it was in the input.The first node is considered odd, the second node even and so on … 123456789101112131415161718class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return head; ListNode *pre=head,*cur=head-&gt;next; while(cur&amp;&amp;cur-&gt;next)&#123; ListNode *t=pre-&gt;next; pre-&gt;next=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; pre-&gt;next-&gt;next=t; pre=pre-&gt;next; cur=cur-&gt;next; &#125; return head; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2019%2F04%2F04%2FLeetCode%E5%88%B7%E9%A2%98%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[递归树的高度 104.Maximum Depth of Binary Tree(Easy)12345678class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1; &#125;&#125;; 平衡树 110.Balanced Binary Tree(Easy)解题思路：高度平衡二叉树是每一个节点的两个子树的深度不超过1，那么就需要一个求节点深度的函数，然后比较每个节点的左右子树的深度差。 1234567891011121314class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(root==NULL) return true; if(abs(getDepth(root-&gt;left)-getDepth(root-&gt;right))&gt;1) return false; return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right); &#125;private: int getDepth(TreeNode *root)&#123; if(root==NULL) return 0; return 1+max(getDepth(root-&gt;left),getDepth(root-&gt;right)); &#125; &#125;; 解题思路：上面这种方法效率不高，因为每个点都会被上面的点计算深度时访问一次，可以对此优化。如果发现子树不平衡，就不计算具体的深度，而是直接返回-1；对于每一个节点，通过checkDepth的方法递归获得左右子树的深度，如果子树平衡，则返回真实的深度，否则返回-1. 1234567891011121314151617181920class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(root==NULL) return true; if(checkDepth(root)==-1) return false; return true; &#125;private: int checkDepth(TreeNode *root)&#123; if(root==NULL) return 0; int left=checkDepth(root-&gt;left); if(left==-1) return -1; int right=checkDepth(root-&gt;right); if(right==-1) return -1; int diff=abs(left-right); if(diff&gt;1) return -1; return 1+max(left,right); &#125; &#125;; 二叉树的直径 543.Diameter of Binary Tree(Easy)Note: The length of path between two nodes is represented by the number of edges between them. 解题思路：二叉树的直径就是两点之间的最远距离，也就是某个节点的左右两个子树的深度之和。 1234567891011121314151617class Solution &#123;public: int diameterOfBinaryTree(TreeNode* root) &#123; int res=0; maxDepth(root,res); return res; &#125;private: int maxDepth(TreeNode *root,int &amp;res)&#123; if(!root) return 0; int left=maxDepth(root-&gt;left,res); int right=maxDepth(root-&gt;right,res); res=max(res,left+right); return 1+max(left,right); &#125;&#125;; 翻转二叉树 226.Invert Binary Tree(Easy)1234567891011class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; TreeNode *t=root-&gt;left; root-&gt;left=invertTree(root-&gt;right); root-&gt;right=invertTree(t); return root; &#125;&#125;; 归并两棵二叉树 617.Merge Two Binary Trees(Easy)解题思路：如果t1不存在，则直接返回t2；若t2不存在，则直接返回t1；否则以t1和t2的节点值之和建立新节点root，然后对t1和t2的左子节点调用递归并赋给root的左子节点，再对t1和t2的右子节点调用递归并赋给root的右子节点。12345678910111213class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; //if(!t1&amp;&amp;!t2) return NULL; if(!t1) return t2; if(!t2) return t1; TreeNode *root=new TreeNode(t1-&gt;val+t2-&gt;val); root-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left); root-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right); return root; &#125;&#125;; 二叉树的路径和判断路径和是否等于一个数 112.Path Sum(Easy)123456789class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;root-&gt;val==sum) return true; return hasPathSum(root-&gt;left,sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val); &#125;&#125;; 找出所有路径和等于一个数的路径 113.Path Sum II(Medium)解题思路：使用深度优先搜索DFS，创建二维数组res和一位数组path，每当DFS搜索到新节点时，都要保存该节点；而且每当找出一条路径之后，都将path保存到res中；而且每当DFS搜索到子节点，发现不是路径和时，返回上一个结点时，需要把该节点从path中移除。 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; helper(root,sum,path,res); return res; &#125;private: void helper(TreeNode *root,int sum,vector&lt;int&gt; &amp;path,vector&lt;vector&lt;int&gt;&gt; &amp;res)&#123; if(!root) return; path.push_back(root-&gt;val); if(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;root-&gt;val==sum) res.push_back(path); helper(root-&gt;left,sum-root-&gt;val,path,res); helper(root-&gt;right,sum-root-&gt;val,path,res); path.pop_back(); &#125; &#125;; 统计路径和等于一个数的路径数量 437.Path Sum III(Easy)题目描述：求二叉树的路径和等于一个给定值，这条路径不一定从根节点开始，也不一定以叶子节点结尾，可以是中间的任意一段，而且二叉树的节点值有正有负。 解题思路：借助一个子函数求解以root开始的路径和等于给定值的数量，然后在pathSum函数中调用该函数即可。 12345678910111213141516class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if(!root) return 0; int res=pathSumStartWithNode(root,sum)+pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum); return res; &#125; int pathSumStartWithNode(TreeNode* node,int sum)&#123; if(!node) return 0; int res=0; if(node-&gt;val==sum) res++; res+=pathSumStartWithNode(node-&gt;left,sum-node-&gt;val)+pathSumStartWithNode(node-&gt;right,sum-node-&gt;val); return res; &#125;&#125;; 解题思路：还有另一种解法，依然使用递归，相当于先序遍历，对于每一个节点都有记录了一条从根节点到当前节点的路径，同时用一个变量curSum记录路径节点总和，然后看curSum和sum是否相等，相等的话res自增1，不等的话继续查看子路径和有没有满足的，做法就是每次去掉一个节点，看路径和是否等于给定值。1234567891011121314151617181920212223class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; int res=0; vector&lt;TreeNode*&gt; record; helper(root,sum,0,record,res); return res; &#125; void helper(TreeNode* node,int sum,int curSum,vector&lt;TreeNode*&gt;&amp; record,int&amp; res)&#123; if(!node) return; curSum+=node-&gt;val; record.push_back(node); if(curSum==sum) res++; int tmp=curSum; for(int i=0;i&lt;record.size()-1;i++)&#123; tmp-=record[i]-&gt;val; if(tmp==sum) res++; &#125; helper(node-&gt;left,sum,curSum,record,res); helper(node-&gt;right,sum,curSum,record,res); record.pop_back(); &#125;&#125;; 子树 572.Subtree of Another Tree(Easy)12345678910111213141516171819202122232425262728293031Given tree s: 3 / \ 4 5 / \ 1 2Given tree t: 4 / \ 1 2Return true, because t has the same structure and node values with a subtree of s.Given tree s: 3 / \ 4 5 / \ 1 2 / 0Given tree t: 4 / \ 1 2Return false. 1234567891011121314class Solution &#123;public: bool isSubtree(TreeNode* s, TreeNode* t) &#123; if(!s) return false; return isSame(s,t)||isSubtree(s-&gt;left,t)||isSubtree(s-&gt;right,t); &#125; bool isSame(TreeNode *s,TreeNode *t)&#123; if(!s&amp;&amp;!t) return true; if(!s||!t) return false; if(s-&gt;val!=t-&gt;val) return false; return isSame(s-&gt;left,t-&gt;left)&amp;&amp;isSame(s-&gt;right,t-&gt;right); &#125;&#125;; 判断对称树 101.Symmetric Tree(Easy)解题思路：判断二叉树是否是对称树，那么对于每一个节点都要对称，t1和他t2是某节点的左右子节点，我们需要比较t1和t2的节点值是否相等，同时还要比较t1的左子节点和t2的右子节点、t1的右子节点和t2的左子节点是否相等。1234567891011121314class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return isSymmetric(root-&gt;left,root-&gt;right); &#125; bool isSymmetric(TreeNode *t1,TreeNode *t2)&#123; if(!t1&amp;&amp;!t2) return true; if(!t1||!t2) return false; if(t1-&gt;val!=t2-&gt;val) return false; return isSymmetric(t1-&gt;left,t2-&gt;right)&amp;&amp;isSymmetric(t1-&gt;right,t2-&gt;left); &#125;&#125;; 最小深度 11.Minimum Depth of Binary Tree(Easy)解题思路：用深度优先搜索DFS来做。首先判空，若当前节点不存在，直接返回0；然后求左右子节点的深度，若其中一个子节点为空，则将另一个子节点深度加1返回；若左右都存在，则将二者中的较小值加1返回即可。1234567891011class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; int left=minDepth(root-&gt;left); int right=minDepth(root-&gt;right); if(left==0||right==0) return left+right+1; return min(left,right)+1; &#125;&#125;; 未待完续…]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治]]></title>
    <url>%2F2019%2F04%2F02%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[给表达式加括号 241.Different Ways to Add Parentheses(Medium)Input: “2-1-1”.((2-1)-1) = 0(2-(1-1)) = 2Output : [0, 2] 题目描述：给出一个可能含有加减乘的表达式，让我们在任意位置添加括号，求出所有可能的表达式的值。 解题思路：以遇到的运算符为界，将表达式分为两部分，分别递归求解。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;input.size();i++)&#123; if(input[i]==&apos;+&apos;||input[i]==&apos;-&apos;||input[i]==&apos;*&apos;)&#123; vector&lt;int&gt; left=diffWaysToCompute(input.substr(0,i));//获得字符串input中从0开始长度为i的字符串 vector&lt;int&gt; right=diffWaysToCompute(input.substr(i+1));//默认时的长度是从开始到尾 for(int j=0;j&lt;left.size();j++)&#123; for(int k=0;k&lt;right.size();k++)&#123; if(input[i]==&apos;+&apos;) res.push_back(left[j]+right[k]); else if(input[i]==&apos;-&apos;) res.push_back(left[j]-right[k]); else res.push_back(left[j]*right[k]); &#125; &#125; &#125; &#125; //若res为空，说明传入的字符串为一个数字，直接将该数字存入结果即可 //c_str()函数返回一个指向正规C字符串的指针常量,atoi()的参数类型是const char* if(res.empty()) res.push_back(atoi(input.c_str())); return res; &#125;&#125;; 上述解法中的递归函数的参数没用指针，这样的话每次调用都要拷贝string对象，如果用指针的化就是直接引用，在leetcode上测试两种方法消耗的内存没差，可能是因为传入的对象本身就不大。 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; if(input.empty()) return &#123;&#125;; return helper(input,0,input.size()-1); &#125;private: vector&lt;int&gt; helper(string&amp; input,int l,int r)&#123; vector&lt;int&gt; res; for(int i=l;i&lt;=r;i++)&#123; if(input[i]==&apos;+&apos;||input[i]==&apos;-&apos;||input[i]==&apos;*&apos;)&#123; vector&lt;int&gt; left=helper(input,l,i-1);//获得字符串input中从0开始长度为i的字符串 vector&lt;int&gt; right=helper(input,i+1,r);//默认时的长度是从开始到尾 for(int j=0;j&lt;left.size();j++)&#123; for(int k=0;k&lt;right.size();k++)&#123; if(input[i]==&apos;+&apos;) res.push_back(left[j]+right[k]); else if(input[i]==&apos;-&apos;) res.push_back(left[j]-right[k]); else res.push_back(left[j]*right[k]); &#125; &#125; &#125; &#125; if(res.empty()) res.push_back(atoi(input.substr(l,r-l+1).c_str())); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心思想]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode%E5%88%B7%E9%A2%98%2F%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[分配饼干 455.Assign Cookies (Easy)Input: [1,2], [1,2,3]Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.You have 3 cookies and their sizes are big enough to gratify all of the children,You need to output 2. 题目描述：每个孩子都有一个满意度，每个饼干斗殴一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。 解题思路：先拿最小的Cookies给胃口最小的孩子，看能否满足，能的话，res自增1，然后再拿下一个Cookies去满足下一位小朋友；如果当前Cookies不能满足当前小朋友，那么就用下一块稍大一些的Cookies去尝试满足当前的小朋友。当Cookies发完了或小朋友都满足了就停止遍历。 123456789101112131415class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(),g.end()); sort(s.begin(),s.end()); int res=0,si=0; while(res&lt;g.size()&amp;&amp;si&lt;s.size())&#123; if(s[si]&gt;=g[res]) res++; si++; &#125; return res; &#125;&#125;; 不重叠的区间个数 435.Non-overlapping Intervals (Medium)Input: [ [1,2], [1,2], [1,2] ] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. 题目描述：计算让一组区间不重叠最少需要移除的区间个数。 解题思路：先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。 在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面的区间个数也就越大。 按区间的结尾进行排序，每次选择结尾最小并且和前一个区间不重叠的区间。 1234567891011121314151617181920212223242526/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: int eraseOverlapIntervals(vector&lt;Interval&gt;&amp; intervals) &#123; if(intervals.size()==0) return 0; sort(intervals.begin(),intervals.end(),[](Interval&amp; a,Interval&amp; b)&#123;return a.end&lt;b.end;&#125;); int res=1; int end=intervals[0].end; for(int i=1;i&lt;intervals.size();i++)&#123; if(intervals[i].start&lt;end) continue; end=intervals[i].end; res++; &#125; return intervals.size()-res; &#125;&#125;; 非递减数组665.Non-decreasing Array(Easy)Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 题目描述：最多有一次修改某个数字的机会，问是否能将数组变为非递减数组。 解题思路：看下面三个例子，4，2，3-1，4，2，32，3，4，2，5观察上面三个例子可以发现，当后面的数字小于前面的数字时，有时只需修改前面较大的数字(如前两个例子)，有时却要修改后面较小的数字(如第3个例子)，规律如下：判断较小的数字与再前面的数字的关系！ 如果再前面的数字不存在，如第一个例子，4前面没有数字了，就直接修改前面的数字为当前的数字2； 若再前面的数字存在，且小于当前数字时(-1&lt;2)，同样的，直接修改前面的数字为当前的数字2就好了； 若再前面的数字存在，但大于当前数字时(3&gt;2)，就需要修改当前的数字为前面的数字； 由于只有一次修改的机会，用一个变量flag，初始化为true，修改数字后变为false，当下次再需要修改时，若flag为false，就直接返回false；遍历结束后返回true。 123456789101112131415161718class Solution &#123;public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; bool flag=true; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i]&lt;nums[i-1])&#123; if(!flag) return false; if(i==1||nums[i]&gt;=nums[i-2]) nums[i-1]=nums[i]; else nums[i]=nums[i-1]; flag=false; &#125; &#125; return true; &#125;&#125;; 买入和售出股票的最大收益121.Best Time to Buy and Sell Stock(Easy)题目描述：只进行一次交易 解题思路：记录前面的最小价格，将这个价格作为买入价格，然后将当前的价格作为售出价格，判断当前收益是否为最大收益。 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0,buy=INT_MAX; for(int i=0;i&lt;prices.size();i++)&#123; buy=min(buy,prices[i]); res=max(res,prices[i]-buy); &#125; return res; &#125;&#125;; 122.Best Time to Buy and Sell Stock II(Easy)题目描述：可以交易无数次，一次股票交易包括买入和卖出，多个交易之间不能交叉。 解题思路：只需要从第二天开始，如果当前价格比昨天价格高，就把差值加入到收益，因为我们可以昨天买入，今天卖出，若明天价更高，还可以今天买入，明天卖出；以此类推。 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0; for(int i=1;i&lt;prices.size();i++)&#123; if(prices[i]&gt;prices[i-1]) res+=prices[i]-prices[i-1]; &#125; return res; &#125;&#125;; 还有股票3问题，需要用到动态规划，就先不写啦！ 子数组最大的和 53.Maximum Subarray(Easy)For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. O(n)时间复杂度解题思路：定义两个变量res和curSum，res保存要返回的结果，curSum保存当前为止求出的数组之和的最大值；每遍历一个数字nums[i],比较curSum+nums[i]和nums[i]中的较大值存入curSum，然后再比较res和curSum的较大值并存入res，以此类推，最后返回res。 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int res=INT_MIN,curSum=0; for(int num:nums)&#123; curSum=max(curSum+num,num); res=max(res,curSum); &#125; return res; &#125;&#125;; O(logn)时间复杂度解题思路：分治法求解，把数组分为两部分，分别求出左边和右边的最大数组之和；然后还要从中间向左右两边分别扫描，找出包含中间元素的最大数组之和；求出包含中间元素的最大值和左右两边得到的最大值中较大的那个。 1234567891011121314151617181920212223242526class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; return helper(nums,0,nums.size()-1); &#125;private: int helper(vector&lt;int&gt;&amp; nums,int l,int r)&#123; if(l&gt;=r) return nums[l]; int m=l+(r-l)/2; int lmax=helper(nums,l,m-1); int rmax=helper(nums,m+1,r); int mmax=nums[m],t=mmax; for(int i=m-1;i&gt;=l;i--)&#123; t+=nums[i]; mmax=max(mmax,t); &#125; t=mmax; for(int i=m+1;i&lt;=r;i++)&#123; t+=nums[i]; mmax=max(mmax,t); &#125; return max(mmax,max(lmax,rmax)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode%E5%88%B7%E9%A2%98%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[求开方 69.Sqrt (Easy)Input: 4Output: 2 Input: 8Output: 2Explanation: The square root of 8 is 2.82842…, and since we want to return an integer, the decimal part will be truncated. 解题思路：利用二分查找在0~x中查找sqrt。对于x=8，它的开方是2.82842…，最后返回2而不是3.再循环条件l&lt;=h并且循环退出时，h总是比l小，即h=2，l=3，因此最后的返回值应该是h而不是l。 1234567891011121314151617class Solution &#123;public: int mySqrt(int x) &#123; if(x==0||x==1) return x; int l=0,h=x; while(l&lt;=h)&#123; int mid=(l+h)&gt;&gt;1; if(mid==x/mid) return mid; else if(mid&gt;x/mid) h=mid-1; else l=mid+1; &#125; return h; &#125;&#125;; 大于给定元素的最小元素 744.Find Smallest Letter Greater Than Target (Easy)题目描述：给定一个有序数组和一个字符，要求找出letters中大于target的最小字符，如果找不到就返回第一个字符。 1234567891011121314class Solution &#123;public: char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; int l=0,h=letters.size()-1; while(l&lt;=h)&#123; int m=l+(h-l)/2; if(letters[m]&lt;=target) l=m+1; else h=m-1; &#125; return l&lt;letters.size()? letters[l]:letters[0]; &#125;&#125;; 有序数组中的单独元素 540.Single Element in a Sorted Array (Medium)Input: [1,1,2,3,3,4,4,8,8]Output: 2 Note: Your solution should run in O(log n) time and O(1) space. 题目描述：题目给了一个有序数组，所有的元素都出现了两次，除了一个元素，让我们找到这个元素。 解题思路： 设index为单独元素在数组中的位置。如果m为偶数，并且m+1&lt;index,那么nums[m]==nums[m+1];m+1&gt;index,那么nums[m]!=nums[m+1]. 从上面的规律可以看出，如果nums[m]==nums[m+1]，那么index所在数组位置为[m+2,h],此时令l=m+2;如果nums[m]!=nums[m+1]，那么index所在数组位置为[l,m],此时令h=m。 解释为什么可以直接取nums[m+1]的值，不用考虑越界？因为如果l与h相等就不会进入循环，所以m一定比h小，一定会有m+1存在。 12345678910111213141516class Solution &#123;public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int l=0,h=nums.size()-1; while(l&lt;h)&#123; int m=l+(h-l)/2; if(m&amp;1) m--;//保证l/m/h均为偶数 if(nums[m]==nums[m+1]) l=m+2; else h=m; &#125; return nums[l];//返回l或h均可 &#125;&#125;; 第一个错误的版本 278.First Bad Version题目描述：给定一个元素n代表有[1,2,3…n]版本，可以调用isBadversion(int x)知道某个版本是否错误，要求找到第一个错误的版本。 解题思路：如果第m个版本出错，则表示第一个错误的版本在[l,m]之间，令h=m；否则第一个错误的版本在[m+1,h]之间，令l=m+1.因为h的赋值表达式为h=m，因此循环条件为l&lt;h,不然可能会死循环。 1234567891011121314151617// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int l=0,h=n; while(l&lt;h)&#123; int m=l+(h-l)/2; if(isBadVersion(m)) h=m; else l=m+1; &#125; return l; &#125;&#125;; 旋转数字的最小数字 153.Find Minimum in Rotated Sorted Array (medium)Input: [3,4,5,1,2],Output: 1 解题思路：如果nums[m]&gt;nums[h],则最小的数字肯定在[m+1,h]之间，令l=m+1;否则，最小的数字在[l,m]之间，令h=m(若nums[m]&lt;nums[h],则m对应的数字肯定在最小数字的右边，即是和最小数字一起被旋转到数组后面的); 123456789101112131415class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int l=0,h=nums.size()-1; while(l&lt;h)&#123; int m=l+(h-l)/2; if(nums[m]&gt;nums[h]) l=m+1; else h=m; &#125; return nums[l]; &#125;&#125;; 查找区间 34.Find First and Last Position of Element in a Sorted Array (Medium)Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 解题思路：定义一个二分查找子函数。若nums[m]&gt;=target,h=m;否则l=m-1;该函数h初始值为nums.size(), 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int first=binarySearch(nums,target); int last=binarySearch(nums,target+1)-1; if(first==nums.size()||nums[first]!=target) return vector&lt;int&gt; &#123;-1,-1&#125;; else&#123; return vector&lt;int&gt; &#123;first,max(first,last)&#125;; &#125; &#125;private: int binarySearch(vector&lt;int&gt;&amp;nums,int target)&#123; int l=0,h=nums.size();//注意，h的初值 while(l&lt;h)&#123; int m=l+(h-l)/2; if(nums[m]&gt;=target) h=m; else l=m+1; &#125; return l; &#125;&#125;; 代码解释：return vector {first,max(first,last)};若改成return vector {first,last};若出现数组中只有一个元素时，会出错，如Input：[1]1Output：[0,-1]Expected：[0,0] 代码解释：int l=0,h=nums.size();若改成h=nums.size()-1;若找不到target时，返回的将是nums.size()-1的值，再减1之后值就不对了，该句代码主要是考虑到target为最后的元素的情况，如：Input:[2,2]2Output:[0,0]Expected:[0,1]]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双指针]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[有序数组的 167.Two Sum IIInput: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 题目描述：在有序数组中找出两个数，使它们的和为 target。 解题思路：使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 如果两个指针指向元素的和sum==target，即返回结果； 如果sum&gt;target，移动较大元素的指针； 如果sum&lt;target，移动较小元素的指针。 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int i=0,j=numbers.size()-1; while(i&lt;j)&#123; if(numbers[i]+numbers[j]==target) return vector&lt;int&gt; &#123;i+1,j+1&#125;; else if(numbers[i]+numbers[j]&lt;target) i++; else j--; &#125; return vector&lt;int&gt;&#123;&#125;; &#125;&#125;; 两数平方和 633.Sum of Square NumbersInput: 5Output: TrueExplanation: 1 1 + 2 2 = 5 题目描述：判断一个数是否为两个数的平方和。 12345678910111213141516class Solution &#123;public: bool judgeSquareSum(int c) &#123; int i=0,j=(int)sqrt(c); while(i&lt;=j)&#123; int powSum=i*i+j*j; if(powSum==c) return true; else if(powSum&lt;c) i++; else j--; &#125; return false; &#125;&#125;; 上述代码超时，无奈又去网上找了其他的解法： 方法二： 由于是求一个数能否由两个数平方之和组成，需要判断两次；从c的平方根开始；先判断如果i i==c,说明c是个平方数，再凑个0就是两数平方之和，返回true；如果不等，那么算出c-ii，如果这个差值也是个平方数的化，返回true；遍历结束后返回false。 123456789101112class Solution &#123;public: bool judgeSquareSum(int c) &#123; for(int i=sqrt(c);i&gt;=0;i--)&#123; if(i*i==c) return true; int t=c-i*i,j=sqrt(t); if(j*j==t) return true; &#125; return false; &#125;&#125;; 方法三： 使用集合set，对于每个i i,都加入集合set中，然后计算c-ii，如果这个差值在集合set中，则返回true，遍历结束返回false。1234567891011121314class Solution &#123;public: bool judgeSquareSum(int c) &#123; unordered_set&lt;int&gt; s; for(int i=0;i&lt;=sqrt(c);i++)&#123; s.insert(i*i); int t=c-i*i; if(s.find(t)!=s.end()) return true; &#125; return false; &#125;&#125;; 翻转字符串的元音字母 345.Reverse Vowels of a StrigGiven s = “leetcode”, return “leotcede”. 使用双指针指向待翻转的两个原因字符，一个从头向尾，一个指针从尾向头。 12345678910111213141516171819202122class Solution &#123;public: string reverseVowels(string s) &#123; int i=0,j=s.size()-1; char vowel[]=&#123;&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;,&apos;A&apos;,&apos;E&apos;,&apos;I&apos;,&apos;O&apos;,&apos;U&apos;&#125;; set&lt;char&gt; vowels(vowel,vowel+sizeof(vowel)/sizeof(char)); string res(s.size(),&apos;\0&apos;); while(i&lt;=j)&#123; if(vowels.find(s[i])==vowels.end()) res[i++]=s[i]; else if(vowels.find(s[j])==vowels.end()) res[j--]=s[j]; else&#123; res[i]=s[j]; res[j]=s[i]; i++;j--; &#125; &#125; return res; &#125;&#125;; 回文字符串 680.Valid PalindromeInput: “abca”Output: TrueExplanation: You could delete the character ‘c’. 题目描述：可以删除一个字符，判断是否能构成回文字符串。 解题思路：允许删除一个字符，当遇到不匹配的时候，要么删除左边的字符，要么删除右边的字符，都要遍历一遍，只要有一种能返回true，结果就返回true。可以写一个子函数来判断字符串中的某个范围内的子字符串是否为回文串。 123456789101112131415161718192021class Solution &#123;public: bool validPalindrome(string s) &#123; int i=0,j=s.size()-1; while(i&lt;j)&#123; if(s[i]!=s[j]) return isValid(s,i+1,j)||isValid(s,i,j-1); i++;j--; &#125; return true; &#125;private: bool isValid(string s,int i,int j)&#123; while(i&lt;j)&#123; if(s[i++]!=s[j--]) return false; &#125; return true; &#125;&#125;; 归并两个有序数组 88.Merge Sorted ArrayInput:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 题目描述：把归并结果存到第一个数组上。解题思路：题目中说了num1数组有足够的空间，不用resize数组，已知混合之后的数组的大小，这样从nums1和nums2数组的末尾开始一个一个比较，把较大的数按顺序从后往前加入混合之后的数组末尾。需要三个变量i、j、k，分别指向nums1、nums2和混合数组的末尾。进行while循环，如果i和j都大于0，再看如果nums1[i]&gt;nums[j],说明要先把nums1[i]先加入混合数组的末尾，加入后k和i均自减1；反之把nums2[j]加入混合数组末尾，加入后k和j均自减1。循环结束后，有可能i或j还大于0，若j大于0，则需要继续循环将nums2中的数组继续拷贝到nums1；若i大于0，那么就不用管了。 1234567891011121314class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i=m-1,j=n-1,k=m+n-1; while(i&gt;=0&amp;&amp;j&gt;=0)&#123; if(nums1[i]&gt;nums2[j]) nums1[k--]=nums1[i--]; else nums1[k--]=nums2[j--]; &#125; while(j&gt;=0) nums1[k--]=nums2[j--]; &#125;&#125;; 判断链表是否存在环 141.Linked List Circle使用快慢指针，一个指针移动一个节点，一个指针移动两个节点，若存在环，那么两指针一定相遇。12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head==NULL||head-&gt;next==NULL) return false; ListNode *slow=head,*fast=head; while(fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(fast==slow) return true; &#125; return false; &#125;&#125;; 判断是否为子序列 392.Is Subsequence(Medium)s = “abc”, t = “ahbgdc”Return true. 解题思路：两个指针分别指向字符串s和t，如果字符相等，则i和j自增1，否则j自增1，，看最后i是否等于s的长度；若等于说明s已经遍历完了，且字符都在t中出现过。123456789101112class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int i=0; for(int j=0;i&lt;s.size()&amp;&amp;j&lt;t.size();j++)&#123; if(s[i]==t[j]) i++; &#125; return i==s.size(); &#125;&#125;; 最长子序列 524.Longest Word in Dictionary through DeletingInput:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]Output:“apple” 题目描述：删除s中的一些字符，使得它构成的字符串列表d中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。解题思路：判断s删除一些字符后，是否存在于字典中，用i、j分别表示字符串和单词中某个字母的位置；遍历给定字符串，若遍历到单词中的某个字母，则j自增1，如果没有，则继续往下遍历。这样如果最后i和单词长度相等，则说明单词中所有的字母都按顺序出现在字符串s中！找出能构成的最长单词，需要遍历字典中的所有单词，找出长度最长的。 12345678910111213141516171819202122232425class Solution &#123;public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; string longestWord=&quot;&quot;; for(string target:d)&#123; int l1=longestWord.size(),l2=target.size(); if(l1&gt;l2||(l1==l2&amp;&amp;longestWord.compare(target)&lt;0)) continue; if(isValid(s,target)) longestWord=target; &#125; return longestWord; &#125;private: bool isValid(string s,string target)&#123; int i=0,j=0; while(i&lt;s.size()&amp;&amp;j&lt;target.size())&#123; if(s[i]==target[j]) j++; i++; &#125; return j==target.size(); &#125;&#125;; 补充：字典中的最长单词 720.Lonest Word in DIctionaryInput:words = [“w”,”wo”,”wor”,”worl”, “world”]Output: “world”Explanation:The word “world” can be built one character at a time by “w”, “wo”, “wor”, and “worl”. 解题思路：题目给了一个字符串数组，从单个字符开始拼，最长能构成什么单词，注意中间生成的字符串也要在字典中，而且当组成的单词长度一样时，返回字母序小的那个。使用BFS的做法，使用一个queue来辅助，先把所有长度为1的单词找出来放入queue中，当作初始的单词，然后进行循环，每次从队首取出一个元素，如果长度大于我们维护的最大值mxLen，则更新mxlen和结果，如果相等取字母序小的那个。然后试着增加长度，做法就是遍历26个字母，将每个字母都加到单词后面，然后看是否存在于字典中，存在的话，就入队，等待下一次遍历，增加长度之后记得要恢复原来的状态。 1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestWord(vector&lt;string&gt;&amp; words) &#123; string res=&quot;&quot;; int mxLen=0; unordered_set&lt;string&gt; s(words.begin(),words.end()); queue&lt;string&gt; q; for(string word:words)&#123; if(word.size()==1) q.push(word); &#125; while(!q.empty())&#123; string t=q.front(); q.pop(); if(t.size()&gt;mxLen)&#123; mxLen=t.size(); res=t; &#125;else if(t.size()==mxLen) res=min(res,t); for(char c=&apos;a&apos;;c&lt;=&apos;z&apos;;c++)&#123; t.push_back(c); if(s.find(t)!=s.end())//或者使用count函数 q.push(t); t.pop_back(); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.数学形态学运算]]></title>
    <url>%2F2019%2F03%2F25%2FComputerVision%2FOpenCV-ImageProcessing%2F3-Mathematical%20morphology%2F</url>
    <content type="text"><![CDATA[数学形态学运算–腐蚀、膨胀、开运算、闭运算数学形态学操作可以分为二值形态学和灰度形态学，灰度形态学由二值形态学扩展而来，数学形态学有两个基本的运算，腐蚀和膨胀，而腐蚀和膨胀又形成了开运算和闭运算。 二值形态学-通常用于二值图像腐蚀膨胀的作用： 消除噪声 分割出独立的图像元素，在图像中连接相邻的元素 寻找图像中明显的极大值区域或者极小值区域 求出图像的梯度 膨胀– 是图像中的高亮部分进行膨胀，效果图拥有比原图更大的高亮区域；腐蚀– 是原图中的高亮部分被腐蚀，效果图拥有比原图更小的高亮区域。从数学的角度来说腐蚀和膨胀操作就是将图像与核进行卷积，核可以是任意形状和大小的，核大则周围对其影响大，变化大，核小则周围对齐影响小，变化小。 更加高级的形态学变换 开运算–先腐蚀再膨胀，可以用来去掉目标外的孤立点，消除小物体，在纤细处分离物体，并且在平滑较大物体的边界的同时不明显改变其面积。 闭运算–先膨胀再腐蚀，能够去掉目标内的孔，排除小型黑洞。 形态学梯度–就是膨胀图与俯视图之差，用于保留物体的边缘轮廓。 顶帽–原图像与开运算之差，用于分离比邻近点亮一些的斑块。 黑帽–闭运算与原图像之差，用于分离比临近点暗一些的斑块。 1234567891011121314151617181920212223int main()&#123; Mat img = imread(&quot;alita.png&quot;); Mat out1, out2,out3,out4,out5; //MORPH_RECT表示矩形的卷积核，当然也可以选择椭圆形、交叉型的 Mat element = getStructuringElement(MORPH_RECT, Size(10, 10)); dilate(img, out1, element); erode(img, out2, element); //高级形态学处理，调用这个函数就可以了，具体选择哪种操作，直接修改第三个参数 morphologyEx(img, out3, MORPH_GRADIENT, element); morphologyEx(img, out4, MORPH_TOPHAT, element); morphologyEx(img, out5, MORPH_BLACKHAT, element); imshow(&quot;原图&quot;, img); imshow(&quot;膨胀操作&quot;, out1); imshow(&quot;腐蚀操作&quot;, out2); imshow(&quot;形态学梯度&quot;, out3); imshow(&quot;顶帽&quot;, out4); imshow(&quot;黑帽&quot;, out5); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>腐蚀</tag>
        <tag>膨胀</tag>
        <tag>开闭运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.Filter]]></title>
    <url>%2F2019%2F03%2F25%2FComputerVision%2FOpenCV-ImageProcessing%2F2-Filter%2F</url>
    <content type="text"><![CDATA[OpenCV基本滤波算法分类及作用 线性滤波 方框滤波：模糊图像 均值滤波：模糊图像 高斯滤波：信号的平滑处理，去除符合正态分布的噪声 非线性滤波 中值滤波：去除椒盐噪声 双边滤波：保边去噪 OpenCV中的函数调用1.方框滤波void boxFilter(InputArray src,OutputArray dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), boolnormalize=true, int borderType=BORDER_DEFAULT )用一个像素的领域像素值之和作为滤波结果，邻域即模板所覆盖的图像区域，此时模板的所有系数都为1. 源图像可以是彩色图或者是灰度图,因为图像处理的时候,通道是分开来处理的 目的图像的大小和通道数必须和源图像相同 int类型的ddepth，输出图像的深度，-1代表使用原图深度，即src.depth()。 Size类型（对Size类型稍后有讲解）的ksize，内核的大小 Point类型的anchor，表示锚点（即被平滑的那个点），注意它有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。 bool类型的normalize，默认值为true，一个标识符，表示内核是否被其区域归一化（normalized）了。 int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，我们一般不去管它。 其中f表示原图，h表示核，g表示目标图，当normalize=true的时候，方框滤波就变成了我们熟悉的均值滤波。也就是说，均值滤波是方框滤波归一化（normalized）后的特殊情况。其中，归一化就是把要处理的量都缩放到一个范围内,比如(0,1)，以便统一处理和直观量化. 2.均值滤波void blur(InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )均值滤波就是方框滤波的一个特殊情况，blur函数内部中其实就是调用了一下boxFilter,均值滤波的特点就是不能很好的保护细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊，不能很好的去除噪点。 src,输入图像。该函数对通道是独立处理的,且可以处理任意通道数的图片，但需要注意，待处理的图片深度应该为CV_8U, CV_16U, CV_16S, CV_32F 以及 CV_64F之一。 dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。 Size类型的ksize，内核的大小。一般这样写Size(w,h)来表示内核的大小(其中，w 为像素宽度,h为像素高度)。Size（3,3）就表示3x3的核大小，Size（5,5）就表示5x5的核大小 Point类型的anchor，表示锚点（即被平滑的那个点），注意他有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。 int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，一般不去管它。 3.高斯滤波void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT)高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。从数学的角度来看，图像的高斯模糊过程就是图像与正态分布做卷积。由于正态分布又叫作高斯分布，所以这项技术就叫作高斯模糊。 src，输入图像，即源图像，填Mat类的对象即可。它可以是单独的任意通道数的图片，但需要注意，图片深度应该为CV_8U,CV_16U, CV_16S, CV_32F 以及 CV_64F之一。 dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。 ksize，高斯内核的大小。其中ksize.width和ksize.height可以不同，但他们都必须为正数和奇数。或者，它们可以是零的，它们都是由sigma计算而来。 sigmaX，表示高斯核函数在X方向的的标准偏差。 sigmaY，表示高斯核函数在Y方向的的标准偏差。若sigmaY为零，就将它设为sigmaX，如果sigmaX和sigmaY都是0，那么就由ksize.width和ksize.height计算出来。 4.中值滤波void medianBlur(InputArray src, OutputArray dst, int ksize)基本思想就是用像素点的邻域灰度的中值来代替该像素点的灰度值，该方法在去除脉冲噪声、椒盐噪声的同时又能保留图像的细节，不会出现边缘模糊的情况。中值滤波跟均值滤波的思想看起来很相似，只是一个取平均值，一个取中位数而已 第一个参数，InputArray类型的src，函数的输入参数，填1、3或者4通道的Mat类型的图像；当ksize为3或者5的时候，图像深度需为CV_8U，CV_16U，或CV_32F其中之一，而对于较大孔径尺寸的图片，它只能是CV_8U。 第二个参数，OutputArray类型的dst，需要和源图片有一样的尺寸和类型。 第三个参数，int类型的ksize，孔径的线性尺寸（aperture linear size），注意这个参数必须是大于1的奇数，比如：3，5，7，9 … 中值滤波与均值滤波的比较：均值滤波中噪声成分会被加入到平均计算，所以输出是受到噪声的影响的。但是中值滤波中，由于噪声成分很难选上，所以基本不影响输出。当然好的性能也需要付出一点代价的，中值滤波花费的时间是均值滤波的5倍以上 5.双边滤波void bilateralFilter(InputArray src, OutputArray dst, int d,double sigmaColor,double sigmaSpace,int borderType=BORDER_DEFAULT )双边滤波的最大特点就是做边缘保护。 InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。 OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。.- int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。 double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值越大，表明该像素邻域内有越宽广的颜色会被混合到一起，产生较大的半相等颜色区域。 double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着颜色相近的较远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。当d&gt;0时，d指定了邻域大小且与sigmaSpace五官，否则d正比于sigmaSpace. int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT 123456789101112131415161718int mainfilter()&#123; Mat img = imread(&quot;alita.png&quot;); Mat out1,out2,out3,out4,out5; boxFilter(img, out1, -1, Size(3, 3)); blur(img, out2, Size(3, 3)); GaussianBlur(img, out3, Size(3, 3), 0, 0); medianBlur(img, out4, 5); bilateralFilter(img, out5, 25, 25 * 2, 25 / 2); imshow(&quot;原图&quot;, img); imshow(&quot;方框滤波&quot;, out1); imshow(&quot;均值滤波&quot;, out2); imshow(&quot;高斯滤波&quot;, out3); imshow(&quot;中值滤波&quot;, out4); imshow(&quot;双边滤波&quot;, out5); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>图像滤波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.imageBasicOperation]]></title>
    <url>%2F2019%2F03%2F24%2FComputerVision%2FOpenCV-ImageProcessing%2F1-imageBasicOperation%2F</url>
    <content type="text"><![CDATA[OpenCV Mat类型定义和赋值cv::Mat img(height,width,例：cv::Mat M(480,640,CV_8UC3，Scalar(255,0,0)); 表示定义了一个480行640列的矩阵，矩阵的每个单元的由三个(C3:3 Channel)8位无符号整形(U Unsigned U8 8位)构成,Scalar(255,0,0)表示给每个单元赋值。 123456789101112131415161718192021222324252627282930313233#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char **argv)&#123; //这些方式都是自己拥有独立的内存空间 Mat img1(3, 3, CV_8UC3, Scalar(255, 0, 0)); cout &lt;&lt; img1&lt;&lt;esndl; int sz[3] = &#123; 2, 2, 2 &#125;; Mat img2(3, 3, CV_8UC1, Scalar(200, 0, 255));//单通道的化只会赋值第一个值 cout &lt;&lt; img2 &lt;&lt; endl; Mat img3; img3.create(4, 4, CV_8UC3); cout &lt;&lt; img3 &lt;&lt; endl; Mat img4 = Mat::zeros(4, 4, CV_8UC3); Mat img5 = img4.clone(); Mat img6; img4.copyTo(img6); //clone和copyto函数，这是图像的深拷贝，相当于重新创建了一份一模一样的图像 //下面都是浅拷贝，指针指向同一个实例 Mat img7 = img6; Mat img8(img6); waitKey(0); return 0;&#125; 图像二值化操作threshold —— 简单的阈值操作def threshold(src, dst,thresh, maxval,thresholdType) thresh：Double类型的，具体的阈值 maxval：Double类型的，阈值的最大值 thresholdType: THRESH_BINARY 二进制阈值化 -&gt; 大于阈值为1 小于阈值为0 THRESH_BINARY_INV 反二进制阈值化 -&gt; 大于阈值为0 小于阈值为1 THRESH_TRUNC 截断阈值化 -&gt; 大于阈值为阈值，小于阈值不变 THRESH_TOZERO 阈值化为0 -&gt; 大于阈值的不变，小于阈值的全为0 THRESH_TOZERO_INV 反阈值化为0 -&gt; 大于阈值为0，小于阈值不变 adaptiveThreshold —— 自适应阈值操作def adaptiveThreshold(src,dst,maxValue,adaptiveMethod,thresholdType,blockSize,C) maxval：Double类型的，阈值的最大值 adaptiveMethod： ADAPTIVE_THRESH_MEAN_C（通过平均的方法取得平均值)ADAPTIVE_THRESH_GAUSSIAN_C(通过高斯取得高斯值) thresholdType同上 blockSize：Int类型的，这个值来决定像素的邻域块有多大（这里的blockSize的值要为奇数，否则会给出这样的提示：Assertion failed (blockSize % 2 == 1 &amp;&amp; blockSize &gt; 1) in cv::adaptiveThreshold ） C：偏移值调整量，计算adaptiveMethod用到的参数 总结： 在两种情况下，自适应阈值T(x, y)。通过计算每个像素周围bxb大小像素块的加权均值并减去常量C得到。其中，b由blockSize给出，大小必须为奇数；如果使用平均的方法，则所有像素周围的权值相同；如果使用高斯的方法，则（x,y）周围的像素的权值则根据其到中心点的距离通过高斯方程得到。 12345678910111213141516171819202122232425262728#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char **argv)&#123; Mat img = imread(&quot;groot.jpg&quot;, CV_LOAD_IMAGE_GRAYSCALE);//载入灰度图 if (img.empty())&#123; cout &lt;&lt; &quot;read img falied!\n&quot;; return -1; &#125; //全局二值化 int th = 150; Mat global; threshold(img, global, th, 255, CV_THRESH_BINARY); //局部二值化 int blockSize = 25; int constValue = 10; Mat local; adaptiveThreshold(img, local, 255, CV_ADAPTIVE_THRESH_MEAN_C, CV_THRESH_BINARY, blockSize, constValue); imshow(&quot;原图&quot;, img); imshow(&quot;全局二值化&quot;, global); imshow(&quot;局部二值化&quot;, local); waitKey(0); return 0;&#125; 运行结果如下： 访问图片中的像素①指针访问：最快 ②迭代器iterator：较慢，非常安全，指针访问可能出现越界问题 ③动态地址计算：更慢，通过at()实现。适用于访问具体某个第i行，j列的像素，而不适用遍历像素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;void visitByPointer(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); int rows = dstImg.rows; int cols = dstImg.cols*dstImg.channels(); for (int i = 0; i &lt; rows; i++) &#123; uchar *data = dstImg.ptr&lt;uchar&gt;(i);//获取第i行地址 for (int j = 0; j &lt; cols; j++)&#123; data[j] += 10; //add code 处理每一个像素 &#125; &#125;&#125;void visitByIterator(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); const int chanels = dstImg.channels(); switch (chanels) &#123; case 1:&#123; Mat_&lt;uchar&gt;::iterator it = dstImg.begin&lt;uchar&gt;(); Mat_&lt;uchar&gt;::iterator itend = dstImg.end&lt;uchar&gt;(); for (; it != itend;it++) &#123; *it += 10;//处理每个像素 &#125;break; &#125; case 3:&#123; Mat_&lt;Vec3d&gt;::iterator it3 = dstImg.begin&lt;Vec3d&gt;(); Mat_&lt;Vec3d&gt;::iterator it3end = dstImg.end&lt;Vec3d&gt;(); for (; it3 != it3end;it3++) &#123; (*it3)[0] += 10; (*it3)[1] -= 10; (*it3)[2] -= 10; &#125;break; &#125; default: break; &#125;&#125;void visitByAt(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); int rows = dstImg.rows; int cols = dstImg.cols; int channels = dstImg.channels(); switch (channels) &#123; case 1:&#123; for (int i = 0; i &lt; rows;i++) &#123; for (int j = 0; j &lt; cols;j++) &#123; dstImg.at&lt;uchar&gt;(i, j) += 10; &#125; &#125;break; &#125; case 3:&#123; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; dstImg.at&lt;Vec3d&gt;(i, j)[0] += 10; dstImg.at&lt;Vec3d&gt;(i, j)[1] -= 10; dstImg.at&lt;Vec3d&gt;(i, j)[2] -= 10; &#125; &#125;break; &#125; default: break; &#125;&#125;int main(int argc, char **argv)&#123; Mat img = imread(&quot;Lena.png&quot;); Mat dstImg1,dstImg2,dstImg3; visitByPointer(img, dstImg1); visitByIterator(img, dstImg2); //visitByAt(img, dstImg3); imshow(&quot;原图&quot;, img); imshow(&quot;指针访问&quot;, dstImg1); imshow(&quot;迭代器访问&quot;, dstImg2); //imshow(&quot;at访问&quot;, dstImg3); waitKey(0); return 0;&#125; 常用的数据结构12345678910111213141516171819202122232425262728293031323334353637int main(int argc,char** argv)&#123; Mat m1(3, 3, CV_8UC3, Scalar(255, 0, 0));//其中宏的解释：CV_[位数][带符号与否][类型前缀]C[通道数] cout &lt;&lt; m1 &lt;&lt; endl;//输出的就是3*9的矩阵 //或者利用IplImage指针来初始化，将IplImage*转化为Mat IplImage* img = cvLoadImage(&quot;Lena.png&quot;); Mat m2 = cvarrToMat(img); //Mat转IplImage IplImage img2 = IplImage(m2); Mat m3; m3.create(3, 3, CV_8UC(2)); cout &lt;&lt; m3 &lt;&lt; endl; //点的表示 Point p1; p1.x = 1; p1.y = 1; //或者 Point p2(1, 1); //颜色的表示：Scalar(b,g,r) Scalar(1, 1, 1) ; //尺寸的表示：Size Size(2,3);//宽和高 //矩形的表示：Rect，成员变量有x、y、width、height Rect r1(0, 0, 100, 200); Rect r2(10, 10, 100, 200); Rect r3 = r1 | r2;//两个矩形求交集 Rect r4 = r1 &amp; r2;//两个矩形求并集 waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>Mat初始化</tag>
        <tag>访问像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径中斜杠和反斜杠的区别]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9A%8F%E7%AC%94%2F%E8%B7%AF%E5%BE%84%E4%B8%AD%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8F%8D%E6%96%9C%E6%9D%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Unix使用斜杠/ 作为路径分隔符，而web应用最新使用在Unix系统上面，所以目前所有的网络地址都采用斜杠/ 作为分隔符; Windows由于使用斜杠/作为DOS命令提示符的参数标志了，为了不混淆，所以采用反斜杠\作为路径分隔符。所以目前Windows系统上的文件目录结构都是用反斜杠\作为路径分隔符。随着发展，DOS系统已经被淘汰了，命令提示符用的很少，斜杠和反斜杠在大多数情况下可以互换。 总结: 浏览器地址栏网址使用斜杠/ Windows文件目录结构地址使用反斜杠\ 出现heml url()属性中的路径，指定的路径是网络路径，所以必须用斜杠/ 出现在普通字符串中的路径，如果代表的是Windows文件路径，则使用斜杠和反斜杠是一样的，如果代表的是网络文件路径，则必须使用斜杠/ 上面提到斜杠/是url地址中用到的分隔符；对应的，双斜杠//用在网络域名访问中，是协议和主机名或IP地址之间的分隔符，以双斜杠//开头的是一俩url是依赖协议的url表示形式，URL格式：协议://域名或IP/请求文件路径/文件名；如百度的网址：https://www.baidu.com/ 。URL默认以斜杠/结尾，而没有给出文件名的情况下，URL引用路径中最后一个目录中的默认文件(通常对应于主页). 反斜杠是Windows系统文件目录结构使用的分隔符，如：D:\allDream(用反斜杠也可以，但是双斜杠或双反斜杠不行)。对应的，双反斜杠\在Windows里表示绝对地址的第一项，后面跟IP地址或计算机名，就是需要打开这个IP地址或计算机名对应主机的网络共享资源。]]></content>
      <tags>
        <tag>Node</tag>
        <tag>路径分隔符/&amp;\</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-TwoSum]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode%E5%88%B7%E9%A2%98%2FLeetCode-TwoSum%2F</url>
    <content type="text"><![CDATA[1.Two Sum (1)Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解题思路 定义一个unordered_map变量record，用于保存遍历过的元素的下标； 遍历数组的每一个元素，如果target减去nums[i]的值在record中，则直接返回两个下标，否则将该元素插入到record中，继续循环； 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; record; for(int i=0;i&lt;nums.size();i++)&#123; int complement=target-nums[i]; if(record.find(complement)!=record.end())&#123; int res[]=&#123;record[complement],i&#125;; return vector&lt;int&gt; &#123;res,res+2&#125;; &#125; record[nums[i]]=i; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; Two Sum II (167)这道题目和剑指offer上”和为s的两个数字”是一样的。 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice.Example: Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 解法一：暴力+二分搜索给定的数组有序，而且题目中限定一定有解，那么可以使用两层循环进行暴力求解，外层循环遍历数组，作为第一个元素，然后内层循环使用二分法来搜索target-numbers[i]即可。时间复杂度为O(nlogn).12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; for(int i=0;i&lt;numbers.size();i++)&#123; int t=target-numbers[i],left=i+1,right=numbers.size()-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(numbers[mid]==t) return vector&lt;int&gt; &#123;i+1,mid+1&#125;; else if(numbers[mid]&lt;t) left=mid+1; else right=mid-1; &#125; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 解法二：对撞指针需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加刚好等于target，直接返回两个指针的位置，若小于target，左指针右移，若大于target，有指针左移，以此类推直到两个指针相遇停止。时间复杂度为O(n).123456789101112131415161718// 对撞指针// Time：O(n)// Space:O(1)class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int i=0,j=numbers.size()-1; while(i&lt;j)&#123; if(numbers[i]+numbers[j]==target) return vector&lt;int&gt; &#123;i+1,j+1&#125;; else if(numbers[i]+numbers[j]&lt;target) i++; else j--; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 和为s的连续正整数序列要求计算出9~16的和,写出正确答案是100。究竟有多少种连续的正数序列的和为100(至少包括两个数)。另一组连续正数和为100的序列:18,19,20,21,22。现有问题如下,能不能也很快的找出所有和为S的连续正数序列? 输出所有和为S的正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。 方法一：暴力求解——滑动窗口思想将序列(1, 2)作为初始序列，small表示序列的第一个，big表示序列的最后一个。如果序列中和小于所求值，序列的big往前走一个从而把一个更大的数包括到序列中；如果序列中和小于所求值，small往前走一个把原来序列中最小的数排除出去。如果相等，打印出当前序列，big继续往前走一个，来寻找新的序列。一直到big大于等于所求和的一半了，遍历就停止了。 整个思路就像模拟了一个窗口在变化，这种方法本质上依然是贪心，不过是首位双指针的贪心。123456789101112131415161718192021222324252627282930313233//牛客网上的解决方案class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(sum&lt;3) return res; int small=1,big=2; int mid=(1+sum)&gt;&gt;1; int curSum=small+big; while(small&lt;mid)&#123; if(curSum==sum) InsertRes(small,big,res); while(curSum&gt;sum&amp;&amp;small&lt;mid)&#123; curSum-=small; small++; if(curSum==sum)&#123; InsertRes(small,big,res); &#125; &#125; big++; curSum+=big; &#125; return res; &#125;private: void InsertRes(int begin,int end,vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123; vector&lt;int&gt; temp; for(int i = begin;i&lt;=end;i++) temp.push_back(i); res.push_back(temp); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>窗口思想</tag>
        <tag>中位数法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法小结]]></title>
    <url>%2F2019%2F03%2F22%2FMarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MarkDown修改字体颜色用代码进行更改字体颜色，还可以修改字体大小、字体格式等 。1234567891011121314&lt;font 更改语法&gt; 你的内容 &lt;/font&gt;更改语法有: color=#0099ff 更改字体颜色face=&quot;黑体&quot; 更改字体size= 7 更改字体大小 &lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 常用颜色表：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145颜色名 十六进制颜色值 颜色AliceBlue #F0F8FF rgb(240, 248, 255)AntiqueWhite #FAEBD7 rgb(250, 235, 215)Aqua #00FFFF rgb(0, 255, 255)Aquamarine #7FFFD4 rgb(127, 255, 212)Azure #F0FFFF rgb(240, 255, 255)Beige #F5F5DC rgb(245, 245, 220)Bisque #FFE4C4 rgb(255, 228, 196)Black #000000 rgb(0, 0, 0)BlanchedAlmond #FFEBCD rgb(255, 235, 205)Blue #0000FF rgb(0, 0, 255)BlueViolet #8A2BE2 rgb(138, 43, 226)Brown #A52A2A rgb(165, 42, 42)BurlyWood #DEB887 rgb(222, 184, 135)CadetBlue #5F9EA0 rgb(95, 158, 160)Chartreuse #7FFF00 rgb(127, 255, 0)Chocolate #D2691E rgb(210, 105, 30)Coral #FF7F50 rgb(255, 127, 80)CornflowerBlue #6495ED rgb(100, 149, 237)Cornsilk #FFF8DC rgb(255, 248, 220)Crimson #DC143C rgb(220, 20, 60)Cyan #00FFFF rgb(0, 255, 255)DarkBlue #00008B rgb(0, 0, 139)DarkCyan #008B8B rgb(0, 139, 139)DarkGoldenRod #B8860B rgb(184, 134, 11)DarkGray #A9A9A9 rgb(169, 169, 169)DarkGreen #006400 rgb(0, 100, 0)DarkKhaki #BDB76B rgb(189, 183, 107)DarkMagenta #8B008B rgb(139, 0, 139)DarkOliveGreen #556B2F rgb(85, 107, 47)Darkorange #FF8C00 rgb(255, 140, 0)DarkOrchid #9932CC rgb(153, 50, 204)DarkRed #8B0000 rgb(139, 0, 0)DarkSalmon #E9967A rgb(233, 150, 122)DarkSeaGreen #8FBC8F rgb(143, 188, 143)DarkSlateBlue #483D8B rgb(72, 61, 139)DarkSlateGray #2F4F4F rgb(47, 79, 79)DarkTurquoise #00CED1 rgb(0, 206, 209)DarkViolet #9400D3 rgb(148, 0, 211)DeepPink #FF1493 rgb(255, 20, 147)DeepSkyBlue #00BFFF rgb(0, 191, 255)DimGray #696969 rgb(105, 105, 105)DodgerBlue #1E90FF rgb(30, 144, 255)Feldspar #D19275 rgb(209, 146, 117)FireBrick #B22222 rgb(178, 34, 34)FloralWhite #FFFAF0 rgb(255, 250, 240)ForestGreen #228B22 rgb(34, 139, 34)Fuchsia #FF00FF rgb(255, 0, 255)Gainsboro #DCDCDC rgb(220, 220, 220)GhostWhite #F8F8FF rgb(248, 248, 255)Gold #FFD700 rgb(255, 215, 0)GoldenRod #DAA520 rgb(218, 165, 32)Gray #808080 rgb(128, 128, 128)Green #008000 rgb(0, 128, 0)GreenYellow #ADFF2F rgb(173, 255, 47)HoneyDew #F0FFF0 rgb(240, 255, 240)HotPink #FF69B4 rgb(255, 105, 180)IndianRed #CD5C5C rgb(205, 92, 92)Indigo #4B0082 rgb(75, 0, 130)Ivory #FFFFF0 rgb(255, 255, 240)Khaki #F0E68C rgb(240, 230, 140)Lavender #E6E6FA rgb(230, 230, 250)LavenderBlush #FFF0F5 rgb(255, 240, 245)LawnGreen #7CFC00 rgb(124, 252, 0)LemonChiffon #FFFACD rgb(255, 250, 205)LightBlue #ADD8E6 rgb(173, 216, 230)LightCoral #F08080 rgb(240, 128, 128)LightCyan #E0FFFF rgb(224, 255, 255)LightGoldenRodYellow #FAFAD2 rgb(250, 250, 210)LightGrey #D3D3D3 rgb(211, 211, 211)LightGreen #90EE90 rgb(144, 238, 144)LightPink #FFB6C1 rgb(255, 182, 193)LightSalmon #FFA07A rgb(255, 160, 122)LightSeaGreen #20B2AA rgb(32, 178, 170)LightSkyBlue #87CEFA rgb(135, 206, 250)LightSlateBlue #8470FF rgb(132, 112, 255)LightSlateGray #778899 rgb(119, 136, 153)LightSteelBlue #B0C4DE rgb(176, 196, 222)LightYellow #FFFFE0 rgb(255, 255, 224)Lime #00FF00 rgb(0, 255, 0)LimeGreen #32CD32 rgb(50, 205, 50)Linen #FAF0E6 rgb(250, 240, 230)Magenta #FF00FF rgb(255, 0, 255)Maroon #800000 rgb(128, 0, 0)MediumAquaMarine #66CDAA rgb(102, 205, 170)MediumBlue #0000CD rgb(0, 0, 205)MediumOrchid #BA55D3 rgb(186, 85, 211)MediumPurple #9370D8 rgb(147, 112, 216)MediumSeaGreen #3CB371 rgb(60, 179, 113)MediumSlateBlue #7B68EE rgb(123, 104, 238)MediumSpringGreen #00FA9A rgb(0, 250, 154)MediumTurquoise #48D1CC rgb(72, 209, 204)MediumVioletRed #C71585 rgb(199, 21, 133)MidnightBlue #191970 rgb(25, 25, 112)MintCream #F5FFFA rgb(245, 255, 250)MistyRose #FFE4E1 rgb(255, 228, 225)Moccasin #FFE4B5 rgb(255, 228, 181)NavajoWhite #FFDEAD rgb(255, 222, 173)Navy #000080 rgb(0, 0, 128)OldLace #FDF5E6 rgb(253, 245, 230)Olive #808000 rgb(128, 128, 0)OliveDrab #6B8E23 rgb(107, 142, 35)Orange #FFA500 rgb(255, 165, 0)OrangeRed #FF4500 rgb(255, 69, 0)Orchid #DA70D6 rgb(218, 112, 214)PaleGoldenRod #EEE8AA rgb(238, 232, 170)PaleGreen #98FB98 rgb(152, 251, 152)PaleTurquoise #AFEEEE rgb(175, 238, 238)PaleVioletRed #D87093 rgb(216, 112, 147)PapayaWhip #FFEFD5 rgb(255, 239, 213)PeachPuff #FFDAB9 rgb(255, 218, 185)Peru #CD853F rgb(205, 133, 63)Pink #FFC0CB rgb(255, 192, 203)Plum #DDA0DD rgb(221, 160, 221)PowderBlue #B0E0E6 rgb(176, 224, 230)Purple #800080 rgb(128, 0, 128)Red #FF0000 rgb(255, 0, 0)RosyBrown #BC8F8F rgb(188, 143, 143)RoyalBlue #4169E1 rgb(65, 105, 225)SaddleBrown #8B4513 rgb(139, 69, 19)Salmon #FA8072 rgb(250, 128, 114)SandyBrown #F4A460 rgb(244, 164, 96)SeaGreen #2E8B57 rgb(46, 139, 87)SeaShell #FFF5EE rgb(255, 245, 238)Sienna #A0522D rgb(160, 82, 45)Silver #C0C0C0 rgb(192, 192, 192)SkyBlue #87CEEB rgb(135, 206, 235)SlateBlue #6A5ACD rgb(106, 90, 205)SlateGray #708090 rgb(112, 128, 144)Snow #FFFAFA rgb(255, 250, 250)SpringGreen #00FF7F rgb(0, 255, 127)SteelBlue #4682B4 rgb(70, 130, 180)Tan #D2B48C rgb(210, 180, 140)Teal #008080 rgb(0, 128, 128)Thistle #D8BFD8 rgb(216, 191, 216)Tomato #FF6347 rgb(255, 99, 71)Turquoise #40E0D0 rgb(64, 224, 208)Violet #EE82EE rgb(238, 130, 238)VioletRed #D02090 rgb(208, 32, 144)Wheat #F5DEB3 rgb(245, 222, 179)White #FFFFFF rgb(255, 255, 255)WhiteSmoke #F5F5F5 rgb(245, 245, 245)Yellow #FFFF00 rgb(255, 255, 0)YellowGreen #9ACD32 rgb(154, 205, 50)]]></content>
      <tags>
        <tag>Node</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法_递归]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[1.如何理解”递归”？当你在电影院看电影时忘记自己是在第几排，电影院里面太黑看不清，没法数，于是就问前面的人他是第几排，你想只要在他的数字上加1，就知道自己是在哪一排了；但是前面的人也看不清啊，所以他也问他前面的人…就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排把数字传回来，于是你就知道答案了。这就是一个非常标准的递归求解问题的分解过程，去的过程叫”递”，回来的过程叫”归”。基本上，所有的递归问题都可以用递推公式来表示。12f(n)=f(n-1)+1 其中，f(1)=1 2.递归需要满足的三个条件2.1 一个问题的解可以分解为几个子问题的解子问题就是数据规模更小的问题。比如，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。 2.2 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样你在求解“自己在哪一排”的思路，和前一排的人求解“自己在哪一排”的思路是一模一样的。 2.3 存在递归终止条件写递归代码最关键的是写出递推公式，找到终止条件。举个例子：假如这里有n个台阶，每次可以跨1个台阶或2个台阶，请问走完这n个台阶有多少种走法？可以这样思考：走到第n个台阶的走法有两类，第一类是从第n-1阶走了1个台阶，另一类是从n-2阶走了2个台阶。所以n个台阶的走法就等于:(走n-1阶的走法，再走1个台阶)+(走n-2阶的走法，再走2个台阶)，用公式表示就是：1f(n)=f(n-1)+f(n-2) 来看终止条件：当有一个台阶时，就只有一种走法 ，所以f(1)=1。如果递归终止条件只有f(1)=1一个，那f(2)就没法求解了，所以我们可以把f(2)=2作为另一个终止条件。123f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2) 最终的递归代码：12345int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; return f(n-1) + f(n-2);&#125; 总结： 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 3.递归代码要警惕堆栈溢出函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完返回时，才出栈。系统栈或则虚拟机栈空间一般都不大，如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。 4.递归代码要警惕重复计算上述第二个递归例子，如果把整个过程分解一下，如图所示：从图中可以发现，计算f(5)时，要先计算f(4)和f(3),而计算f(4)时还需要计算f(3),因此f(3)被计算了很多次，这就是重复计算问题。重复子问题可以用数组保存中间值的方法来优化，之后动态规划问题会用到这类思想。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——二维数组中的查找]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。时间限制：1秒 空间限制：32768K 解题思路利用二维数组从上到下、从左到右递增的规律，选取右上角或左下角的元素a[i][j]与target比较： 当target小于元素a[i][j]时，那么target必定在元素a[i][j]所在行的左边，即j–； 当target大于元素a[i][j]时，那么target必定在元素a[i][j]所在列的下边，即i++。 1234567891011121314151617class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row=array.size(); int col=array[0].size(); int i=0,j=col-1;//坐标定在右上角 while( i&lt;row &amp;&amp; j&gt;=0)&#123; if(target==array[i][j]) return true; else if(target&lt;array[i][j]) j--;//遇小左移 else i++;//遇大下移 &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>数组</tag>
        <tag>元素查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——把数组排成最小的数]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。时间限制：1秒 空间限制：32768K 解题思路 将数组中的整数数组转换成字符串数组； 自定义一个比较大小的函数，比较两个字符串s1和s2大小的时候，先将它们拼起来，比较s1+s2和s2和s1哪个大，如果s1+s2大，说明s2应该放前面，根据这个规则将所有的字符换排序； 拼接所有的字符串数组中的元素。 123456789101112131415161718class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string res; vector&lt;string&gt; str; for(int i=0;i&lt;numbers.size();i++) str.push_back(to_string(numbers[i])); sort(str.begin(),str.end(),myCompare); for(int i=0;i&lt;str.size();i++) res+=str[i]; return res; &#125;private: static bool myCompare(string &amp;s1,string &amp;s2)&#123; return s1+s2 &lt; s2+s1; &#125;&#125;; tips：1. sort()函数的第三个参数自定义的比较函数返回值类型应该是static bool，不然会报错,但是在其他编译器中只要自定义函数返回的是bool类型的就可以了，没必要是静态函数。 ./solution.h:8:36: error: reference to non-static member function must be calledsort(str.begin(),str.end(),myCompare); 2. 深究STL的sort()函数以前在自定义比较函数时一直都有个疑问，当什么情况下会进行升序排列、什么情况下又进行降序排列呢？传入的两个参数应该如何进行比较？在这里推荐直接看C++技术文档 comp函数返回值：返回一个bool类型的值，这个值表示了在上升序列中第一个参数是否位于第二个参数之前。 如果comp返回true，sort根据返回值将第一个参数排在第二个参数前面； 如果comp返回false，sort根据返回值将第一个参数排在第二个参数后面。 本题中，当s1+s2 &lt; s2+s1时，s1应该排在s2前面，即排序结果能够使数据最小。 总结sort函数根据comp函数的返回值，对comp函数的两个参数排序：如果comp返回true，排序为 参数1、参数2，否则排序为 参数2、参数1。升序排列，则return para1para2]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>数组</tag>
        <tag>sort函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——数组：为什么很多编程语言中数组都从0开始编号？]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前言在每一种编程语言中，基本都会有数组这种数据类型。但它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。大部分编程语言中，数组都是从0开始编号的，但你是否下意识的想过，为什么数组要从0开始编号，而不是从1开始呢？ 从1开始不是更符合人类的思维习惯吗？ 如何实现随机访问？数组(Array)是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。 接下来分两个角度来理解。 第一个是线性表 线性表就是数据拍成向一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈也是线性表结构。 与之对应的是非线性表 。如二叉树、堆、图等，在非线性表中，数据之间并不是简单的前后关系。 第二个是连续的内存空间和相同类型的数据。 因为这两个限制它才有了随机访问的特性，但也让数组的删除、插入变得非常低效，为了保证连续性，就需要做大量的数据搬移工作。 数组是如何实现根据下标随机访问数组元素的呢？拿一个长度为10的int类型的数组int[] a=new int[10]来举例。计算机给数组a分配一块连续内存空间1000-1039，其中内存块的首地址为base_address=1000。计算机通过地址来访问内存中的数据，当计算机需要访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：a[i]_address=base_address+i×data_type_size 面试的时候，经常会问数组和链表的区别，很多人回答说“链表适合插入删除，时间复杂度为O(1)；数组适合查找，查找时间为O(1)”。这种描述是不准确的。数组是适合查找，但是查找的时间复杂度并不为O(1).即使是排好序的数组，用二分查找，时间的复杂度也是O(logn)，所以正确的描述应该是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。 低效的插入和删除数组为了保证内存数据的连续性，会导致插入、删除操作比较低效。现在我们来讨论一下，究竟为什么会导致低效？又有哪些改进方法？ 插入操作假设数组长度为n，现在需要将一个数据插入到数组中的第k个位置，须将k~n这部分的元素都顺序的往后挪一位，平均情况时间复杂度为O(n)。如果数组中的数据是有序的，我们在某个位置插入一个新元素时，就必须安装刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，，在这种情况下，要将某个元素插入到第k个位置，为避免大规模的数据搬移，有一个简单的办法就是直接将第k为的数据搬移到数组元素的最后，把新的元素直接放到第k个位置。这种处理技巧，在特性场景下，在第k个位置插入一个元素的时间复杂度就会降到O(1)。这个处理思想在快排中也会用到。 删除操作和插入类似，如果删除数组末尾的数据，最好情况时间复杂度为O(1),如果删除开头的数据，则最坏情况时间复杂度为O(n),平均情况时间复杂度为O(n)。实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多！例如，数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在要依次删除a,b,c三个元素。为避免多次数据搬移，我们可以先记录下已经删除的数据。每次的删除操作并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 解答开篇问题从数组储存的内存模型来看，“下标”最确切的定义应该是“偏移”，根据前面讲到的寻址公式，如果数组从1开始计数，那么我们计算数组元素a[i]的内存地址就会变成： a[i]_address=base_address+i×data_type_size对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的操作，效率的优化就要尽可能做到极致。数组选择从0开始，而不是从1开始，最主要的原因可能是历史原因。## 相关思考题目### JVM的标记清楚垃圾回收算法的核心理念大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。不足：- 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时效率较高。- 空间问题。会产生不连续的内存空间碎片。### 二维数组的内存寻址公式假设二维数组大小为m*n,则a[i][j]的地址为：a[i][j]_address=base_address+(i×m+j)×data_type_size]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——二进制中1的个数 & 整数中1出现的次数]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20%26%20%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述：二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解法一基本思路： 先判断整数二进制表示中最右边是不是为1，如果是则计数器自增1；接着把输入的整数右移一位，继续判断二进制表示中最右边是否为1，直到整个数变为0为止。代码如下所示，case通过率0.00%，超时引起的，是因为如果输入的是负数，右移时，为保证移位后是一个负数，因此移位后的最高为会设1.如果一直做右移，那么这个数字最终会变为0xFFFFFFFF而陷入死循环。若n=n&gt;&gt;1;改为n/=2;通过率为55.56%，还没找到是什么原因？ 12345678910111213class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n)&#123; if(n&amp;1) res++; n=n&gt;&gt;1; &#125; return res; &#125;&#125;; 解法二基本思路： 为避免死循环，不右移输入的数字，而是定义一个无符号整型变量flag，让flag返回左移，与输入的数字进行与运算，如下：然鹅case通过率为11.11%，看书写的代码，我也不清楚为什么这样！！ 1234567891011121314class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; unsigned int flag=1; while(flag)&#123; if(n&amp;&amp;flag) res++; flag=flag&lt;&lt;1; &#125; return res; &#125;&#125;; 解法三基本思路： 这种解法就厉害了，整数的二进制表示中有几个1就执行几次循环，步骤：把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变为0. 123456789101112class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n)&#123; res++; n=(n-1)&amp;n; &#125; return res; &#125;&#125;; Tips:位运算左移右移计算机表示数字正负不是用+、-号来表示，而是用最高位数字来表示，0表示正，1表示负。 1.有符号右移&gt;&gt;（若正数，高位补0，若负数，高位补1）正数：4&gt;&gt;2 右移两位，高为补0(0000 0000 0000 0000 0000 0000 0000 0100)&gt;&gt;(000000 0000 0000 0000 0000 0000 0000 01)结果为1，即4/(2^2) 负数：-4&gt;&gt;2 (-4的二进制为4的原码取反再加1，如下)右移两位，高位补1(1111 1111 1111 1111 1111 1111 1111 1100)&gt;&gt;(1111 1111 1111 1111 1111 1111 1111 1111)根据上述得到的补码求出源码才是我们所求的结果，保留符号位，然后按位取反再加1，为(100000 0000 0000 0000 0000 0000 0000 01),结果为-1，即-4/(2^2)。 2.无符号右移&gt;&gt;&gt;(无论正负，高位均补0)正数：4&gt;&gt;&gt;2 与4&gt;&gt;2的运算结果相同，结果也是1 负数：-4&gt;&gt;&gt;2(1111 1111 1111 1111 1111 1111 1111 1100)&gt;&gt;&gt;(0011 1111 1111 1111 1111 1111 1111 1111)结果为1073741823 3.左移&lt;&lt;(不区分有符号和无符号)分析num&lt;&lt;n 相当于num(num的二进制)向左移动n位； 左边(高位)溢出部分直接舍弃；右边(低位)移入部分全部补0； 移位结果：若左移时舍弃的高位不包括1，则没左移一位，就相当于该数乘以2.(左移有可能导致符号变化) 题目描述：整数中1出现的次数求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解法一：暴力解决累加1~n中每个正数1的个数。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int res=0; for(int i=1;i&lt;=n;i++)&#123; res+=numberOf1(i); &#125; return res; &#125;private: int numberOf1(unsigned int i)&#123; int res=0; while(i)&#123; if(i%10==1) res++; i/=10; &#125; return res; &#125;&#125;; 解法二：找规律1的数目： 如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定（若没有高位，视高位为0），等于更高位数字X当前位数的权重10^(i-1); 如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响（若没有低位，视低位为0），等于更高位数字X当前位数的权重10^i-1+（低位数字+1）; 如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），等于（更高位数字+1）X当前位数的权重10i-1。 X的数目：这里的X∈[1,9],因为X=0不符合下列规律，需单独计算。首先直到以下的规律： 从1-10，在它们的个位数中，任意的X都出现了1次； 从1-100，在它们的十位数中，任意的X都出现了10次； 从1-1000，在它们的百位数中，任意的X都出现了100次； 依次类推，从1-10^i,在他们的左边第二位(右数第i位)中，任意的X都出现了10^i-1次。 接下来以n=2593，X=5为例来解释如何得到数学公式。从1至2593中，数字 5 总计出现了 813 次，其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。 首先是个位。从 1 至 2590 中，包含了 259 个 10，因此任意的 X 都出现了 259 次。最后剩余的三个数 2591, 2592 和 2593，因为它们最大的个位数字 3 &lt; X，因此不会包含任何 5。（也可以这么看，3&lt;X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字（259）X10^(1-1)=259）； 然后是十位。从 1 至 2500 中，包含了 25 个 100，因此任意的 X 都出现了 25×10=250 次。剩下的数字是从 2501 至 2593，它们最大的十位数字 9 &gt; X，因此会包含全部 10 个 5。最后总计 250 + 10 = 260。（也可以这么看，9&gt;X，则十位上可能出现的X的次数仅由更高位决定，等于更高位数字（25+1）X10^(2-1)=260）； 接下来是百位。从 1 至 2000 中，包含了 2 个 1000，因此任意的 X 都出现了 2×100=200 次。剩下的数字是从 2001 至 2593，它们最大的百位数字 5 == X，这时情况就略微复杂，它们的百位肯定是包含 5 的，但不会包含全部 100 个。如果把百位是 5 的数字列出来，是从 2500 至 2593，数字的个数与百位和十位数字相关，是 93+1 = 94。最后总计 200 + 94 = 294。（也可以这么看，5==X，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，等于更高位数字（2）X10^(3-1)+（93+1）=294）； 最后是千位。现在已经没有更高位，因此直接看最大的千位数字 2 &lt; X，所以不会包含任何 5。（也可以这么看，2&lt;X，则千位上可能出现的X的次数仅由更高位决定，等于更高位数字（0）X10^(4-1)=0）。 总结一下以上的算法，可以看到，当计算右数第 i 位包含的 X 的个数时： 取第 i 位左边（高位）的数字，乘以 10^i−1 ，得到基础值 a 。 取第 i 位数字，计算修正值： 如果大于 X，则结果为 a+ 10^i−1 。 如果小于 X，则结果为 a 。 如果等 X，则取第 i 位右边（低位）数字，设为 b ，最后结果为 a+b+1 。 相应的代码非常简单，效率也非常高，时间复杂度只有 O(log_10^n) 。 123456789101112131415161718192021222324class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int res=0; int high,low,tmp,cur,i=1; high=n; while(high)&#123; high=n/(int)pow(10,i);//求第i位的高位 tmp=n%(int)pow(10,i); cur=tmp/(int)pow(10,i-1);//求第i位的值 low=tmp%(int)pow(10,i-1);//求第i位的低位 if(cur==1) res+=high*(int)pow(10,i-1)+low+1; else if(cur&lt;1) res+=high*(int)pow(10,i-1); else res+=(high+1)*(int)pow(10,i-1); i++; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>二进制</tag>
        <tag>数1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法(一)]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[操作系统做了什么看不下去了！！！]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——复杂度分析]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据结构与算法概念理解从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。狭义上讲，就是指某些著名的数据结构和算法。 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、回溯算法、分治算法、动态规划、字符串匹配算法。 上面最常用、最基础的20个数据结构与算法，要学习它们的”来历”、”特点”、”适合解决什么问题”以及”实际的应用场景”。 下面放一张数据结构和算法的知识图谱：数据结构是为算法服务的，算法要作用在特定的数据结构之上。 那么接下来就开始学习一个数据结构与算法中最重要的概念——复杂度分析。 复杂度分析(上)——如何分析、统计算法的执行效率和资源消耗事后统计法把代码跑一边，通过统计、监控就能得到算法执行的时间和占用的内存大小。但是这种统计法有非常大的局限性。 测试结果非常依赖测试环境 测试结果受数据规模的影响很大，比如对同一个算法，待排序的数据有序度不一样，排序的时间会有河大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作执行时间非常短。此外，测试数据规模小，测试结果无法真实的反应算法的性能。比如对于小规模的数据排序，插入排序可能回避快排要块！ 大O表示法 大O时间复杂度表示法T(n)=O(f(n))其中T(n)表示代码执行的时间，n表示数据规模大小，f(n)表示每行代码执行的次数总和。公式中的O表示代码的执行时间T(n)与f(n)表达式成正比。 时间复杂度分析 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度示例分析对于复杂度量级，可以粗略的分为多项式量级 和非多项式量级 。如下图： O(1)代码执行的时间不随n的增大而增大。算法中不存在循环递归语句，即使有千万行代码，其时间复杂度也是O(1)。 O(logn)、O(nlogn) 1234int i=1;while(i&lt;=n)&#123; i*=2; &#125; 归并排序、快速排序的时间复杂度就是O(nlogn)。 O(m+n)、O(m*n)代码的复杂度由两个数据的规模来决定。 空间复杂度常见的空间复杂度就是O(1)、O(n)、O(n^2)。 复杂度分析(下)——浅析最好、最坏、平均、均摊时间复杂度最好、最坏时间复杂度例如，在一个无序数组中查找变量x。如果数组中第一个元素就是要查找的变量x，那就不需要遍历剩下的n-1个数据了，最好时间复杂度为O(1)。但如果数组中不存在x，那就要把数组遍历一遍，最坏时间复杂度为O(n)。 平均情况时间复杂度依然分析查找变量x的例子：要查找的变量x在数组中的位置，有n+1中情况：在数组的0~n-1为之中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后除以n+1，就可以得到需要遍历的元素个数的平均值。上面的推导存在一个问题就是没有把各种情况发生的概率考虑进去。假设变量x在或不在数组中的概率都为1/2，要查找的数据出现在0~n-1这n个位置的概率也是一样的，为1/n。 均摊时间复杂度 // array 表示一个长度为 n 的数组 // 代码中的 array.length 就等于 n int[] array = new int[n]; int count = 0; void insert(int val) { if (count == array.length) { int sum = 0; for (int i = 0; i &lt; array.length; ++i) { sum = sum + array[i]; } array[0] = sum; count = 1; } array[count] = val; ++count; } 假设数组的长度为n，根据数据插入的位置的不同，可以分为n种情况，每种情况的时间复杂度都是O(1)。此外还有一种额外的情况，就是在数组没有空间时间时插入一个数据，这时时间复杂度为O(n)。而且，这n+1种情况发生的概率一样，都是1/(n+1)。所以根据加权平均的计算方法，求得的平均时间复杂度就是：对于insert()函数来说，O(1)时间的插入和O(n)时间的插入出现的频率是非常有规律的，而且有一定的前后时序关系，一个O(n)插入之后紧跟着n-1个O(1)的插入操作，循环往复。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo及GitPage搭建博客]]></title>
    <url>%2F2019%2F03%2F20%2F%E4%BD%BF%E7%94%A8Hexo%E5%8F%8AGitPage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面刚开始使用GitHub，看到别人在git上搭建的博客很简洁优美，简直就是一片净土，于是自己也来试试！在搭建的过程中遇到了一些问题，再此做个记录。也算是自己的第一篇文章 :) 1.概述Git Pages本来是用于介绍托管在GitHub上的项目，不过，由于它的空间免费稳定，非常适合搭建一个博客。也可以认为是用户编写的、托管在GitHub上的静态网页。目前有两大静态博客主流框架：Jekyll和hexo。但是看到网上很多人吹捧hexo，于是直接放弃Jekyll，开始了hexo+GitHub搭建博客的第一步（在搭建的过程中，发现使用jekyll很简单，等会儿会提到我是如何偶遇它的）。hexo是一个快速、简洁且高效的博客框架，使用markdown解析文章，使用Node.js渲染界面( Hexo Themes上有很多主题以及各种功能，可参考博客我的个人博客之旅：从jekyll到hexo)。 2.搭建步骤2.1环境准备 安装Node.js,用来安装博客框架、渲染主题等。 安装Git，用来下载主题、提交、部署文章等。 2.2安装Hexo运行git bash，执行下面第一条命令安装hexo，第二条用于检查hexo安装的版本,第三条用于初始化hexo，hexo会自动下载一些文件到这个目录，包括node_modules。 $ npm install -g hexo-cli $ hexo -v $ hexo init 2.3建站及本地测试找一个合适的文件夹新建所需文件,第一条在指定文件夹创建所需文件(并初始化)，第三条安装所需组件.第四条开启服务器，访问localhost:4000(默认端口4000，ctrl+c关闭server)即可体验。 $ hexo init myBlog $ cd myBlog $ npm install $ hexo S 在hexo文件夹下执行命令： hexo generate 或者 hexo g //生成静态页面至public目录,public文件夹内的内容是要提交到GitHub上的 hexo server 或 hexo s //开启预览访问端口(开启本地服务) 2.4主题下载和配置使用命令下载主题，然后修改myBlog文件夹下的_config.yml(网站的配置文件，等会儿和github关联时也会修改改配置)。 $ cd themes $ git init $ git clone https://github.com/iissnan/hexo-theme-next.git 2.5将hexo和Git Pages关联起来2.5.1准备工作 注册GitHub账号https://github.com/，并设置Git的user name和email 配置ssh-key 代码库的设置：创建名为 “用户名.github.io” 的仓库，星号表示用户名，创建好之后访问https://zuiing.github.io 即可。插曲：以前我建立过一个git网页博客，但是今天配置hexo时不成功就删除又建了一个，但是域名变为https://zuiing.github.io/zuiing.github.io，如果访问https://zuiing.github.io 出现下面的错误：表示域名已经能够解析到，但是还需要配置，进入仓库zuiing.github.io-&gt;Setting;我的操作是Rename一下，又点了Git Pages中的”Choose a theme”(在这里偶遇了yekyll)，然后就点开了下图中的网页博客链接,就神奇的好了，而且还有了主题，惊喜！ 2.5.2正式开始部署，即设置deployment npm install hexo-deployer-git –save 在网站配置文件 _config.yml中有关deploy部分：修改仓库地址,需要特别注意的是冒号后面一定要有一个空格，以及这里使用的是ssh协议而不是http协议(刚开始我使用的http协议，执行hexo d之后一直关联不成功，估计和协议有关系)，前提是确保在Github上已经添加了公钥。 执行 hexo d 即可发布到Github仓库，其实我的过程远不像上面写的那么简单，在经历了千辛万苦之后总算成功了，这简直就是今天最开心的事儿了！还有，有网友建议每次都按下面的执行顺序来： hexo clean hexo generate hexo deploy 新增或修改主题之后请执行 hexo clean &amp;&amp; hexo d 清理缓存文件并部署。 2.6未知我知道现在才成功了一步，自己对git和hexo的了解还非常少，继续探索啦啦啦，做一个努力的小仙女儿！！！2019/03/20更 3.上传md文件图片无法显示的坑(下面是填坑过程)3.1问题介绍在sourse文件夹下建了一个img文件夹用于存储md插入图片，生成并上传到git之后，发现图片被存在了’用户名.github.io/img’文件夹下,如下图 打开博客网页却看不到图片，肯定是因为生成的index.html格式的文件图片路径不对，导致在GitHub上找不到图片,于是开始网上找解决方案，大部分说辞都差不多，例如hexo博客图片问题### 3.2开始动手1. 确认_config.yml中的post_asset_folder:true；Hexo提供了一种方便管理Asset的设定post_asset_folder，当设置为true后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，可以把该文章相关的所有资源都放到那个文件夹，这样便可以更方便的使用资源。2. 在Hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save3. 安装完成后用hexo创建文章时会发现_posts目录下面会多出一个和文章名字一样的文件夹，图片就放文件夹内即可。4. 接下来是测试图片的过程，图片插入格式如下图：5. hexo g生成之后先去本地public文件夹下看看index.yml中的路径，如下图：真是活见鬼，刚刚测试的时候在index.yml中第一张的路径是要比第二张的路径多一个testImg的(src=”/2019/03/20/testImg/testImg/test.JPG”),现在却都一样，而且在md文档中第二种写法没法直接预览图片，既然这样就是用第一种插入方法吧，anyway，图片插入的问题算是解决了。6. 在博客上查看结果如下： 4.上传md文件格式杂乱 md文档在本地格式正常，但上传到git上就很乱糟糟，如图： 很奇怪的是当我搞好图片显示问题之后，这个问题就自动好了，但我觉得二者之间没太大联系，可能是网页更新显示太慢的原因，如下图： 在用md写文档或插入代码的时候总出错，这里有篇还不错的博文，可以学习下markdown的语法 Markdown语法你都会了吗？,以及在markDown中输入数学公式。 在操作的过程中总是会遇到各种怪象，太菜啦，要被自己蠢哭了 :( 插入图片时，图片所在目录不要有中文，不然本地的markdown都找不到在哪 markdown文档名字与文档中title的名字最好一致，不然上传到gitpages之后文档中的格式会消失，这个问题搞了好几天才发现！！！2019/03/20更 5.hexo next主题配置我的博客配置参考了这篇文章，写的非常详细，效果也很美！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>hexo&amp;GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
