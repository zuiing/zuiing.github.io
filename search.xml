<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[区间覆盖问题]]></title>
    <url>%2F2019%2F09%2F01%2F%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[区间覆盖问题题目描述：小Q在游戏中需要守卫一条路线，范围是[0,L]，可认为是一维数轴，现在有n个守卫，每个守卫的守护范围是[xi,yi]，问小Q至少需要多少个守卫能守护这条路线。 输入： 5 80 20 72 44 66 9 输出：2 1.贪心求解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct Node&#123; int x, y;&#125;;bool cmp(Node a, Node b) &#123; return a.x &lt; b.x;//按照区间左界从小到大排列&#125;int main() &#123; int n, L; Node arr[100];; cin &gt;&gt; n &gt;&gt; L; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; arr[i].x &gt;&gt; arr[i].y; &#125; sort(arr, arr + n, cmp); //区间[0,L] if (arr[0].x &lt; 0) &#123; cout &lt;&lt; -1; return 0; &#125; int left = 0, right = 0, cnt = 1; for (int i = 0; i &lt; n; ++i) &#123; if (arr[i].x &lt;= left) &#123; if (arr[i].y &gt; right) &#123; right = arr[i].y; if (right &gt;= L) break; &#125; &#125; else &#123; //left = right; 如果这条语句放这里，则上述测试案例会得到错误答案 if (arr[i].x &lt;= right) &#123; if (arr[i].y &gt; right) &#123; left = right;//这条赋值语句应该在这儿 right = arr[i].y; cnt++; if (right &gt;= L) break; &#125; &#125; else &#123; cout &lt;&lt; -1; return 0; &#125; &#125; &#125; cout &lt;&lt; &quot;result:&quot;&lt;&lt;cnt; return 0;&#125; 另一种贪心求解，比上一种方法简单，但是须排序两次12345678910111213141516171819202122232425262728293031323334353637struct Node&#123; int x, y;&#125;;bool cmp(Node a, Node b) &#123; return a.x &lt; b.x;//按照区间左界从小到大排列&#125;bool cmpy(Node a, Node b) &#123; return a.y &gt; b.y;&#125;int main() &#123; int n, L; Node arr[100];; cin &gt;&gt; n &gt;&gt; L; //cout &lt;&lt; &quot;请输入区间\n&quot;; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; arr[i].x &gt;&gt; arr[i].y; &#125; //sort(arr, arr + n, cmpy); sort(arr, arr + n, cmp); //区间[0,L] if (arr[0].x &lt; 0) &#123; cout &lt;&lt; -1; return 0; &#125; int board=0, cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; if (arr[i].x &lt;= board &amp;&amp; arr[i].y &gt; board) &#123; board = arr[i].y; cnt++; if (board &gt;= L) break; &#125; &#125; cout &lt;&lt; &quot;result:&quot;&lt;&lt;cnt; return 0;&#125; 2.动态规划1234567891011121314151617181920212223int main()&#123; int n, L; Node arr[100];; cin &gt;&gt; n &gt;&gt; L; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; arr[i].x &gt;&gt; arr[i].y; &#125; vector&lt;int&gt; dp(L + 1, n + 1); dp[0] = 0; //区间[0,L] for (int i = 1; i &lt;= L; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (arr[j].x &lt; i&amp;&amp;arr[j].y &gt;= i) &#123; dp[i] = min(dp[arr[j].x] + 1, dp[i]); &#125; &#125; &#125; if(dp[L]=n+1) cout&lt;&lt;-1; else cout &lt;&lt; &quot;result:&quot;&lt;&lt;dp[L]; return 0;&#125;]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相关面试题]]></title>
    <url>%2F2019%2F06%2F04%2F%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[拼多多1、 一个C++源文件从文本到可执行文件经历的过程对于C/C++编写的程序，从源代码到可执行文件，一般经过下面四个步骤： 预处理，产生.ii文件 编译，产生汇编文件(.s文件) 汇编，产生目标文件(.o或.obj文件) 链接, 产生可执行文件(.out或.exe文件) 2、#include 的顺序以及尖括号和双引号的区别 #include的顺序的区别： 头文件的引用顺序对于程序的编译还是有一定影响的。如果要在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误，也就是常见的某行少个“；”符号。 #include尖括号和双引号的区别： ​ 1）#include &lt;&gt; ，认为该头文件是标准头文件。编译器将会在预定义的位置集查找该头文件，这些预定义的位置可以通过设置查找路径环境变量或者通过命令行选项来修改。使用的查找方式因编译器的不同而差别迥异。 ​ 2）#include “”，认为它是非系统头文件，非系统头文件的查找通常开始于源文件所在的路径。查找范围大于&lt;&gt;。 3、进程和线程，为什么要有线程 和进程相比，它是一种非常”节俭”的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种”昂贵”的多任务工作方式。（资源） 运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。（切换效率） 线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。（通信） 除以上优点外，多线程程序作为一种多任务、并发的工作方式，还有如下优点： 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。(CPU设计保证） 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。（代码易维护） 4、C++11有哪些新特性 关键字及新语法：auto、nullptr、for STL容器：std::array、std::forward_list、std::unordered_map、std::unordered_set 多线程：std::thread、std::atomic、std::condition_variable 智能指针内存管理：std::shared_ptr、std::weak_ptr 其他：std::function、std::bind和lamda表达式 6、malloc的原理，brk系统调用干什么的，mmap呢malloc的实现方案： malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。 调用 malloc函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。 调用 free 函数时，它将用户释放的内存块链接到空闲链表上。 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。 brk和mmap： 从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。 brk是将数据段(.data)的最高地址指针_edata往高地址推； mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。 这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。 7、C++的内存管理方式，STL的allocator，最新版本默认使用的分配器C++的内存管理方式： 在c++中内存主要分为5个存储区： 栈（Stack）：局部变量，函数参数等存储在该区，由编译器自动分配和释放。栈属于计算机系统的数据结构，进栈出栈有相应的计算机指令支持，而且分配专门的寄存器存储栈的地址，效率分高，内存空间是连续的，但栈的内存空间有限。 堆(Heap)：需要程序员手动分配和释放（new,delete），属于动态分配方式。内存空间几乎没有限制，内存空间不连续，因此会产生内存碎片。操作系统有一个记录空间内存的链表，当收到内存申请时遍历链表，找到第一个空间大于申请空间的堆节点，将该节点分配给程序，并将该节点从链表中删除。一般，系统会在该内存空间的首地址处记录本次分配的内存大小，用于delete释放该内存空间。 全局/静态存储区:全局变量，静态变量分配到该区，到程序结束时自动释放，包括DATA段（全局初始化区）与BSS段（全局未初始化段）。其中，初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BSS段。BSS段特点：在程序执行前BSS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0. 文字常量区：存放常量，而且不允许修改。程序结束后由系统释放。 程序代码区：存放程序的二进制代码 SGI 版本STL的默认配置器std::alloc 参见：《STL源码剖析》 考虑到小型区块所可能造成的内存碎片问题，SGI设计了双层配置器。第一级配置器直接使用malloc()和free()；第二级则视情况采取不同的策略：当配置区块超过128bytes时，视为“足够大”，便调用第一级配置器；当配置区块小于128bytes时，视之为“过小”，为了降低额外负担，便采用memory pool（内存池）整理方式，而不再求助于第一级配置器。 内存池的核心：内存池和16个自由链表（各自管理8,16，…，128bytes的小额区块）。在分配一个小区块时，首先在所属自由链表中寻找，如果找到，直接抽出分配；若所属自由链表为空，则请求内存池为所属自由链表分配空间；默认情况下，为该自由链表分配20个区块，若内存池剩余容量不足，则分配可分配的最大容量；若内存池连一个区块都无法分配，则调用chunk_alloc为内存池分配一大块区块；若内存不足，则尝试调用malloc分配，否则返回bad_alloc异常。 8、hash表的实现，包括STL中的哈希桶长度常数。hash表的实现主要涉及两个问题：散列函数和碰撞处理。 hash function （散列函数）。最常见的散列函数：f(x) = x % TableSize . 碰撞问题（不同元素的散列值相同）。解决碰撞问题的方法有许多种，包括线性探测、二次探测、开链等做法。SGL版本使用开链法，使用一个链表保存相同散列值的元素。 虽然开链法并不要求表格大小必须为质数，但SGI STL仍然以质数来设计表格大小，并且将28个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数。 9、hash表如何rehash，怎么处理其中保存的资源先想想为什么需要rehash: 因为，当loadFactor（负载因子）&lt;=1时，hash表查找的期望复杂度为O(1). 因此，每次往hash表中添加元素时，我们必须保证是在loadFactor &lt;1的情况下，才能够添加。 模仿C++的vector扩容方式，Hash表中每次发现loadFactor==1时，就开辟一个原来桶数组的两倍空间（称为新桶数组），然后把原来的桶数组中元素全部转移过来到新的桶数组中。注意这里转移是需要元素一个个重新哈希到新桶中的。 10、Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的为了避免rehash对服务器造成影响，服务器不是一次将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]. 以下是哈希表渐进式 rehash 的详细步骤： 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。 渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。 11、TCP的模型，状态转移TCP四层模型： 应用层 Telnet、FTP和e-mail等 传输层 TCP和UDP 网络层 IP、ICMP和IGMP 链路层 设备驱动程序及接口卡 状态转移： 熟悉三次握手 和 四次释放的TCP状态转移。 12、ubuntu开机的时候系统做了什么 加载BIOS BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”。硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序 读取MBR 计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。 Bootloader 在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。 Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。 Boot Loader有若干种，其中Grub、Lilo和spfdisk是常见的Loader。Linux环境中，目前最流行的启动管理器是Grub。 加载内核 内核的加载，内核加载后，接开始操作系统初始化，根据进程的优先级启动进程。 13、C++中struct和class的区别 默认的访问控制： 默认的继承访问权限：struct是public，class是private 12345678struct A&#123; char a;&#125;；struct B : A&#123; char b;&#125;； 这是B是public继承A的。 如果都将上面的struct改成class，那么B是private继承A的。这就是默认的继承访问权限。所以我们在平时写继承的时候，通常会这样写： class B : public A 当然，到底默认是public继承还是private继承，取决于子类而不是基类。 12struct A&#123;&#125;；class B : A&#123;&#125;; //private继承struct C : B&#123;&#125;； //public继承 struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。 初始化方面 1234567struct A //定义一个struct&#123; char c1; int n2; double db3;&#125;;A a=&#123;&apos;p&apos;, 7, 3.1415926&#125;; //定义时直接赋值 将上面的struct改成class，会报错！尝试向struct中加入一个构造函数或虚函数，struct也不能用{}赋值了！ 以{}的方式来赋初值，只是用一个初始化列表来对数据进行按顺序的初始化，如上面写成A a={‘p’,7};则c1，n2被初始化，而db3没有。这样的简单的copy操作，只能发生在简单的数据结构上，而不应该放在对象上。加入一个构造函数或虚函数会使struct更体现出一种对象的特性，而使{}不再有效。 14、如何防止C++头文件被重复引用可以使用ifndef或者program once，都可以。但是两者有一些区别。从兼容性上说，ifndfe更好，有些老的编译器可能不支持program once；此外，对于2个名字不同的头文件，但内容相同，ifndef还是可以鉴别出来，防止重复，program once 不行。 15、内联函数和宏的区别 内联函数的展开发生在编译期，而宏是在预处理阶段； 内联函数本身是函数，而宏不是； 最重要的一点：内联函数会对参数进行类型检查，而宏只是简单的替换，所以内联函数更加安全，所以往往宏需要对参数加括号，但是也不一定安全， 内联函数有自己明确的作用域或者访问权限，比如放在类里面的private，而宏是没有的。 内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接被镶嵌到目标代码中。 内联函数要做参数类型检查，这是内联函数跟宏相比的优势。 inline是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。对于短小的代码来说，inline可以带来一定的效率提升，而且和C时代的宏相比，inline更安全可靠。可是这个是以增加空间消耗为代价的。 inline一般只用于如下情况： 一个函数不断被重复调用； 函数只有简单的几行，且函数不包含for、while、switch语句。 16、Linux下常用命令（1）ls -al 显示当前目录下的所有文件目录信息，包括隐藏的（2）mkdir 创建文件夹（3）cat 查看文件内容（4）cp 拷贝（5）rm -rf 删除文件（夹）下所有文件（6）find 查找文件（7）grep 正则匹配（8）pwd 显示当前文件路径（9）ln 创建文件连接 -s 软连接（10）chmod 修改文件权限（11）netstat -a |grep 查看网络状态（12）top 腾讯相关面试题1、hash表使用开链，里面的链表过长说明了什么？答：hash函数设计的不好，导致冲突严重，进而导致同一个“桶”内的链表数目增多。 2、C++不能被继承的类 使用C++11新增的final关键字，使得声明的类是一个最终类，无法被继承 将构造函数放入到private里面，这样无法构造出子列对象 3、什么叫字长？答：计算机在同一时间能处理的一组二进制数成为计算机的一个字，这组二进制数的位数就是字长，所以现在计算机有16位、32位、64位等。 4、计算机的存储系统答：分为内存和外村，其中内存有主存、cache、寄存器等，外存分为磁盘、光盘等。 5、static关键字的作用、存放位置作用： static关键字有隔离隐藏的作用，比如多个cpp文件，如果将全局变量声明为static，那么该变量只对该文件可见； 变量声明为static，可以使得这个变量的生命期是整个程序结束； c++类中的static声明的变量和函数表示都是属于类的属性，而不是对象的成员。 存放位置： 未初始化的放在bss段，初始化的放在data段。 6、堆和栈的区别 从管理方式上栈是由编译器自动管理，无需我们手动控制；对于堆，开辟和释放工作由程序员控制，所以有内存泄漏等情况的发生。 从申请大小上栈是由高地址向低地址扩展的，是一块连续的内存区域，所以栈的栈顶地址或者大小是一开始就分配好的。在使用过程中，比如递归调用层数过多，那么就有可能造成栈溢出，所以栈能获得的空间比较少；堆是向高地址扩展的，是链表组织的方式，所以有可能是不连续的，他的大小只受限于有效的虚拟内存大小，所以堆能开辟的空间较大。 从碎片问题上栈是没有碎片的情况，因为它有严格的出栈入栈，不会存在一个内存块从栈的中间位置弹出；堆有碎片的情况，频繁的调用new/delete分配释放内存，必然会造成内存碎片。 从分配方式上 堆都是动态分配的，栈大多是静态分配的，也可以动态分配，可以由alloc函数分配。 从分配效率上计算机会在底层对栈提供支持，比如有专门的寄存器分配，用来存放栈的地址，压栈出栈的指令等；堆是由c/c++函数库提供的，机制比较复杂 7、malloc和new的区别答：最大的区别在于malloc只是简单的分配了内存空间，而new在分配了内存空间之后调用了对象的构造函数。 8、引用和指针的区别 引用是一个已有对象的别称，指针是一个地址，从非空性上说，引用不能为空，指针本身是个值，可以为空 在编码的时候，对引用不需要判断，但是对于指针，必须对其非空性进行判断 当指向的对象可能再发生变化的时候，往往用指针，而引用是一定固定的！ 9、多态的实现原理(非懂)答：C++多态主要是通过虚函数表实现的 C++多态的体现，主要是通过父类指针指向一个子类对象，此时调用的函数就是子类的函数，体现了多态性，因为在调用过程中，通过4个字节的虚表指针找到了虚函数表，此时由于实际对象是子类对象，那么其虚函数表是子类的虚函数表，对于同一个虚函数，子类的虚函数会覆盖掉符类的虚函数，构建出自己的虚函数表，所以此时通过虚表指针访问的虚函数就是子类的虚函数，这就是C++的多态的体现。 10、C++的内存模型答：内存分为5个段，从低地址到高地址，依次是代码段、数据段、bss段、堆、栈。 11、滑动窗口的作用答：主要就是为了实现流量控制，控制了发送包的速率，每次发送方只能发送滑动窗口内部的数据包，才能保证接收方不会因为发送过快造成流量淹没，数据包的堆是。它的大小是 拥塞窗口和通告窗口 二者的最小值。]]></content>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F2019%2F05%2F01%2FLeetCode%E5%88%B7%E9%A2%98%2F%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[原理1.基本原理0s表示一串0，1s表示一串1；1234x ^ 0s = x x &amp; 0s = 0 x | 0s = xx ^ 1s = ~x x &amp; 1s = x x | 1s = 1sx ^ x = 0 x &amp; x = x x | x = x 利用x ^ 1s = ~x 的特点，可以将位级表示翻转；利用x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数； 利用x &amp; 0s = 0 和x &amp; 1s = x 的特点，可以实现掩码操作；一个数num与mask：00111100 进行位与操作，只保留num中与mask的1部分相对应的位； 利用x | 0s = x 和x | 1s = 1s 的特点，可以实现设值操作；一个数num与mask：00111100 进行位或操作，将num中与mask中的1部分相对应的都设置为1。 位与运算技巧： n&amp;(n-1)去除n的位级表示中最低的那一位；例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000； n&amp;(-n)得到n的位级表示中最低的那一位；-n得到n的反码加1，对于二进制表示10110100，-n得到01001100，相与得到00000100； n-n&amp;(~n+1)去除n的位级表示中最高的那一位。 移位运算： n为算术右移，相当于除以2^n; n为无符号右移，左边会补0； &lt;&lt;n为算术左移，相当于乘以x^n. 1.mask计算要获得11111111，将0取反即可，~0； 要得到只有第i位为1的mask，将1左移i-1位即可，1&lt;&lt;(i-1);例如1&lt;&lt;4得到第5位为1的mask：00010000； 得到1到i位为1的mask，1&lt;&lt;i-1即可，例如将 1&lt;&lt;4-1 = 00010000-1 = 00001111； 得到1到i位为9的mask，只需将1到i位为1的mask取反，即~(1&lt;&lt;i-1). 例题汉明距离 461.Hamming Distance(Easy)解题思路：求两个数字之间的汉明距离，即其二进制数对应位不同的个数，那么最直接了当的做法就是按位分别取出两个数对应位上的数并异或；异或的性质就是相同的为0，不同的为1，只需要把1的数目累加起来就是汉明距离了。123456789101112class Solution &#123;public: int hammingDistance(int x, int y) &#123; int z=x^y,res=0; while(z)&#123; res++; z&amp;=(z-1); &#125; return res; &#125;&#125;; 单独的数字 136.Single Number(Easy)Input: [4,1,2,1,2]Output: 4 Note:Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 解题思路：两个相同的数字异或为0，根据这个特点，把数组中的所有数组异或起来，则没对相同的数字都会得0，然后最后剩下的数字就是那个只有一次的数字。 12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res=0; for(auto num:nums) res^=num; return res; &#125;&#125;; 单独的数字II 137.Single NumberII(Medium)Input: [2,2,3,2]Output: 3 解题思路：建立一个32位的数字，统计每一位上1出现的个数，如果某一位上为1的话，如果该整数出现了三次，对3取余为0，把每个数的对应位都加起来对3取余，最终剩下来的就是单独的数字。 1234567891011121314class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res=0; for(int i=0;i&lt;32;i++)&#123; int sum=0; for(auto num:nums) sum+=(num&gt;&gt;i)&amp;1; res|=(sum%3)&lt;&lt;i; &#125; return res; &#125;&#125;; 单独的数字III 260.Single Nummber(Medium)Input: [1,2,1,3,2,5]Output: [3,5] 解题思路：首先把原数组全部异或起来，会得到一个数字，这个数字是两个不相同的数字异或的结果，我们取出其中任意一位为’1’的位，为方便起见，用diff&amp;(-diff)取出最低位为’1’的位；接下来想啊，如果如果两个相同的数字异或，每一位都会是0，而不同的数字为1，一定会有对应位不同，一个0一个1，这样异或为1；例如3和5二进制为11和101，从低往高看，最开始产生不同的是第二位，那么我们用第二位来和数组中每个数字相与，根据结果的不同，一定可以把3和5分开，而其他数字由于是成对出现，所以区分开来也是成对的，最终异或为0，不会对3和5产生影响，分别将两个小组中的数字异或起来，就可以得到最终结果啦。1234567891011121314class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int diff=accumulate(nums.begin(),nums.end(),0,bit_xor&lt;int&gt;()); diff&amp;=(-diff); vector&lt;int&gt; res(2,0); for(auto num:nums)&#123; if(diff&amp;num) res[0]^=num; else res[1]^=num; &#125; return res; &#125;&#125;; 丢失的数字 268.Missing Number(Easy)Input: [3,0,1]Output: 2 题目描述：题目给我们n个数字，是0~n之间的数但是有一个数字去掉了，让寻找这个数，要求线性时间复杂度和常数级的空间复杂度； 解题思路：用等差数列求和公式求出0~n之间所有数字之和，然后遍历数组求出给定数字的累加和，然后做减法，差值就是丢失的数字。 1234567891011class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int sum=0,n=nums.size(); for(auto num:nums)&#123; sum+=num; &#125; return 0.5*n*(n+1)-sum; &#125;&#125;; 接替思路：使用Bit Manipulate来解，既然0~n之间少了一个数，那么将这个少了一个数的数字和0~n之间完整的数组异或一下，那么相同的数字都变为0了，剩下的就是少了的那个数字了。 1234567891011class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int res=0; for(int i=0;i&lt;nums.size();i++)&#123; res^=(i+1)^nums[i]; &#125; return res; &#125;&#125;; 翻转比特位 190.Reverse Bites(Easy)Input: 00000010100101000001111010011100Output: 00111001011110000010100101000000Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. 接替思路：只需要把要翻转的数从右往左一位位取出来，如果取出来的是1，将结果res左移一位加1，否则直接将res左移一位，然后将n右移一位即可。12345678910111213141516171819202122232425class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; int res=0; for(int i=0;i&lt;32;i++)&#123; if(n&amp;1) res=(res&lt;&lt;1)+1; else res&lt;&lt;=1; n&gt;&gt;=1; &#125; return res; &#125;&#125;;//简化代码class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; int res=0; for(int i=0;i&lt;32;i++)&#123; res=(res&lt;&lt;1)|(n&amp;1); n&gt;&gt;=1; &#125; return res; &#125;&#125;; 不用额外变量交换两个变量1234a=a^b;b=a^b;a=a^b; 判断2的次方数 231.Power of Two(Easy)接替思路：2的次方数都只有一个1，剩下的都是0，所以只要每次判断最低位是否为1，然后向右移位，最后统计1的个数即可判断是否为2的次方数；或者还有一个技巧，如果一个数是2的次方数，根据上面的分析，那么它的二进制位最高位为1，其他为0，那么如果减去1的话，则最高位会降一位，其余为0的位现在都变为1，把两数相与，就会得到0，利用这个性质，只需一行代码。 1234567class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return (n&gt;0)&amp;&amp;(!(n&amp;(n-1))); &#125;&#125;; 判断4的次方数 342.Power of Four(Easy)接替思路：判断一个数是否是4的次方数，最直接的方法就是不停地除以4，看最后结果是否为1；另一种方法就是先根据num&amp;(num-1)判断一个数是否为2的次方数，二进制表示下，只有最高位为1，那么由于是2的次方数，不一定是4的次方数，比如8，所以还需要加上其他的限定条件，仔细观察可以发现，4的次方数的最高位的1都是奇数位，只要与上一个数 (0x55555555) &lt;==&gt; 1010101010101010101010101010101,如果得到的数还是本身，则可以确定是4的次方数。 1234567891011121314151617class Solution &#123;public: bool isPowerOfFour(int num) &#123; while(num&amp;&amp;(num%4==0))&#123; num/=4; &#125; return num==1; &#125;&#125;;class Solution &#123;public: bool isPowerOfFour(int num) &#123; return (num&gt;0)&amp;&amp;!(num&amp;(num-1))&amp;&amp;(num&amp;0x55555555); &#125;&#125;; 有交替位的二进制数 693.Binary Number with Alternaing Bits(Easy)Input: 10Output: TrueExplanation:The binary representation of 10 is: 1010. Input: 11Output: FalseExplanation:The binary representation of 11 is: 1011. 解题思路：最直接的方法就是一位一位检查，用一个变量bit来记录上一个位置的值，初始化为-1，然后用与1的方法获取最低位的值，如果是1，那么当此时bit已经是1的话，则返回false，否则bit赋为1；同理，如果是0，那么当此时bit已经是0的化，返回false，否则bit赋为0，如果while循环退出，返回true。 123456789101112131415161718class Solution &#123;public: bool hasAlternatingBits(int n) &#123; int bit=-1; while(n)&#123; if(n&amp;1)&#123; if(bit==1) return false; bit=1; &#125;else&#123; if(bit==0) return false; bit=0; &#125; n&gt;&gt;=1; &#125; return true; &#125;&#125;; 解题思路：下面这种写法更加简洁，不需要哟管if条件来判断，而是通过异或1的方式将0和1互换，while循环的条件是最低位等于d，而d在0和1之间不停切换，n每次也往右平移一位，循环退出后，若n为0，则返回true，否则返回false。123456789101112class Solution &#123;public: bool hasAlternatingBits(int n) &#123; int d=n&amp;1; while((n&amp;1)==d)&#123; d^=1; n&gt;&gt;=1; &#125; return n==0; &#125;&#125;; 解题思路：巧妙解法，利用0和1交替的特性，进行错位相加，从而组成全1的二进制数，然后用一个检测全1的二进制数的技巧，即与上加1后的数，因为全1的二进制数加1就会进一位，并且除了最高为其余为全是0，跟原数相与后会变为0；比如n是10101，那么n&gt;&gt;1就是1010，二者相加就是11111，再加1就是100000，二者相‘与’就是0。 123456789 class Solution &#123; public: bool hasAlternatingBits(int n) &#123; int a=n+(n&gt;&gt;1); return ((a+1)&amp;a)==0; &#125; &#125;;runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type &apos;int&apos; 求一个数的补码 476.Number Complement(Easy)Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. 解题思路：这道题给我们一个数，求其补数；需要做的就是每个位翻转一下，但是翻转的起始位置是从最高位的1开始的，前面的0不能被翻转，所以我们要从高往低遍历，如果遇到第一个1后，flag的值赋为true，然后就可以进行翻转了，翻转的方法就是对应位异或一个1；123456789101112class Solution &#123;public: int findComplement(int num) &#123; bool flag=false; for(int i=31;i&gt;=0;i--)&#123; if(num&amp;(1&lt;&lt;i)) flag=true; if(flag) num^=(1&lt;&lt;i); &#125; return num; &#125;&#125;; 解题思路：由于位操作~可以直接取反，但是如果直接对num取反的话就是每一位都翻转了，而最高位之前的0是不能翻转的，所以我们只要用一个mask来标记最高位1前面的所有0的位置，然后对mask取反后，与上对num取反的结果即可。需注意mask要定义成无符号类型，不然右移之后会变负数。 123456789class Solution &#123;public: int findComplement(int num) &#123; unsigned int mask=UINT_MAX; while(mask&amp;num) mask &lt;&lt;= 1; return ~mask &amp; ~num; &#125;&#125;; 实现整数的加法 371.Sum of Two Intergers(Easy)Example 1: Input: a = 1, b = 2Output: 3 Example 2: Input: a = -2, b = 3Output: 1 解题思路：实现两数相加，不能使用加号或其他数学运算符号，只能采用Bit Manipulation；在做加法的时候，每位相加会有进位carry产生，然后在下一位计算时需要加上进位一起运算，那么就要分为两部分，不考虑进位和只考虑进位的情况，然后递归调用该算法，直到进位为0；由于LeetCode不能对负数进行左移，也就是说最高位符号位必须为0才能左移，那么就在a和b相与之后，再与上一个最高位为0其余全1的数0xfffffff，这样就强制把最高位清零，然后再进行左移。当然也可以直接迭代实现！ 123456789101112131415class Solution &#123;public: int getSum(int a, int b) &#123; return b==0?a:getSum((a^b),(a&amp;b)&lt;&lt;1); &#125;&#125;;runtime error: left shift of negative value -2147483648class Solution &#123;public: int getSum(int a, int b) &#123; return b==0?a:getSum((a^b),(a&amp;b&amp;0x7fffffff)&lt;&lt;1); &#125;&#125;; 字符串数组的最大乘积 318.Maximum Product of Word Lengths(Medium)Given [“abcw”, “baz”, “foo”, “bar”, “xtfn”, “abcdef”]Return 16The two words can be “abcw”, “xtfn”. 解题思路：该题目给我们一个单词数组，让求两个没有相同字母的单词的长度之积的最大值；最直接的方法就是每两个单词进行比较，如果没有相同字母，则计算其长度之积，然后每次更新结果就可以找到最大值，但是时间复杂度太大；另一种方法就是使用mask，题目中给的都是小写字母，可以使用一个int整数的后26位来对应26个字母，若为1，说明该对应位置的字母出现过，那么每个单词都可由一个int数字表示，两个单词没有共同字母的条件是这两个int数相与为0； 1234567891011121314151617class Solution &#123;public: int maxProduct(vector&lt;string&gt;&amp; words) &#123; int res=0; vector&lt;int&gt; mask(words.size(),0); for(int i=0;i&lt;words.size();i++)&#123; for(auto c:words[i]) mask[i]|= 1&lt;&lt;(c-&apos;a&apos;); for(int j=0;j&lt;i;j++)&#123; if(!(mask[j]&amp;mask[i])) res=max(res,int(words[i].size() * words[j].size())); &#125; &#125; return res; &#125;&#125;; 统计从0~n每个数的二进制表示中1的个数 338.Counting Bits(Medium)1234567891011121314151617181920210 0000 0-------------1 0001 1-------------2 0010 13 0011 2-------------4 0100 15 0101 26 0110 27 0111 3-------------8 1000 19 1001 210 1010 211 1011 312 1100 213 1101 314 1110 315 1111 4 解题思路：找规律，规律是，从1开始，遇到偶数时，其1的个数和该偶数除以2得到的数字的1的个数相同，遇到奇数时，其1的个数等于该奇数除以2得到的数字的1的个数再加1. 123456789101112class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res&#123;0&#125;; for(int i=1;i&lt;=num;i++)&#123; if(i%2==0) res.push_back(res[i/2]); else res.push_back(res[i/2]+1); &#125; return res; &#125;&#125;; 12345678910111213141516171819202122i bin &apos;1&apos; i&amp;(i-1)0 0000 0-----------------------1 0001 1 0000-----------------------2 0010 1 00003 0011 2 0010-----------------------4 0100 1 00005 0101 2 01006 0110 2 01007 0111 3 0110-----------------------8 1000 1 00009 1001 2 100010 1010 2 100011 1011 3 101012 1100 2 100013 1101 3 110014 1110 3 110015 1111 4 1110 解题思路：利用更加巧妙的方法，i&amp;(i-1)这个本来是用来判断一个数是否是的次方数的快捷方法，比如8，二进制位1000，那么8&amp;(8-1)，只要为0就是2的指数，通过上述规律发现0~15的数字和其对应的i&amp;(i-1)值可以发现，每个i值都是i&amp;(i-1)对应的值加1。 1234567891011class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res(num+1,0); for(int i=1;i&lt;=num;i++)&#123; res[i]=res[i&amp;(i-1)]+1; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F04%2F18%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[斐波那契数列爬楼梯70.Clibing Staris(Easy)解题思路：定义一个数组dp存储上楼梯的方法数，dp[i]表示走到第i个楼梯的方法数目。第i个楼梯可以从第i-1和第i-2个楼梯再走一步到达，走到第i个楼梯的方法数为走到第i-1和第i-2个楼梯的方法数之和. 状态转移方程：dp[i]=dp[i-1]+dp[i-2]1234567891011121314class Solution &#123;public: int climbStairs(int n) &#123; if(n&lt;=2) return n; int pre2=1,pre1=2; for(int i=2;i&lt;n;i++)&#123; int cur=pre1+pre2; pre2=pre1; pre1=cur; &#125; return pre1; &#125;&#125;; 打家劫舍 198.House Robber(Easy)解题思路：该题相当于在一个数组中取出一个或多个不相邻数，使其和最大。维护一个数组dp，其中dp[i]表示到i位置时不相邻数能形成的最大和，由于不能抢劫相邻用户，如果抢劫了第i-1个用户，那么就不能再抢劫第i个用户，状态转移方程dp[i]=max(dp[i-2]+nums[i],dp[i-1]),当然也可以直接使用两个辅助变量，如爬楼梯。1234567891011121314class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; else if(nums.size()==1) return nums[0]; vector&lt;int&gt; dp(nums.size(),0); dp[0]=nums[0];dp[1]=max(nums[0],nums[1]); for(int i=2;i&lt;nums.size();i++)&#123; dp[i]=max(dp[i-2]+nums[i],dp[i-1]); &#125; return dp.back(); &#125;&#125;; 打家劫舍 213.House Robber II(Medium)解题思路：和上一题不同的是，现在房子围成了一个圈，如果抢了第一家，就不能抢最后一家，因此第一家和最后一家只能抢其中的一家，或者都不抢。现在如果我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后返回较大值。123456789101112131415161718class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;=1) return nums.empty()?0:nums[0]; return max(rob(nums,0,nums.size()-1),rob(nums,1,nums.size())); &#125; int rob(vector&lt;int&gt;&amp; nums,int i,int j)&#123; if(j-i&lt;=1) return nums[i]; int pre2=nums[i],pre1=max(nums[i],nums[i+1]); for(int k=i+2;k&lt;j;k++)&#123; int cur=max(pre2+nums[k],pre1); pre2=pre1; pre1=cur; &#125; return pre1; &#125;&#125;; 信件错排(考虑三封信件之间的关系)题目描述：有N个信和信封，它们被打乱，求错误装信方式的数量。解题思路：定义一个数组dp存储错误方式数量，dp[i]表示前i个信和信奉的错误方式数量。假设第i个信装到第j个信封里面，第j个信装到第k个信封里面，根据i和k是否相等，有两种情况： i==k，交换i和k的信后，它们的信和信封在正确的位置，但是其余i-2封信有dp[i-2]中错误装信的方式。由于j有i-1种取值，因此共有(i-1)*dp[i-2]. i！=k，交换i和j的信后，第i个信和信封在正确的位置，其余i-1封信有dp[i-1]种错误装信方式。由于j有i-1种取值，因此共有(i-1)*dp[i-1]种错误装信方式。 综上，动态转移方程：dp[i]=max((i-1)dp[i-2],(i-1)dp[i-1]) 矩阵路径矩阵的最小路径和 64.Minimum Path Sum(Medium)解题思路：维护一个二维dp数组，其中dp[i][j]表示当前位置的最小路径和，递推公式dp[i][j]=grid[i][j]+min(dp[i-1][j],dp[i][j-1]) 12345678910111213141516class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m=grid.size(),n=grid[0].size(); int dp[m][n]=&#123;grid[0][0]&#125;; for(int i=1;i&lt;m;i++) dp[i][0]=grid[i][0]+dp[i-1][0]; for(int j=1;j&lt;n;j++) dp[0][j]=grid[0][j]+dp[0][j-1]; for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++)&#123; dp[i][j]=grid[i][j]+min(dp[i-1][j],dp[i][j-1]); &#125; &#125; return dp[m-1][n-1]; &#125;&#125;; 矩阵的总路径和 62.Unique Path(Medium)解题思路：求所有不同的路径的个数，和爬楼梯很类似，爬楼梯是每次只能爬一格或两格，这题是每次只能向下或向右走，求到达右下角的所有不同的走法。可以维护一个二维数组dp,dp[i][j]表示到当前位置不同的走法的个数，然后可以得到递推公式为：dp[i][j]=dp[i-1][j]+dp[i][j-1],为了节省空间，也可以使用一维数组。 123456789101112class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;int&gt; dp(n,1); for(int i=1;i&lt;m;i++)&#123; for(int j=1;j&lt;n;j++) dp[j]+=dp[j-1]; &#125; return dp[n-1]; &#125;&#125;; 数组区间区域和检索-不可变 303.Range Sum Query-Immutable(Easy)解题思路：检索一个数组的某个区间的所有数字之和，首先数组内容不会变化，其次有很多的区间和检索。用建立累计直方图的思想来建立一个累计和的数组dp，其中dp[i]表示[0,i]区间的数字之和，那么[i,j]就表示为dp[j]-dp[i-1],注意当i==0时，直接返回dp[j]. 123456789101112131415class NumArray &#123;public: NumArray(vector&lt;int&gt;&amp; nums) &#123; dp=nums; for(int i=1;i&lt;nums.size();i++) dp[i]+=dp[i-1]; &#125; int sumRange(int i, int j) &#123; return i==0?dp[j]:dp[j]-dp[i-1]; &#125;private: vector&lt;int&gt; dp; &#125;; 算术切片 413.Arithmetic Slices(Medium)题目分析：计算一种算数切片，其实就是找等差数列，限定了等差数列的长度至少是3，那么[1,2,3,4]含有3个长度至少为3的算术切片，那么[1,2,3,4,5]有：len=3:[1,2,3],[2,3,4],[3,4,5]len=4:[1,2,3,4],[2,3,4,5]len=5:[1,2,3,4,5]解题思路：可以归纳出规律，长度为n的等差数列有1个，长度为n-1的等差数列有2个,…,长度为3的等差数列有n-2个，那么总共就是1+2+3+…+n-2,利用求和公式得到长度为n的等差数列中含有长度至少为3的算术切片的个数为(n-1)(n-2)/2,那么题目就变成了找原数组中等差数列的长度，然后带入公式求和。1234567891011121314151617class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int res=0,len=2; for(int i=2;i&lt;A.size();i++)&#123; if(A[i]-A[i-1]==A[i-1]-A[i-2]) len++; else&#123; if(len&gt;2) res+=(len-1)*(len-2)/2; len=2; &#125; &#125; if(len&gt;2) res+=(len-1)*(len-2)/2; return res; &#125;&#125;; 解题思路：定义一个一维dp数组，其中dp[i]表示，到i位置为止的算数切片的个数，那么从第三个数字开始遍历，如果当前数字和之前连个数字构成算数切片，那么就更新dp[i-1]+1,然后res累加上dp[i]的值即可。123456789101112131415class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int res=0; vector&lt;int&gt; dp(A.size(),0); for(int i=2;i&lt;A.size();i++)&#123; if(A[i]-A[i-1]==A[i-1]-A[i-2])&#123; dp[i]=dp[i-1]+1; &#125; res+=dp[i]; &#125; return res; &#125;&#125;; 或者：直接用一个变量代替数组。123456789101112131415class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int res=0,cur=0; for(int i=2;i&lt;A.size();i++)&#123; if(A[i]-A[i-1]==A[i-1]-A[i-2]) cur++; else cur=0; res+=cur; &#125; return res; &#125;&#125;; 分割整数整数拆分343.Integer Break(Medium)题目分析：这道题给了我们一个正整数n，让我们拆分成至少两个正整数之和，使其乘积最大。解题思路：正整数从1开始，但是1不能拆分成两个正整数之和，所以不能当输出。 那么2只能拆成1+1，所以乘积也为1。数字3可以拆分成2+1或1+1+1，显然第一种拆分方法乘积大为2。数字4拆成2+2，乘积最大，为4。数字5拆成3+2，乘积最大，为6。数字6拆成3+3，乘积最大，为9。数字7拆为3+4，乘积最大，为12。数字8拆为3+3+2，乘积最大，为18。数字9拆为3+3+3，乘积最大，为27。数字10拆为3+3+4，乘积最大，为36。…. 通过观察上面的规律，可以看出从5开始，数字都需要先拆出所有的3，一直拆到剩下一个数为2或4，因为剩4就不用再拆了，拆成两个2和不拆一样。先预处理2和3，然后将结果res初始化为1，然后当n大于4时循环，结果自乘3，n自减3；跳出循环时n只能是2或4，再乘以res返回即可。12345678910111213class Solution &#123;public: int integerBreak(int n) &#123; if(n&lt;=3) return n-1; int res=1; while(n&gt;4)&#123; res*=3; n-=3; &#125; return res*n; &#125;&#125;; 解题思路：观察列出的10之前的数字的规律，可以发现数字7拆分结果是数字4的三倍，而7刚好比4大3，数字8拆分结果是数字5的三倍，而8比5大3，后面也是这样的规律，那么我们可以把数字6之前的拆分结果都列举粗来，然后之后的数通过查表都能计算出来。1234567891011class Solution &#123;public: int integerBreak(int n) &#123; vector&lt;int&gt; dp=&#123;0,0,1,2,4,6,9&#125;; for(int i=7;i&lt;=n;i++)&#123; dp.push_back(3*dp[i-3]); &#125; return dp[n]; &#125;&#125;; 检验完全平方数 367.Valid Perfect Square解题思路：给一个数，判断是否为完全平方数，肯定不能用暴力，最好是能以指数的速度来缩小范围。下面这种方法总超时1234567891011121314151617class Solution &#123;public: bool isPerfectSquare(int num) &#123; if(num==1) return true; long x=num/2,t=x*x; while(t&gt;num)&#123; x/=2; t=x*x; &#125; for(int i=x;i&lt;=2*x;i++)&#123; if(i*i==num) return true; &#125; return false; &#125;&#125;; 解题思路：数学解法，利用：完全平方数都是一系列奇数之和：1 = 14 = 1 + 39 = 1 + 3 + 516 = 1 + 3 + 5 + 725 = 1 + 3 + 5 + 7 + 936 = 1 + 3 + 5 + 7 + 9 + 11….1+3+…+(2n-1) = (2n-1 + 1)n/2 = n*n123456789101112class Solution &#123;public: bool isPerfectSquare(int num) &#123; int i=1; while(num&gt;0)&#123; num-=i; i+=2; &#125; return num==0; &#125;&#125;; 完全平方数 279.Perfect Squares(Medium)解题思路：该题给出一个正整数，求它最少能由几个完全平方数组成，考察四方和定理；根据四方和定理，任意一个正整数均可表示成4个正数的平方，即该题返回的结果只有1，2，3或4，首先将数字化简一下，由于一个数如果含有因数4，那么可以将4都去掉，并不影响结果，比如8和2，12和3；还有一个可以化简的就是，若一个数除8余7，那么肯定是由4个完全平方数组成；上面两步，一个很大的数可能变得很小，大大减小的运行时间，下面就尝试将其拆成两个平方数之和，若拆成功返回1或2，注意返回的是!!i+!!j.否则返回3.1234567891011121314class Solution &#123;public: int numSquares(int n) &#123; while(n%4==0) n/=4; if(n%8==7) return 4; for(int i=0;i*i&lt;=n;i++)&#123; int j=sqrt(n-i*i); if(i*i+j*j==n) return !!i+!!j; &#125; return 3; &#125;&#125;; 解题思路：用动态规划来做，建立一个长度为n+1的一维dp数组，将第一个值初始化为0，其余值都初始化为INT_MAX,i从0循环到n，j从i+jj&lt;=n的位置，然后每次更新dp[i+jj]的值，动态更新dp数组，其中dp[i]表示正整数i至少能由多少个完全平方数组成，最后返沪dp[n]即可。1234567891011121314class Solution &#123;public: int numSquares(int n) &#123; vector&lt;int&gt; dp(n+1,INT_MAX); dp[0]=0; for(int i=0;i&lt;=n;i++)&#123; for(int j=1;i+j*j&lt;=n;j++)&#123; dp[i+j*j]=min(dp[i+j*j],dp[i]+1); &#125; &#125; return dp[n]; &#125;&#125;; 解码方法91.Decode Ways(Medium)解题思路：这道题和爬楼梯问题很相似，但是还有一些其他的条件限制，比如第一位数不能为0，两位数不能大于26，其十位上的数也不能为0，除去这些条件，跟爬楼梯基本一样。建立一维dp数组，长度为数组长度+1，全部初始化为1，然后从第三个数开始更新，对应数组的第一个数，对每个数组首先判断其是否为0，若是则改为0，若不是，赋上一个dp值，此时相当于加上了dp[i-1]，然后看数组前一位是否存在，如果存在且满足前一位不是0，且和当前为一起组成的两位数不大于26，则当前dp值加上dp[i-1]，可以看出和斐波那契数列数组的递推式一样，12345678910111213141516171819202122232425262728293031class Solution &#123; public: int numDecodings(string s) &#123; if(s.empty()||(s.size()&gt;1&amp;&amp;s[0]==&apos;0&apos;)) return 0; vector&lt;int&gt; dp(s.size()+1,0); dp[0]=1; for(int i=1;i&lt;dp.size();i++)&#123; dp[i]=(s[i-1]==&apos;0&apos;)?0:dp[i-1]; if(i&gt;1&amp;&amp;(s[i-2]==&apos;1&apos;||(s[i-2]==&apos;2&apos;&amp;&amp;s[i-1]&lt;=&apos;6&apos;)))&#123; dp[i]+=dp[i-2]; &#125; &#125; return dp.back(); &#125; &#125;;``` ## 最长递增子序列已知一个序列 &#123;S1, S2,...,Sn&#125;，取出若干数组成新的序列 &#123;Si1, Si2,..., Sim&#125;，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 子序列 。如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个 递增子序列 。定义一个数组dp存储最长递增子序列的长度，dp[n]表示以Sn结尾的序列的最长子序列长度。对于一个递增子序列 &#123;Si1, Si2,...,Sim&#125;，如果im&lt;n,并且Sim&lt;Sn，此时&#123;Si1, Si2,..., Sim, Sn&#125; 为一个递增子序列，递增子序列的长度增加1.满足上述条件的自增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的序列上加上Sn就构成了以Sn结尾的最长递增子序列，因此dp[n]=max(dp[i]+1|Si&lt;Sn&amp;&amp;i&lt;n).因为在求dp[n]时可能无法找到一个满足条件的递增子序列，此时&#123;Sn&#125;就构成了递增子序列，需要对前面的芳曾进行修改，令dp[n]最小为1，即：dp[n]=max(1,dp[i]+1|Si&lt;Sn&amp;&amp;i&lt;n)对于一个长度为n的序列，最长递增子序列并不一定是以Sn为结尾，因此dp[n]不是序列的最长递增子序列的长度，需要遍历dp数组找出最大值才是所要的结果### 最长递增子序列 [300.Longest Increasing Subsequence(Medium)](https://leetcode.com/problems/longest-increasing-subsequence/description/)解题思路：动态规划的解法，时间复杂度为O(n^2),类似brute force的解法，维护一个一位dp数组，其中dp[i]表示以nums[i]结尾的最长递增字串的长度，对于每一个nums[i],我们从第一个数再搜索到i，如果发现某个数小于nums[i]，则更新dp[i],更新方法为max(dp[i],dp[j]+1),即比较当前dp[i]的值和那个小于nums[i]的数的dp值加1的大小，到最后dp啥机子中国最大的值就是要返回的LIS的长度。 class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(nums.size(),1); int res=0; for(int i=0;i&lt;nums.size();i++){ for(int j=0;j&lt;i;j++){ if(nums[i]&gt;nums[j]) dp[i]=max(dp[i],dp[j]+1); } res=max(res,dp[i]); } return res; } }; 12解题思路：优化时间复杂度为O(nlgn)，用到二分查找法。建立一个ends数组，把首元素放进去，然后比较之后的元素，如果遍历到的新元素比ends数组中的首元素小的话，替换首元素为次新元素，如果遍历到的新元素比ends数组的末尾元素还大，则将新元素添加到ends数组末尾；如果遍历到的新元素比ends数组首元素大、比尾元素小，则二分查找到第一个不小于次新元素的位置，覆盖掉该位置原来的数字，以此类推直到遍历完整个nums数组，此时ends数组的长度就是我们要求的LIS的长度。 class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return 0; vector&lt;int&gt; ends{nums[0]}; for(auto a:nums){ if(a&lt;ends[0]) ends[0]=a; else if(a&gt;ends.back()) ends.push_back(a); else{ int left=0,right=ends.size(); while(left&lt;right){ int mid=left+(right-left)/2; if(a&gt;ends[mid]) left=mid+1; else right=mid; } ends[right]=a; } } return ends.size(); } }; 1234### 链对的最大长度 [646.Maximum Length of Pair Chain(Medium)](https://leetcode.com/problems/maximum-length-of-pair-chain/description/)题目分析：题目给出一些链对，规定如果后面链对的首元素大于前链对的末元素，那么这两个链对就可以链起来，问最大能连多少个。 解题思路：由于规定链对的首元素一定小于尾元素，我们需要比较的是某个链表的首元素和另一个链表的尾元素之间的关系，如果整个链对数组是无序的，就很麻烦，因此需要对链对数组进行排序，按链对的尾元素进行排序，小的放前面，这样就可以利用贪心算法进行求解。用一个变量end来记录当前比较到的尾元素的值，初始化为最小值，然后遍历的时候，如果当前链对的首元素大于end，则res自增1，end更新为当前链对的尾元素： class Solution { public: int findLongestChain(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) { int res=0,end=INT_MIN; sort(pairs.begin(),pairs.end(),[](vector&lt;int&gt; &amp;a,vector&lt;int&gt; &amp;b){return a[1]&lt;b[1];}); for(auto pair:pairs){ if(pair[0]&gt;end){ res++; end=pair[1]; } } return res; } }; 12### 摆动子序列 [376.Wiggle Subsequence(Medium)](https://leetcode.com/problems/wiggle-subsequence/description/)解题思路：给了一个数组，求最长摆动子序列，可以用DP和Greedy来做，维护两个dp数组，其中p[i]表示到i位置时首差值为正的摆动子序列的最大长度，q[i]表示到i位置时首差值为负的摆动子序列的最大长度。从i=1开始遍历数组，然后对于每个遍历到的数字，再从开头位置遍历到这个数字，然后比较nums[i]和nums[j]，分别更新对应的位置： class Solution { public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) { if(nums.empty()) return 0; vector&lt;int&gt; p(nums.size(),1); vector&lt;int&gt; q(nums.size(),1); for(int i=1;i&lt;nums.size();i++){ for(int j=0;j&lt;i;j++){ if(nums[i]&gt;nums[j]) p[i]=max(p[i],q[j]+1); else if(nums[i]&lt;nums[j]) q[i]=max(q[i],p[j]+1); } } return max(p.back(),q.back()); } }; 12345678910111213141516## 最长公共子序列对于两个字序列S1和S2，找出它们最长的公共子序列。定义一个二维数组dp用来存储最长公共子序列的长度，其中dp[i][j]表示S1的前i个字符与S2的前j个字符最长公共子序列的长度。考虑S1i与S2i值是否相等，分为两种情况：- 当S1i==S2i时，那么就能在S1的前i-1个字符与S2的前j-1个字符最长公共子序列的基础上再加上S1i这个值，最长公共子序列长度加1，即dp[i][j]=dp[i-1][j-1]+1;- 当S1i！=S2i时，此时最长公共子序列为S1的前i-1个字符与前j个字符最长公共子序列或者S1的前i个字符与S2的前j-1个字符最长公共子序列，取它们的最大者，即dp[i][j]=max(dp[i][j-1],dp[i-1][j]).综上，最长公共子序列的状态转移方程可以得到。与最长递增子序列相比，最长公共子序列有以下不同点：- 针对的是两个序列，求它们的最长公共子序列；- 在最长递增子序列中dp[i]表示以S1为结尾的最长递增子序列，子序列必须包含Si；在最长公共子序列中，dp[i][j]表示S1中前i个字符与S2中前j个字符的最长公共子序列长度，不一定包含S1i和S2j；- 在求最终解时，最长公共子序列中dp[n][m]就是最终接，而最长递增子序列中dp[n]不是最终解，因为Sn为结尾的最长递增子序列不一定是真个序列最长递增子序列，需要遍历一遍dp数组找到最大者。 public int lengthOfLCS(int[] nums1, int[] nums2) { int n1 = nums1.length, n2 = nums2.length; int[][] dp = new int[n1 + 1][n2 + 1]; for (int i = 1; i &lt;= n1; i++) { for (int j = 1; j &lt;= n2; j++) { if (nums1[i - 1] == nums2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return dp[n1][n2]; } 1234567## 0-1背包 ### 硬币找零 [322.Coin Change(Medium)](https://leetcode.com/problems/coin-change/description/)解题思路：维护一个动态数组dp，其中dp[i]表示钱数为i时的最小硬币数的找零，数组初始化为amount+1，，dp[0]初始化为0；更新dp[i]的方法就是遍历每个硬币，如果遍历到的硬币值小于i时，用dp[i-coins[j]]+1来更新dp[i]，因此状态转移方程为dp[i]=min(dp[i],dp[i-coins[j]+1). class Solution { public: int coinChange(vector&lt;int&gt;&amp; coins, int amount) { vector&lt;int&gt; dp(amount+1,amount+1); dp[0]=0; for(int i=1;i&lt;=amount;i++){ for(int j=0;j&lt;coins.size();j++){ if(i&gt;=coins[j]) dp[i]=min(dp[i],dp[i-coins[j]]+1); } } return dp[amount]&gt;amount?-1:dp[amount]; } }; 12345### 硬币找零2 [518.Coin Change 2(Medium)](https://leetcode.com/problems/coin-change-2/description/)**题目分析：** 该题要求组成给定钱数共有多少种不同的方法。 **解题思路：** 使用DP来做，如果只有一个硬币，给定钱数的组成方式最多一种，就看此钱数能够整除该硬币值；当有两个硬币时，组成某个签署的方式就可能有多种，比如可能由每种硬币单独来组成，或者是两种硬币同时来组成。例如有两个硬币[1,2]，钱数为5，那么钱数是5的组成方法可以看作两部分组成，一种是由硬币1单独组成,(1,1,1,1,1);另一种是由1和2共同组成，说明我们的组成方法中至少需要由一个2，所以次数先取出一个硬币2，那么只要拼出钱数为3的总方法即可。 定义一个二维dp数组，其中dp[i][j]表示用前i个硬币组成钱数为j的不同组合方法；采用的方法就是一个硬币一个硬币的增加，每增加一个硬币，都从1~amount遍历，对于遍历到的当前钱数j，组成方法就是不加上当前硬币coins[i-1](硬币数组从0开始，因此要让i-1)的拼出方法dp[i-1][j],再加上去掉当前硬币值的钱数的组成方法，当然钱数j要大于等于当前硬币值，那么状态转移方程为dp[i][j]=dp[i-1][j]+(j&gt;=coins[i-1]?dp[i][j-doins[i-1]:0). class Solution { public: int change(int amount, vector&lt;int&gt;&amp; coins) { vector&lt;vector&lt;int&gt;&gt; dp(coins.size()+1,vector&lt;int&gt;(amount+1,0)); dp[0][0]=1; for(int i=1;i&lt;=coins.size();i++){ dp[i][0]=1; for(int j=1;j&lt;=amount;j++){ dp[i][j]=dp[i-1][j]+(j&gt;=coins[i-1]?dp[i][j-coins[i-1]]:0); } } return dp[coins.size()][amount]; } }; 123### 字符串按单词列表分割 [139.Word Break(Medium)](https://leetcode.com/problems/word-break/description/)解题思路：定义一个一维dp数组，其中dp[i]表示范围[0,i)内的子串是否可以拆分，注意这里dp的数组的长度要比s串的长度大1，因为要处理空串的情况，初始化dp[0]=true,然后开始遍历；这里需要两个for循环来遍历，因此必须遍历所有的子串，用j把[0,i)范围内的子串分成两部分，[0,j)和[j,i)，其中范围[0,j)就是dp[j]，范围[j,i)就是s.substr(j,i-j),其中dp[j]是之前的状态，已经计算出来了，可以直接取，只需要在字典中查找ssubstr(j,i-j)是否存在，如果二者均存在，将dp[i]赋为true，并且break，此时就不需要再用j去分[0,i)的范围了，因为[0,i)范围已经可以拆分了。最终返回dp数组的最后一个值，就是整个数组是否可以拆分的布尔值了！ class Solution { public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) { unordered_set&lt;string&gt; wordSet(wordDict.begin(),wordDict.end()); vector&lt;bool&gt; dp(s.size()+1); dp[0]=true; for(int i=1;i&lt;=s.size();i++){ for(int j=0;j&lt;i;j++){ if(dp[j]&amp;&amp;wordSet.count(s.substr(j,i-j))){ dp[i]=true; break; } } } return dp.back(); } }; 123### 补充：组合之和 [39.Combination Sum(Medium)](https://leetcode.com/problems/combination-sum/)解题思路：像这样结果要求返回所有符合要求解的题一般都是要用到递归，而且解题思路大同小异，相类似的题目还有Path Sum II,Subsets II,Permutations,permutations II,Combinations等，都是需要另写一个递归函数，这里新加入三个变量，start记录当前记录的递归到的下标，out为一个解，res保存所有已经得到的解，每次调用新的递归函数时，此时的target要减去当前数组的数： class Solution { public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; out; combinationSumDFS(candidates,target,0,out,res); return res; } void combinationSumDFS(vector&lt;int&gt;&amp; candidates,int target,int start,vector&lt;int&gt;&amp; out,vector&lt;vector&lt;int&gt;&gt;&amp; res){ if(target&lt;0) return; else if(target==0){res.push_back(out);return;} for(int i=start;i&lt;candidates.size();i++){ out.push_back(candidates[i]); combinationSumDFS(candidates,target-candidates[i],i,out,res); out.pop_back(); } } }; 12### 补充：组合之和II [40.Combination SumII(Medium)](https://leetcode.com/problems/combination-sum-ii/)解题思路：和上一题没本质区别，只需做一点改动，上面那道题给定数组中的数字可以重复使用，而这道题不能重复使用，只需要在递归的for循环里加上if(i&gt;start&amp;&amp;candidates[i]==candidates[i-1])continue;这样可以防止res中出现重复项，然后在递归调用中的参数改为i+1即可！ class Solution { public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; out; sort(candidates.begin(),candidates.end()); cmbinationSum2DFS(candidates,target,0,out,res); return res; } void cmbinationSum2DFS(vector&lt;int&gt;&amp; candidates, int target,int start,vector&lt;int&gt;&amp; out,vector&lt;vector&lt;int&gt;&gt;&amp; res){ if(target&lt;0) return; else if(target==0){res.push_back(out);return;} for(int i=start;i&lt;candidates.size();i++){ if(i&gt;start&amp;&amp;candidates[i]==candidates[i-1]) continue; out.push_back(candidates[i]); cmbinationSum2DFS(candidates,target-candidates[i],i+1,out,res); out.pop_back(); } } }; 12### 补充：组合项 [77.Combinations(Medium)](https://leetcode.com/problems/combinations/)解题思路：让求从1~n共n个数字里k个数的组合数的所有情况，还是要用DFS来解，建立一个保存所有结果的数组res以及保存每一个组合的小集合out，每次放一个数到out里，如果out里数个数到达k个，则把out保存到最终结果中，否则在下一层继续调用递归！ class Solution { public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; out; combineDFS(n,k,1,out,res); return res; } void combineDFS(int n,int k,int start,vector&lt;int&gt;&amp; out,vector&lt;vector&lt;int&gt;&gt;&amp; res){ if(out.size()==k) {res.push_back(out);return;} for(int i=start;i&lt;=n;i++){ out.push_back(i); combineDFS(n,k,i+1,out,res); out.pop_back(); } } }; 123456789### 补充：组合之和III [216.Combination Sum III(Medium)](https://leetcode.com/problems/combination-sum-iii/Input: k = 3, n = 9Output:[[1,2,6], [1,3,5], [2,3,4]]解题思路：这道题跟前两道组合之和最显著的区别在于该题的个数是固定的，为k；其实这道题和Combinations更相似些，但是那道题只是排序，对k个数字之和没有要求，所以这道题是它们的综合体，n是k个数字之和，如果n小于0，则直接返回，如果n正好等于0，而且此时out中数字的个数正好为k，说明此时为一个解，将其存入res中！ class Solution { public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; out; combinationSum3DFS(k,n,1,out,res); return res; } void combinationSum3DFS(int k,int n,int start,vector&lt;int&gt;&amp; out,vector&lt;vector&lt;int&gt;&gt;&amp; res){ if(n&lt;0)return; else if(n==0&amp;&amp;out.size()==k){res.push_back(out);return;} for(int i=start;i&lt;=9;i++){ out.push_back(i); combinationSum3DFS(k,n-i,i+1,out,res); out.pop_back(); } } }; 12345678910### 组合之和IV [377.Combination Sum IV(Medium)](https://leetcode.com/problems/combination-sum-iv/)Example:nums = [1, 2, 3] target = 4The possible combination ways are:(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1)解题思路：为什么我用递归来求结果不对呢？再想想吧~ class Solution { public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) { int res=0; combinationSum4DFS(nums,target,0,res); return res; } void combinationSum4DFS(vector&lt;int&gt;&amp; nums, int target,int start,int &amp;res){ if(target&lt;0) return; else if(target==0){res++;return;} for(int i=start;i&lt;nums.size();i++){ combinationSum4DFS(nums,target-nums[i],i,res); } } }; 12解题思路：动态规划求解，有点像爬梯子，定义一个一维dp数组，其中dp[i]表示目标数为i的解的个数，然后从1遍历到target，对于每一个数，遍历nums数组，如果i&gt;=nums[j],dp[i]+=dp[i-nums[j]];比如对于[1,2,3]4,当计算dp[3]时，2可以拆分为1+x，x即为dp[2],3也可以拆分为2+x，x即为dp[1]，3也可以拆分为3+x,x即为dp[0]，把所有的情况加起来就是组成3的所有情况了！ class Solution { public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; dp(target+1,0); dp[0]=1; for(int i=1;i&lt;=target;i++){ for(int j=0;j&lt;nums.size();j++){ if(i&gt;=nums[j]) dp[i]+=dp[i-nums[j]]; } } return dp[target]; } }; 我的天！DP也超时！！test:[3,33,333]10000 1解题思路：根据网上大佬的办法进行剪枝，如果target远大于nums数组的个数的话，先给nums数组排个序，然后从1遍历到target，对于i小于数组中的数字x时，直接break，因为后面的数更大 class Solution { public: int combinationSum4(vector&lt;int&gt;&amp; nums, int target) { vector&lt;int&gt; dp(target + 1); dp[0] = 1; sort(nums.begin(), nums.end()); for (int i = 1; i &lt;= target; ++i) { for (auto a : nums) { if (i &lt; a) break; dp[i] += dp[i - a]; } } return dp.back(); } }; 还是超时！！！ 123456789101112## 股票交易 ### 买股票的最佳时间含冷冻期 [309.Best Time to Buy and Sell Stock with Coolsown(Medium)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)掠过## 字符串编辑### 删除两个字符串的字符使它们相等 [583.Delete Operation for Two Strings(Medium)](https://leetcode.com/problems/delete-operation-for-two-strings/description/)Input: &quot;sea&quot;, &quot;eat&quot; Output: 2 Explanation: You need one step to make &quot;sea&quot; to &quot;ea&quot; and another step to make &quot;eat&quot; to &quot;ea&quot;. 问题分析：给了两个单词，问最少需要多少步可以让两个单词相等，每一步可以在任意一个单词中删掉一个字符；那么怎么才能让步数最少呢？如果知道两个单词最长的相同子序列的长度并乘以2，被两个单词的长度之和一减，就是最少步数了！ 解题思路：其实就是转换成球最长相同子序列的问题；定义一个二维dp数组，其中dp[i][j]表示word1的前i个字符和word2的前j个字符组成的两个单词的最长公共子序列的长度；如果当前的两个字符相等，那么dp[i][j]=dp[i-1][j-1]+1,因为最长相同子序列又多了一个相同的字符，所以长度加1，由于dp数组的大小定义是(n1+1)*(n2+1),所以比较的是word1[i-1]]和word2[j-1];如果当前的两个字符不相等，要错位相比，比如&quot;sea&quot;和&quot;eat&quot;，当比较第一个字符，发现&apos;s&apos;和&apos;e&apos;不相等，则比较sea中的s和eat的a，sea中的e和eat中的e相比，这样dp[i][j]就要去dp[i][j-1]和dp[i-1][j]中的较大值了，最后就求出了最大共同子序列的长度！ class Solution { public: int minDistance(string word1, string word2) { int n1=word1.size(),n2=word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n1+1,vector&lt;int&gt;(n2+1,0)); for(int i=1;i&lt;=n1;i++){ for(int j=1;j&lt;=n2;j++){ if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1]+1; else dp[i][j]=max(dp[i-1][j],dp[i][j-1]); } } return n1+n2-dp[n1][n2]*2; } }; 1解题思路：这道题和Edit Distance相同的思路，那道题是问一个单词通过多少步修改可以得到另一个单词(word1通过多少步修改可以得到word2)，其实word2删除一个字符，和跟在word1对应的地方加上那个要删除的字符，达到的效果是一样的，并不影响最终的步骤数；定义一个二维的dp数组，其中dp[i][j]表示word1的前i个字符和word2的前j个字符组成的两个字符，能使其便相同的最小的步数！ class Solution { public: int minDistance(string word1, string word2) { int n1=word1.size(),n2=word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(n1+1,vector&lt;int&gt;(n2+1,0)); for(int i=0;i&lt;=n1;i++) dp[i][0]=i; for(int j=0;j&lt;=n2;j++) dp[0][j]=j; for(int i=1;i&lt;=n1;i++){ for(int j=1;j&lt;=n2;j++){ if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=1+min(dp[i-1][j],dp[i][j-1]); } } return dp[n1][n2]; } }; 12345678910111213141516### 编辑距离 [72.Edit Distance(Hard)](https://leetcode.com/problems/edit-distance/escription/)Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot; Output: 3 Explanation: horse -&gt; rorse (replace &apos;h&apos; with &apos;r&apos;) rorse -&gt; rose (remove &apos;r&apos;) rose -&gt; ros (remove &apos;e&apos;) 解题思路：维护一个二维dp数组，其大小为m*n，m和n分别是word1和word2的长度，dp[i][j]表示从word1的前i个字符转换到word2的前j个字符所需要的步骤；那我们要先给这个二维数组dp的第一行第一列赋值，因为第一行和第一列对应的总有一个字符串是空串，于是转换步骤就是另一个字符串的长度；比如word1是“bbc&quot;，word2是”abcd“，那么我们可以得到dp数组如下： Ø a b c d Ø 0 1 2 3 4 b 1 1 1 2 3 b 2 2 1 2 3 c 3 3 2 1 2 通过观察可以发现，当word1[i]==word2[j]时，dp[i][j]=dp[i-1][j-1]，其他情况时，dp[i][j]是其左，左上，上的三个值中的最小值加1，其实这里的左，上和左上，分别对应增加、删除、修改操作，那么得到状态转移方程为： if word1[i - 1] == word2[j - 1] dp[i][j] =dp[i - 1][j - 1]; else min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1 class Solution { public: int minDistance(string word1, string word2) { int m=word1.size(),n=word2.size(); vector&lt;vector&lt;int&gt;&gt; dp(m+1,vector&lt;int&gt;(n+1,0)); for(int i=1;i&lt;=m;i++) dp[i][0]=i; for(int j=1;j&lt;=n;j++) dp[0][j]=j; for(int i=1;i&lt;=m;i++){ for(int j=1;j&lt;=n;j++){ if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1]; else dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1; } } return dp[m][n]; } }; 12345678910111213141516171819202122232425262728293031### 复制粘贴按键 [650.2 Keys Keyboard(Medium)](https://leetcode.com/problems/2-keys-keyboard/description/)Example 1:Input: 3 Output: 3 Explanation: Intitally, we have one character &apos;A&apos;. In step 1, we use Copy All operation. In step 2, we use Paste operation to get &apos;AA&apos;. In step 3, we use Paste operation to get &apos;AAA&apos;. Note: Copy All: You can copy all the characters present on the notepad (partial copy is not allowed). Paste: You can paste the characters which are copied last time.题目分析：给我们两个按键以及一个A，目标是利用这两个按键打印出n个A，注意复制的时候要全部复制，不能选择部分复制，然后复制和粘贴都算操作步骤，问打印出n个A需要多少步操作。 解题思路：从简单的例子开始分析，试图找规律 当n = 1时，已经有一个A了，我们不需要其他操作，返回0当n = 2时，我们需要复制一次，粘贴一次，返回2当n = 3时，我们需要复制一次，粘贴两次，返回3当n = 4时，这就有两种做法，一种是我们需要复制一次，粘贴三次，共4步，另一种是先复制一次，粘贴一次，得到AA，然后再复制一次，粘贴一次，得到AAAA，两种方法都是返回4当n = 5时，我们需要复制一次，粘贴四次，返回5当n = 6时，我们需要复制一次，粘贴两次，得到AAA，再复制一次，粘贴一次，得到AAAAAA，共5步，返回5通过分析发现，首先对于任意一个n(除1外)，最差的情况就是用n步，不会再对于n步；小于n的情况，如n=6时，只用了5步，发现是先拼成了AAA，再复制粘贴成AAAAAA，其实还可以先拼出AA，再复制一次粘贴两次，得到的还是5；分析到这，解题思路已经比较清晰了，需要找出n的所有因子，然后这个因子可以当作模块的个数，再计算出模块的长度n/i，调用递归，加上模块的个数i来更新结果即可！ class Solution { public: int minSteps(int n) { if(n==1) return 0; int res=n; for(int i=n-1;i&gt;1;i--){ if(n%i==0){ res=min(res,minSteps(n/i)+i); } } return res; } }; `]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索]]></title>
    <url>%2F2019%2F04%2F15%2FLeetCode%E5%88%B7%E9%A2%98%2F%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[BacktrackingBacktracking(回溯)属于DFS。 普通DFS主要用在可达性问题，这种问题只需要执行到特定的位置然后返回即可。 而Backtracking主要用于求解排列组合问题，例如有{‘a’,’b’,’c’}三个字符，求解所有由这三个字符排列得到的字符串，这种问题在执行到特性的位置返回之后还会继续执行求解过程。 因为Backtracking不是理解就返回，而要继续求解，因此在程序实现时，需要注意对元素的标记问题： 在访问一个新元素进入新的递归调用时，需要将新元素标记为已经访问，这样才能在继续递归调用时不用重复访问该元素； 但是在递归返回时，需要将元素标记为未访问，因为只需要保证在一个递归链中不同时访问一个元素，可以访问已经访问过但是不在当前递归链中的元素。 数字键盘组合 17.Letter Comninatations of a Phone Number(Medium)123456789101112131415161718192021class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; if(digits.size()==0) return vector&lt;string&gt;&#123;&#125;; vector&lt;string&gt; res; string out=&quot;&quot;; string dict[]=&#123;&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;; letterCombinatoinsDFS(digits,0,out,res,dict); return res; &#125; void letterCombinatoinsDFS(string &amp;digits,int level,string out,vector&lt;string&gt;&amp; res,string dict[])&#123; if(level==digits.size())&#123; res.push_back(out);return; &#125; string str=dict[digits[level]-&apos;1&apos;]; for(int i=0;i&lt;str.size();i++)&#123; letterCombinatoinsDFS(digits,level+1,out+string(1,str[i]),res,dict); &#125; &#125;&#125;; IP地址划分93.Restore IP Addresses(Medium)Input: “25525511135”Output: [“255.255.11.135”, “255.255.111.35”] 问题描述：IP地址由32位二进制数组成，为便于使用，常以xxx.xxx.xxx.xxx形式表现，每组xxx代表小于或等于255的十进制数。所以IP地址总共有四段，每一段可能有一位、两位或三位，范围是[0,255]，题目明确指出输入字符串只含有数字，所以当某段是三位时，需要判断是否越界，还有一点很重要，当只有一位时，0可以组成某一段，如果有两位或三位时，像00，01，001，000都是不合法的，所以 还要一个判断函数来判定某个字符串是否合法。解题思路：这道题可以看作是字符串的分段问题，在输入字符串中加入三个点，将字符串分为四段，每一段必须合法，求所有的情况。只要遇到字符串的子序列或配准问题首先考虑动态规划DP，只要遇到需要求出所有情况首先考虑用递归 。这道题并非是求字符串的子序列或配准问题，更符合后者，所以使用递归来解。用k来表示当前还需要分的段数，如果k==0，则表示三个点已经加入完成，若这时字符串刚好为空，则将当前分好的结果保存。若k！=0，则对于每一段，分别用一位、两位、三位来尝试，分别判断其合不合法，如果合法，则调用递归继续分剩下的字符串，最终求出所有合法组合。 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; res; restoreIP(s,4,&quot;&quot;,res); return res; &#125; void restoreIP(string s,int k,string out,vector&lt;string&gt;&amp; res)&#123; if(k==0)&#123; if(s.empty()) res.push_back(out); &#125;else&#123; for(int i=1;i&lt;=3;i++)&#123; if(s.size()&gt;=i&amp;&amp;isValid(s.substr(0,i)))&#123; if(k==1) restoreIP(s.substr(i),k-1,out+s.substr(0,i),res); else restoreIP(s.substr(i),k-1,out+s.substr(0,i)+&quot;.&quot;,res); &#125; &#125; &#125; &#125; bool isValid(string str)&#123; if(str.empty()||str.size()&gt;3||(str.size()&gt;1&amp;&amp;str[0]==&apos;0&apos;)) return false; int res=stoi(str); return res&lt;=255&amp;&amp;res&gt;=0; &#125;&#125;; 二叉树路径 257.Binary Tree Paths(Easy)解题思路：返回所有根节点到叶子节点的路径。不停地DFS到叶节点，然后再回溯回去。在递归函数中，当遇到叶节点后加入res中，然后回溯。 12345678910111213141516class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; if(!root) return vector&lt;string&gt; &#123;&#125;; vector&lt;string&gt; res; helper(root,&quot;&quot;,res); return res; &#125; void helper(TreeNode* root,string out,vector&lt;string&gt;&amp; res)&#123; if(!root-&gt;left&amp;&amp;!root-&gt;right) res.push_back(out+to_string(root-&gt;val)); if(root-&gt;left) helper(root-&gt;left,out+to_string(root-&gt;val)+&quot;-&gt;&quot;,res); if(root-&gt;right) helper(root-&gt;right,out+to_string(root-&gt;val)+&quot;-&gt;&quot;,res); &#125;&#125;; 全排列 46.Permutations(Medium)1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; permuteDFS(nums,0,res); return res; &#125; void permuteDFS(vector&lt;int&gt;&amp;nums,int start,vector&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(start==nums.size()) &#123;res.push_back(nums);return;&#125; for(int i=start;i&lt;nums.size();i++)&#123; swap(nums[start],nums[i]); permuteDFS(nums,start+1,res); swap(nums[start],nums[i]); &#125; &#125;&#125;; 全排列II 47.Permutations II(Medium)解题思路：利用set存储结果，并且在递归函数中，先判断i和start不相同，但是nums[i]和nums[start]相同的情况下跳过，进行剪枝，继续下一个循环. 1234567891011121314151617public: vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; set&lt;vector&lt;int&gt;&gt; res; permuteDFS(nums,0,res); return vector&lt;vector&lt;int&gt;&gt;&#123;res.begin(),res.end()&#125;; &#125; void permuteDFS(vector&lt;int&gt;&amp; nums,int start,set&lt;vector&lt;int&gt;&gt;&amp; res)&#123; if(start&gt;=nums.size())&#123;res.insert(nums);return;&#125; for(int i=start;i&lt;nums.size();i++)&#123; if(i!=start&amp;&amp;nums[i]==nums[start]) continue; swap(nums[i],nums[start]); permuteDFS(nums,start+1,res); swap(nums[i],nums[start]); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
        <tag>回溯</tag>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学]]></title>
    <url>%2F2019%2F04%2F07%2FLeetCode%E5%88%B7%E9%A2%98%2F%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[质数的个数 204.Count Primes(Easy)解题思路：需要一个长度为n-1的bool类型的数组来记录每个数字是否被标记过，初始化为true；从2开始遍历到n-1，先找到第一个质数2，然后将其所有的倍数全部标记出来，然后到下一个质数，标记其所有质数，以此类推。 12345678910111213141516class Solution &#123;public: int countPrimes(int n) &#123; int res=0; vector&lt;bool&gt; prime(n,true); for(int i=2;i&lt;n;i++)&#123; if(prime[i])&#123; res++; for(int j=i*2;j&lt;n;j+=i) prime[j]=false; &#125; &#125; return res; &#125;&#125;; 七进制 504.Base 7(Easy)1234567891011121314class Solution &#123;public: string convertToBase7(int num) &#123; if(num==0) return &quot;0&quot;; string res=&quot;&quot;; bool positive=num&gt;0; while(num)&#123; res=to_string(abs(num%7))+res; num/=7; &#125; return positive?res:&quot;-&quot;+res; &#125;&#125;; 16进制 405.Convert a Number to Hexadecimal(Easy)1234567891011121314class Solution &#123;public: string toHex(int num) &#123; string res=&quot;&quot;; for(int i=0;num&amp;&amp;i&lt;8;i++)&#123; int t=num&amp;0xf; if(t&gt;=10) res=char(&apos;a&apos;+t-10)+res; else res=char(&apos;0&apos;+t)+res; num&gt;&gt;=4; &#125; return (res.empty())?&quot;0&quot;:res; &#125;&#125;; 求excel列表名称 168.Excel Sheet Column Title(Easy)123456789101112class Solution &#123;public: string convertToTitle(int n) &#123; string res=&quot;&quot;; while(n)&#123; res+=--n%26+&apos;A&apos;; n/=26; &#125; return string(res.rbegin(),res.rend()); &#125;&#125;; 求阶乘末尾0的个数 172.Factorial Trailing Zeroes(Easy)解题思路：求一个数的阶乘末尾0的个数，即找乘数中10的个数，而10=2*5，其中2的数量又远大于5的数量，那么该题即为找出5的个数；需要注意的是，像25、125这样的数字不知含有一个额5. 123456789101112class Solution &#123;public: int trailingZeroes(int n) &#123; int res=0; while(n)&#123; res+=n/5; n/=5; &#125; return res; &#125;&#125;; 二进制加法 67.Add Binary(Easy)解题思路：用两个指针m和n分别指向两个字符串的末尾，然后每次取出一个字符，转换为数字，若无法取出字符则按0处理，进位carry初始化为0，将三者加起来，对2取余即为当前位的数字，对2取商即为当前进位的值。 12345678910111213141516class Solution &#123;public: string addBinary(string a, string b) &#123; string res=&quot;&quot;; int m=a.size()-1,n=b.size()-1,carry=0; while(carry||m&gt;=0||n&gt;=0)&#123; int p=m&gt;=0?a[m--]-&apos;0&apos;:0; int q=n&gt;=0?b[n--]-&apos;0&apos;:0; int sum=p+q+carry; res=to_string(sum%2)+res; carry=sum/2; &#125; return res; &#125;&#125;; 字符串加法 415.Add Strings(Easy)12345678910111213141516class Solution &#123;public: string addStrings(string num1, string num2) &#123; string res=&quot;&quot;; int m=num1.size()-1,n=num2.size()-1,carry=0; while(carry||m&gt;=0||n&gt;=0)&#123; int a=m&gt;=0?num1[m--]-&apos;0&apos;:0; int b=n&gt;=0?num2[n--]-&apos;0&apos;:0; int sum=a+b+carry; res=to_string(sum%10)+res; carry=sum/10; &#125; return res.empty()?&quot;0&quot;:res; &#125;&#125;; 最少移动次数使数组元素相等 453.Minimum Moves to Equal Array Elements(Easy)Input:[1,2,3] Output:3 Explanation:Only three moves are needed (remember each move increments two elements): [1,2,3] =&gt; [2,3,3] =&gt; [3,4,3] =&gt; [4,4,4] 题目描述：题目给我们一个长度为n的数组，每次可以对n-1个数字同时加1，问最少需要多少次这样的操作才能让数组中所有的数字相等。 解题思路：为了快速缩小差距，应该选择除了数组最大值的所有数字加1，这样能快速到达平衡状态。但是如果每次都找出最大值，然后给其他的数字加1，效果等同于让最大值减1，比如[1,2,3]，将除去最大值的其他数字加1，变为[2,3,3]，全体减1，并不影响数自减相对差异，变为[1,2,2],这个结果其实就是原始数组的最大值3自减为1，傲梦问题就转化为了：将所有数字都减小到最小值，这样难度就大大降低了，只需要先找到最小值，然后累加每个数跟最小值之间的差值即(给除了最大值外的每个数自增1，相当于给某个数自减1)。 12345678910class Solution &#123;public: int minMoves(vector&lt;int&gt;&amp; nums) &#123; int res=0,mn=INT_MAX; for(int i=0;i&lt;nums.size();i++) mn=min(mn,nums[i]); for(int i=0;i&lt;nums.size();i++) res+=abs(nums[i]-mn); return res; &#125;&#125;; 解题思路：也可以求出数组的数字之和sum，然后减去最小值与数组长度的乘积。 123456789101112class Solution &#123;public: int minMoves(vector&lt;int&gt;&amp; nums) &#123; int mn=INT_MAX,sum=0; for(int i=0;i&lt;nums.size();i++)&#123; mn=min(mn,nums[i]); sum+=nums[i]; &#125; return sum-mn*nums.size(); &#125;&#125;; bug：先求和的话，会越界哦！如测试数据[1,2147483647] 最少移动次数使数组元素相等II [453.Minimum Moves to Equal Array Elements]Input:[1,2,3] Output:2 Explanation:Only two moves are needed (remember each move increments or decrements one element): [1,2,3] =&gt; [2,2,3] =&gt; [2,2,2] 题目描述：可以每次对任意一个数字加1或减1操作，用最少的次数让数组所有制相等。 解题思路：这题用到Best Meeting Point那道题的思想。首先给数组排序，那么我们最终需要变成的相等的数字就是中间的数，如果数组有奇数个，那么就是最中间的那个那个数字，如果是有偶数个，那么就是中间两个数的区间中的任意一个数字。而两端的数字变成中间的一个数字需要的步数其实就是两端数字的距离。 123456789101112class Solution &#123;public: int minMoves2(vector&lt;int&gt;&amp; nums) &#123; int res=0,i=0,j=nums.size()-1; sort(nums.begin(),nums.end()); while(i&lt;j)&#123; res+=nums[j--]-nums[i++]; &#125; return res; &#125;&#125;; 或者：123456789101112class Solution &#123;public: int minMoves2(vector&lt;int&gt;&amp; nums) &#123; int res=0,mid=nums.size()/2; sort(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size();i++)&#123; res+=abs(nums[i]-nums[mid]); &#125; return res; &#125;&#125;; 又或者：不需全部排序，用STL自带的nth_element求第n大值，并把它放在第n位置上。123456789101112class Solution &#123;public: int minMoves2(vector&lt;int&gt;&amp; nums) &#123; int res=0,mid=nums.size()/2; nth_element(nums.begin(),nums.begin()+mid,nums.end()); for(int i=0;i&lt;nums.size();i++)&#123; res+=abs(nums[i]-nums[mid]); &#125; return res; &#125;&#125;; 补充：最佳开会地点 [296.Best Meeting Point(Hard)]1234567891011121314A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.For example, given three people living at (0,0), (0,4), and (2,2):1 - 0 - 0 - 0 - 1| | | | |0 - 0 - 0 - 0 - 0| | | | |0 - 0 - 1 - 0 - 0The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6.Hint:Try to solve it in one dimension first. How can this solution apply to the two dimension case? 解题思路：求最佳的开会地点，该地点需要到每个为1的点的曼哈顿距离之和最小，题目中给的提示是让我们先从一维的情况来分析，先看一维时有两个点A和B的情况，1234可以发现，只要开会位置P在[A,B]区间内，不管在哪，距离之和都是A和B之间的距离，如果P不在[A,B]之间，那么距离之和就会大于A和B之间的距离,再加上两个点C、D： ```___C___A___P___B___D___``` 通过分析可以得出，P点的最佳位置就在[A,B]区间内，这样和四个点的距离之和就是AB距离加上CD距离。 因此只要给位置排好序，然后用最后一个坐标减去第一个坐标，倒数第二个坐标减去第二个坐标，直到中间为止,下面就直接贴大佬的代码好了。 class Solution { public: int minTotalDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;int&gt; rows, cols; for (int i = 0; i &lt; grid.size(); ++i) { for (int j = 0; j &lt; grid[i].size(); ++j) { if (grid[i][j] == 1) { rows.push_back(i); cols.push_back(j); } } } return minTotalDistance(rows) + minTotalDistance(cols); } int minTotalDistance(vector&lt;int&gt; v) { int res = 0; sort(v.begin(), v.end()); int i = 0, j = v.size() - 1; while (i &lt; j) res += v[j--] - v[i++]; return res; } }; 12345# 多数投票问题## 求众数 [169.Majority Element(Easy)](https://leetcode.com/problems/majority-element/description/)解题思路：摩尔投票法Moore Voting；先将第一个数假设为过半数，然后把计数器加1，比较下一个数和次数是否相等，若相等则计数器加1，反之则减1.然后看此时计数器的值，若为0，则将下一个值设为候选过半数。 class Solution { public: int majorityElement(vector&lt;int&gt;&amp; nums) { int res=0,cnt=0; for(int num:nums){ if(cnt==0){res=num;cnt++;} else{ num==res?cnt++:cnt--; } } return res; } }; 12或者： class Solution { public: int majorityElement(vector&lt;int&gt;&amp; nums) { int res=0,n=nums.size(); for(int i=0;i&lt;32;i++){ int ones=0,zeros=0; for(int num:nums){ if(ones&gt;n/2||zeros&gt;n/2) break; if((num&amp;(1&lt;&lt;i))!=0) ones++; else zeros++; } if(ones&gt;zeros) res|=(1&lt;&lt;i); } return res; } }; 1234## 检验完全平方数 [367.Valid Perfect Square(Easy)](https://leetcode.com/problems/valid-perfect-square/description/)解题思路：二分法，要查找的数为mid*mid. class Solution { public: bool isPerfectSquare(int num) { int l=0,r=num; while(l&lt;=r){ int mid=l+(r-l)/2,t=mid*mid;//求t时容易越界 if(t==num) return true; else if(t&lt;num) l=mid+1; else r=mid-1; } return false; } }; 1或者： class Solution { public: bool isPerfectSquare(int num) { for(int i=1;i&lt;=(int)sqrt(num);i++){ if(i*i==num) return true; } return false; } }; 12345678910又或者：找数学规律求解，完全平方数就是一系列奇数之和： 1 = 1 4 = 1 + 3 9 = 1 + 3 + 5 16 = 1 + 3 + 5 + 7 25 = 1 + 3 + 5 + 7 + 9 36 = 1 + 3 + 5 + 7 + 9 + 11 .... 1+3+...+(2n-1) = (2n-1 + 1)n/2 = n*n class Solution { public: bool isPerfectSquare(int num) { int i=1; while(num&gt;0){ num-=i; i+=2; } return num==0; } }; 1234## 判断3的次方数 [326.Power of Three(Easy)](https://leetcode.com/problems/power-of-three/description/)解题思路：将n不停的除3，看最后的迭代商是否为1，需考虑输入的是负数和0的情况。 class Solution { public: bool isPowerOfThree(int n) { while(n&amp;&amp;n%3==0){ n/=3; } return n==1; } }; 12或者：由于输入的是int，整数范围是0~2^31，在该范围内允许的最大的3的次方数是3^19=1162261467,那么只要看这个数能够被n整数即可。 class Solution { public: bool isPowerOfThree(int n) { return n&gt;0&amp;&amp;(1162261467%n==0); } }; 123456## 出本身外的数组之积 [238.Product of Array Except Self(Medium)](https://leetcode.com/problems/product-of-array-except-self/description/)题目描述：给定一个数组，让我们返回一个新数组，对于每一个位置上的数是其他位置上数的乘积，并且限制了时间复杂度O(n)，并且不能用除法。接替思路：对于一个数字，如果知道其前面所有数字的乘积，同时也知道后面所有的数乘积，那么二者相乘就是我们要的结果；因此需要分别创建出这两个数组，分贝从数组的两个方向遍历就可以分别创建出乘积累积数组。 class Solution { public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int n=nums.size(); vector&lt;int&gt; fwd(n,1),bwd(n,1),res(n); for(int i=0;i&lt;n-1;i++){ fwd[i+1]=fwd[i]*nums[i]; } for(int i=n-1;i&gt;0;i--) bwd[i-1]=bwd[i]*nums[i]; for(int i=0;i&lt;n;i++) res[i]=fwd[i]*bwd[i]; return res; } }; 12或者：不需要使用单独的数组，直接将乘积累积存入res中，先从前往后遍历，再从后往前遍历，需要用到一个临时变量right，初始化为1。 class Solution { public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { int n=nums.size(); vector&lt;int&gt; res(n,1); for(int i=1;i&lt;n;i++) res[i]=res[i-1]*nums[i-1]; int right=1; for(int i=n-1;i&gt;=0;i--){ res[i]*=right; right*=nums[i]; } return res; } }; 123456## 三个数字的最大乘积 [628.Maximum Produc of Three Numbes(Easy)](https://leetcode.com/problems/maximum-product-of-three-numbers/description/)Input: [1,2,3,4] Output: 24解题思路：若全是正数，则排序后末尾三个数相乘即可；若全是负数，同样排序后末尾三个数相乘就是结果；若存在负数和整数，那么最好的情况肯定是两个最小的负数和一个最大的正数相乘，就可以得到最大的乘积。 class Solution { public: int maximumProduct(vector&lt;int&gt;&amp; nums) { int res=1,n=nums.size(); sort(nums.begin(),nums.end()); int t=nums[0]*nums[1]*nums[n-1]; return max(t,nums[n-1]*nums[n-2]*nums[n-3]); } }; ` 或者：找出3个最大的数和两个最小的数，来比较两种情况下的乘积，时间复杂度为O(n).]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>数学相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2F2019%2F04%2F06%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[验证变位词 242.Valid Anagram(Easy)s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. 解题思路：可以用哈希表映射字符和出现次数，然后比较两个字符串出现的字符数量是否相等，由于本题的字符串只包含26个小写字符，因此可以用长度为26的数组对字符串出现的字符次数进行统计。 12345678910111213class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.size()!=t.size()) return false; int m[26]=&#123;0&#125;; for(int i=0;i&lt;s.size();i++) m[s[i]-&apos;a&apos;]++; for(int i=0;i&lt;t.size();i++)&#123; if(--m[t[i]-&apos;a&apos;]&lt;0) return false; &#125; return true; &#125;&#125;; 最长回文串 409.Longest Palindrome(Easy)Input : “abccccdd”Output : 7Explanation : One longest palindrome that can be built is “dccaccd”, whose length is 7. 解题思路：题目给我们一个字符串，让找出可以组成的最长的回文串的长度，由于字符顺序可以打乱，所以问题就转化成了求偶数个字符的个数；回文串有两种形式，一种是左右完全对称的，比如noon，还有一种是以中间字符为中心左右对车，比如level，那么我们只需统计出所有偶数个字符的出现总和，然后如果有奇数个字符的话，就取出其最大偶数，然后最终的结果加1即可。123456789101112131415161718class Solution &#123;public: int longestPalindrome(string s) &#123; int res=0; bool odd=false; unordered_map&lt;char,int&gt; m; for(int i=0;i&lt;s.size();i++) m[s[i]]++; for(auto it=m.begin();it!=m.end();it++)&#123; res+=it-&gt;second; if(it-&gt;second%2)&#123; res-=1; odd=true; &#125; &#125; return odd?res+1:res; &#125;&#125;; 同构字符串 205.Isomorphic Strigns(Easy)Given “egg”, “add”, return true.Given “foo”, “bar”, return false.Given “paper”, “title”, return true. 题目描述：求同构字符串，就是说字符串中的每个字符可由另外一个字符替代，相同的字符一定要被同一个字符替代，且一个字符不能被多个字符替代，即不能出现一对多的映射。 解题思路：根据一对一映射的特点，可以用两个哈希表分别记录原字符串和目标字符串中字符出现情况；由于ASCII码只有256个字符，因此可以用一个大小为256的数组来代替哈希表，并初始化为0；遍历数组，分别从源字符串和目标字符串取出一个字符，然后分别在两个哈希表中查找值，若不相等，返回false，若相等，将其值更新为i+1；由于初始值为0，所以更新值为i+1，这样当i=0时，映射为1，如果不加1，就没法区分第一个字符是否被更新了。 12345678910111213class Solution &#123;public: bool isIsomorphic(string s, string t) &#123; int ms[256]=&#123;0&#125;,mt[256]=&#123;0&#125;; for(int i=0;i&lt;s.size();i++)&#123; if(ms[s[i]]!=mt[t[i]]) return false; ms[s[i]]=i+1; mt[t[i]]=i+1; &#125; return true; &#125;&#125;; 回文子字符串 647.Palindromic Substrings(Medium)Input: “aaa”Output: 6Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”. 解题思路：以字符串的每个字符当作回文串中间的位置，然后向两边扩展，每成功匹配左右两个相等的字符，res自增1，然后比较下一对；注意会问字符串有奇数和偶数两种形式，如果是奇数长度，那么位置i就是中间那个字符的位置，所以左右两边都从i开始遍历；如果是偶数长度的，那么i是最中间两个字符的左边那个，右边的就是i+1，这样就能找到所有的回文子字符串啦！ 123456789101112131415161718class Solution &#123;public: int countSubstrings(string s) &#123; if(s.size()==0) return 0; int res=0; for(int i=0;i&lt;s.size();i++)&#123; helper(s,i,i,res); helper(s,i,i+1,res); &#125; return res; &#125; void helper(string &amp;s,int i,int j,int &amp;res)&#123; while(i&gt;=0&amp;&amp;j&lt;=s.size()&amp;&amp;s[i]==s[j])&#123; i--;j++;res++; &#125; &#125;&#125;; 验证回文数字 9.Palindrome Number(Easy)解题思路：由于不能将数字转换为字符串，而是直接对整数进行操作，可以利用取整和取余求出前后的数字然后比较。1234567891011121314151617class Solution &#123;public: bool isPalindrome(int x) &#123; if(x&lt;0) return false; int div=1; while(x/div&gt;=10) div*=10; while(x)&#123; int left=x/div; int right=x%10; if(left!=right) return false; x=(x%div)/10; div/=100; &#125; return true; &#125;&#125;; 统计二进制子字符串 696.Count Binary Substrings(Easy)Input: “00110011”Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1’s and 0’s: “0011”, “01”, “1100”, “10”, “0011”, and “01”. 题目描述：给我们一个二进制字符串，统计具有0和1的个数，且0和1搁在都群组在一起(即0和1不能交替出现)的自字符串的个数。 解题思路：看题目中的例子，00110011，当第一个1出现的时候，由于前面两个0，所以一定能组成01，再遇到下一个1时，组成0011；下一个遇到0时，此时0的个数重置为1，而前面1的个数有两个，一定能组成10，同理，下一个为0，能组成1100。可以发现，只要分别统计0和1的个数，如果当前遇到的是1，那么只要之前统计的0的个数大于等于当前1的个数，就一定有一个对应的子字符串，而一旦前一个数字和当前的数字不一样的时候，那么当前数字的计数要重置为1。遍历数组时，若是第一个数字，则对应的ones和zeros自增1，然后分情况讨论，若当前数字是1，然后判断如果前面数字也是1，则ones自增1，否则ones重置为1，如果zeros&gt;=ones，res自增1.反之同理。 123456789101112131415161718192021class Solution &#123;public: int countBinarySubstrings(string s) &#123; int ones=0,zeros=0,res=0; for(int i=0;i&lt;s.size();i++)&#123; if(i==0)&#123; (s[i]==&apos;1&apos;)?ones++:zeros++; &#125;else&#123; if(s[i]==&apos;1&apos;)&#123; ones= (s[i-1]==&apos;1&apos;)?ones+1:1 ; if(zeros&gt;=ones) res++; &#125;else&#123; zeros= (s[i-1]==&apos;0&apos;)?zeros+1:1; if(ones&gt;=zeros) res++; &#125; &#125; &#125; return res; &#125;&#125;; #补充 验证回文串 125.Valid Palindrome(Easy)Input: “A man, a plan, a canal: Panama”Output: true 题目描述：本题与单独验证一个单词是否是回文字符串的区别就是加入了空格和非字母数字的字符。 解题思路：建立两个指针i和j，分别从字符串的开头和结尾开始遍历整个字符串；如果遇到非字母数字的字符就跳过，继续往中间找，如果遇到大写字母就将其转为小写；当左右指针都找到字母数字时，可以进行比较时，如果相等则两个指针向中间移动，然后继续比较下面两个分别找到的字母数字，若不想等，直接返回false。 12345678910111213141516171819202122class Solution &#123;public: bool isPalindrome(string s) &#123; if(s.size()==0) return true; int i=0,j=s.size()-1; while(i&lt;j)&#123; if(!isLetterOrDigit(s[i])) i++; else if(!isLetterOrDigit(s[j])) j--; else&#123; if(s[i]&gt;=&apos;A&apos;&amp;&amp;s[i]&lt;=&apos;Z&apos;) s[i]+=32; if(s[j]&gt;=&apos;A&apos;&amp;&amp;s[j]&lt;=&apos;Z&apos;) s[j]+=32; if(s[i]!=s[j]) return false; i++;j--; &#125; &#125; return true; &#125; bool isLetterOrDigit(char c)&#123; return (c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)||(c&gt;=&apos;a&apos;&amp;&amp;c&lt;=&apos;z&apos;)||(c&gt;=&apos;A&apos;&amp;&amp;c&lt;=&apos;Z&apos;); &#125;&#125;; 分割回文串 131.Palindrome Partitioning(Medium)Input: “aab”Output:[ [“aa”,”b”], [“a”,”a”,”b”]] 题目描述：题目要求找到所有可能拆分成回文串的情况，那么肯定是所有的情况都要遍历到，对于每一个子字符串都要分别判断一次是不是回文数，因此需要一个判断回文数的子函数。 解题思路：将已经检测好的回文子串放到字符串数组out中，当s遍历完之后，将out加入结果res中。那么在递归函数中我们必须要知道当前遍历到的位置，用变量start表示，所以在递归函数中，如果start等于字符串s的长度，说明遍历完成，将out加入res中，并返回，否则就从start处开始遍历，即从start开始的一个字符、两个字符、三个字符…首先判断取出的字符串是否是回文串，若是回文串那么将其加入out，并调用递归函数判断剩下的字符串是否存在回文串，此时start传入i+1，之后还要恢复out的状态。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; if(s.size()==0) return &#123;&#125;; vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; out; helper(s,0,out,res); return res; &#125; void helper(string &amp;s,int start,vector&lt;string&gt; &amp;out,vector&lt;vector&lt;string&gt;&gt; &amp;res)&#123; if(start==s.size()) &#123;res.push_back(out);return;&#125; for(int i=start;i&lt;s.size();i++)&#123; if(!isPalindrome(s,start,i)) continue; out.push_back(s.substr(start,i-start+1)); helper(s,i+1,out,res); out.pop_back(); &#125; &#125; bool isPalindrome(string &amp;s,int start,int end)&#123; if(start==end) return true; while(start&lt;end)&#123; if(s[start]!=s[end]) return false; start++;end--; &#125; return true; &#125;&#125;; 单词拆分 139.Word Break(Medium)Example 1: Input: s = “leetcode”, wordDict = [“leet”, “code”]Output: trueExplanation: Return true because “leetcode” can be segmented as “leet code”.Example 2: Input: s = “applepenapple”, wordDict = [“apple”, “pen”]Output: trueExplanation: Return true because “applepenapple” can be segmented as “apple pen apple”. Note that you are allowed to reuse a dictionary word.Example 3: Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]Output: false 题目分析：看给定的词句能否被拆分成字典里面的内容。 解题思路：看子字符串是否在字典中，首先要将给定的数组放到hashset中，然后开始给字符串分段，使用记忆数组memo[i]定义为范围为[0,i)的子字符串是否可以拆分，初始化为-1，表示没有计算过，如果可以拆分，则赋值为1，否则置0.用start标记分段的位置，这样递归函数中只需要从start的位置往后遍历即可，在递归函数更新记忆数组memo即可。 123456789101112131415161718class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; wordSet(wordDict.begin(),wordDict.end()); vector&lt;int&gt; memo(s.size(),-1); return check(s,wordSet,0,memo); &#125; bool check(string &amp;s,unordered_set&lt;string&gt; &amp;wordSet,int start,vector&lt;int&gt; &amp;memo)&#123; if(start==s.size()) return true; if(memo[start]!=-1) return memo[start]; for(int i=start+1;i&lt;=s.size();i++)&#123; if(wordSet.count(s.substr(start,i-start))&amp;&amp;check(s,wordSet,i,memo)) return memo[start]=1; &#125; return memo[start]=0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表]]></title>
    <url>%2F2019%2F04%2F05%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[两数之和 1.Two Sum(Easy)解题思路：用map存储数组元素和索引的映射，在访问nums[i]时，判断map中是否存在target-nums[i],若存在说明target-nums[i]所在的索引和i就是要找的两个数。12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; record; for(int i=0;i&lt;nums.size();i++)&#123; int complement=target-nums[i]; if(record.find(complement)!=record.end())&#123; int res[]=&#123;record[complement],i&#125;; return vector&lt;int&gt; &#123;res,res+2&#125;; &#125; record[nums[i]]=i; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 是否包含重复值 217.Contains Duplicate(Easy)解题思路：使用一个哈希表，遍历整个数组，如果哈希表里存在，返回true，否则将其放入哈希表中，遍历结束返回false。12345678910111213class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; m; for(int i=0;i&lt;nums[i].size();i++)&#123; if(m.find(nums[i])!=m.end()) return true; m[nums[i]]++; &#125; return false; &#125;&#125;; 解题思路：先将数组排序，然后比较相邻两个数字是否相等。 12345678910class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); for(int i=1;i&lt;nums.size();i++) if(nums[i]==nums[i-1]) return true; return false; &#125;&#125;; 最长和谐子序列 594.Longest Harmonious Subsequence(Easy)Input: [1,3,2,2,5,2,3,7]Output: 5Explanation: The longest harmonious subsequence is [3,2,2,2,3]. 题目描述：题目给了一个数组，让找出最长的和谐子序列，和谐子序列就是序列中数组的最大最小值均为1。 解题思路：由于只是求长度，并不需要返回具体的子序列。因此可以对数组排序，找出相差为1的两个数的总共出现个数就是一个和谐子序列的长度了。可以建立一个数字和其出现次数之间的映射，利用map的自动排序特性，遍历map的时候就是从小到大开始遍历，从第二个映射开始，每次和前面的映射比较，若二者差值刚好为1，那么就把两个数字出现次数相加并更新res。 1234567891011121314151617class Solution &#123;public: int findLHS(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int res=0; map&lt;int,int&gt; m; for(int i=0;i&lt;nums.size();i++) m[nums[i]]++; for(auto it=next(m.begin());it!=m.end();it++)&#123; auto pre=prev(it); if(it-&gt;first==pre-&gt;first+1) res=max(res,it-&gt;second+pre-&gt;second); &#125; return res; &#125;&#125;; 最长连续序列 128.Longest Consecutive Sequence(Hard)Given [100, 4, 200, 1, 3, 2],The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4. 解题思路：要求最长连续序列，并给定了O(n)复杂度限制。思路就是使用一个set集合存入所有的数字，然后遍历数组中的每个数字，并分别用两个变量pre和next算出其前一个数和后一个数是否在集合中存在，如果pre在集合中，那么将pre移除集合，然后pre自减1，直到pre不在集合中，对next采用同样的方法处理，那么next-pre-1就是当前数字的最长连续序列，再更新res即可。这里需注意，当遍历数组中的数字时，要移除该数字，是为了避免重复计算。比如题目中的例子，在遍历到4的时候，会向下遍历3，2，1，如果都不移除数字的话，遍历到1的时候，还会遍历2，3，4。同样，遍历到3的时候，向上遍历4，向下遍历2，1。如果数组中有大量的连续数字的话，那么就有大量的重复计算，十分的不高效，因此要从HashSet中移除数字。 1234567891011121314151617class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; int res=0; unordered_set&lt;int&gt; s(nums.begin(),nums.end()); for(int i=0;i&lt;nums.size();i++)&#123; if(s.find(nums[i])==s.end()) continue; s.erase(nums[i]); int pre=nums[i]-1,next=nums[i]+1; while(s.count(pre)) s.erase(pre--); while(s.count(next)) s.erase(next++); res=max(res,next-pre-1); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>哈希思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2019%2F04%2F04%2FLeetCode%E5%88%B7%E9%A2%98%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[找到两个链表的交点 160.Intersection of Two Linked Lists(Easy)A: a1 → a2 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii ↘ iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii c1 → c2 → c3 iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii ↗B: b1 → b2 → b3 解题思路：当访问A链表的指针访问到链表尾部时，令它从链表B的头部开始访问链表B；同样地，当访问B链表的指针访问到链表尾部时，令它从链表A的头部开始访问链表A；这样就能使两个指针同时访问到交点。 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode*l1=headA,*l2=headB; while(l1!=l2)&#123; if(l1==NULL) l1=headB; else l1=l1-&gt;next; if(l2==NULL) l2=headA; else l2=l2-&gt;next; &#125; return l1; &#125;&#125;; 链表翻转 206.Reverse Linked List(Easy)迭代解法解题思路：定义三个节点指针pRev,pCur,pNext，pRev初始化为NULL，pCur初始化为头节点，刚开始是pRev-&gt;pCur-&gt;pNext的顺序，只需将它们的指向反过来；然后更新pRev和pCur节点，重复此操作直到pCur为NULL为止。 1234567891011121314class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pCur=head,*pNext,*pRev=NULL; while(pCur)&#123; pNext=pCur-&gt;next; pCur-&gt;next=pRev; pRev=pCur; pCur=pNext; &#125; return pRev; &#125;&#125;; 解题思路：还有一种迭代方法就是头插法，需要定义一个dummy节点，每次将原链表的节点插入到dummy为头节点的新链表中。123456789101112131415class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *dummy=new ListNode(-1); while(head)&#123; ListNode *next=head-&gt;next; head-&gt;next=dummy-&gt;next; dummy-&gt;next=head; head=next; &#125; return dummy-&gt;next; &#125;&#125;; 解题思路：下面还有一种做法，也是头插，只不过每次将当前节点(head)的下一个节点采用头插法，插入到链表前面，当前节点head指向始终不变，直到head为最后一个节点，那么它就从第一个变成了最后一个节点。12345678910111213141516class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *dummy=new ListNode(-1); dummy-&gt;next=head; while(head-&gt;next)&#123;//注意这里判断head是否已经成为链表的末尾 ListNode *tmp=head-&gt;next; head-&gt;next=tmp-&gt;next; tmp-&gt;next=dummy-&gt;next; dummy-&gt;next=tmp; &#125; return dummy-&gt;next; &#125;&#125;; 递归解法解题思路：不断调用函数，直到head指向最后一个节点，因为head指向空或最后一个节点就直接返回了；newHead指向对head的下一个节点调用递归函数返回的头节点，此时newHead指向最后一个节点，而head的下一个节点的next指针应该指向head本身，但head之后的next还没断开，所以要再将head移动到末尾，最后返回newHead即可。 1234567891011class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *newHead=reverseList(head-&gt;next); head-&gt;next-&gt;next=head; head-&gt;next=NULL; return newHead; &#125;&#125;; 合并两个有序的链表 21.Merge Two Sorted Lists(Easy)解法一：与合并有序数组类似解题思路：新建一个链表，比较两个链表中的节点值，把较小的链入到新链表中，由于最终会有一个链表先完成插入所有的节点，则直接把另一个未完成的链表节点直接链入新链表的末尾。 1234567891011121314151617181920class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode *dummy=new ListNode(-1); ListNode *t=dummy; while(l1&amp;&amp;l2)&#123; if(l1-&gt;val&lt;l2-&gt;val)&#123; t-&gt;next=l1; l1=l1-&gt;next; &#125;else&#123; t-&gt;next=l2; l2=l2-&gt;next; &#125; t=t-&gt;next; &#125; t-&gt;next=l1?l1:l2; return dummy-&gt;next; &#125;&#125;; 递归求解解题思路：当某个链表为空了，就返回另一个链表；若都不为空，就比较当前两个节点值大小，如果l1小，那么将l1的下一个节点和l2作为参数去调用，将将返回值赋值给l1-&gt;next，返回l1;否则就将l1和l2-&gt;next作为参数调用，将返回值赋值给l2-&gt;next,然后返回l2.123456789101112131415class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if(!l1) return l2; if(!l2) return l1; if(l1-&gt;val&lt;l2-&gt;val)&#123; l1-&gt;next=mergeTwoLists(l1-&gt;next,l2); return l1; &#125;else&#123; l2-&gt;next=mergeTwoLists(l1,l2-&gt;next); return l2; &#125; &#125;&#125;; 从有序链表中删除重复节点 83.Remove Duplicates from Sorted List(East)Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 迭代求解123456789101112131415class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode *cur=head; while(cur&amp;&amp;cur-&gt;next)&#123; if(cur-&gt;val==cur-&gt;next-&gt;val)&#123; cur-&gt;next=cur-&gt;next-&gt;next; &#125;else cur=cur-&gt;next; &#125; return head; &#125;&#125;; 递归求解解题思路：首先判断是否至少有两个节点，若不是直接返回head。然后对head-&gt;next调用递归函数，并赋值给head-&gt;next,该步进行的操作实质上就是对head后面的节点调用递归函数，那么返回来的链表就已经没有重复项了，此时接到head节点后面；最后一句返回的时候，head先跟其后面的节点进行比较，如果值相同，返回后面的节点，这样就直接跳过了head节点，否则返回head。整个的执行过程就是递归一直到末尾节点，再不断的回溯回来，进行删除重复节点。 123456789class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return head; head-&gt;next=deleteDuplicates(head-&gt;next); return (head-&gt;val==head-&gt;next-&gt;val) ? head-&gt;next:head; &#125;&#125;; 删除链表倒数第n个节点 19.Remove Nth Node from End of List(Medium)Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. 题目描述：n一定不会大于链表长度，并且希望遍历一次就能删除倒数第n个节点。 解题思路：使用两个指针pre和cur，均初始化为head，让cur先移动n步，若此时cur为空，则n为链表长度，则需要移除首元素，即返回head-&gt;next；若cur不为空，同时移动两个指针，直到cur指向最后一个元素，此时pre指向要移除元素的前一个元素，再修改指针跳过要移除的节点即可。 12345678910111213141516class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head-&gt;next==NULL) return NULL; ListNode *pre=head,*cur=head; for(int i=0;i&lt;n;i++) cur=cur-&gt;next; if(cur==NULL) return head-&gt;next; while(cur-&gt;next)&#123; cur=cur-&gt;next; pre=pre-&gt;next; &#125; pre-&gt;next=pre-&gt;next-&gt;next; return head; &#125;&#125;; 交换链表中的相邻节点 24.Swap Nodes in Pairs(Mediun)Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 迭代法解题思路：须建立一个dummy节点，dummy-&gt;next指向头节点。然后定义node1、node2、tmp节点，用于交换相邻两节点。 1234567891011121314151617181920212223class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode *dummy=new ListNode(-1),*pre=dummy; dummy-&gt;next=head; ListNode *node1,*node2,*tmp; while(pre-&gt;next&amp;&amp;pre-&gt;next-&gt;next)&#123; node1=pre-&gt;next; node2=pre-&gt;next-&gt;next; tmp=node2-&gt;next; node2-&gt;next=node1; node1-&gt;next=tmp; pre-&gt;next=node2;//交换好node1和node2之后不要忘记将node2和前面的节点连起来，且这两句顺序不能变 pre=node1; &#125; ListNode *res=dummy-&gt;next; delete(dummy); return res; &#125;&#125;; 递归求解解题思路：利用回溯思想，递归遍历到链表结尾，然后交换末尾两个，再依次往前交换。1234567891011class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(!head||!head-&gt;next) return head; ListNode *tmp=head-&gt;next; head-&gt;next=swapPairs(head-&gt;next-&gt;next); tmp-&gt;next=head; return tmp; &#125;&#125;; 链表求和2.Add Two Numbers(Medium)Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 解题思路：新建一个链表，然后把输入的两个链表从头往后遍历，两两相加，添加一个新节点到新链表后面，为了避免两个输入两链表同时为空，最好建立一个dummy节点，将两个节点相加生成的新节点按顺序加到dummy节点后面。相加时需要处理进位问题。 1234567891011121314151617181920class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *dummy=new ListNode(-1),*cur=dummy;//注意，cur应该指向一个对象(dummy节点)，不能指向dummy-&gt;next int carry=0; while(l1||l2)&#123; int val1=l1?l1-&gt;val:0; int val2=l2?l2-&gt;val:0; int sum=val1+val2+carry; carry=sum/10; cur-&gt;next=new ListNode(sum%10); cur=cur-&gt;next; if(l1) l1=l1-&gt;next; if(l2) l2=l2-&gt;next; &#125; if(carry) cur-&gt;next=new ListNode(1);//最高位进位问题也要特殊处理 return dummy-&gt;next; &#125;&#125;; 455.Add Two Numbers II(Medium)Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 题目描述：这道题目的最高位在链表首位，且不能修改链表。 解法一：借助栈解题思路：利用栈保存所有的元素，然后利用栈先进后出的特点就能从后往前获取链表元素了。首先遍历两个链表，将所有元素压入s1和s2两个栈中；新建一个res节点，然后开始循环，两个栈不为空，就将栈顶元素加入到sum中，然后将res节点赋值为sum%10，再新建一个进位节点head，赋值为sum/10，将head指向res；循环退出后，判断res值是否为0，若为0返回res-&gt;next，否则返回res。 12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; stack&lt;int&gt; s1,s2; while(l1)&#123; s1.push(l1-&gt;val); l1=l1-&gt;next; &#125; while(l2)&#123; s2.push(l2-&gt;val); l2=l2-&gt;next; &#125; int sum=0; ListNode *res=new ListNode(0); while(!s1.empty()||!s2.empty())&#123; if(!s1.empty())&#123; sum+=s1.top(); s1.pop(); &#125; if(!s2.empty())&#123; sum+=s2.top();s2.pop(); &#125; res-&gt;val=sum%10; ListNode *head=new ListNode(sum/10); head-&gt;next=res; res=head; sum/=10; &#125; return res-&gt;val==0?res-&gt;next:res; &#125;&#125;; 回文链表 234.Palindrome Linked List(Easy)Input: 1-&gt;2-&gt;2-&gt;1Output: true 题目描述：要求O(n)时间复杂度以及O(1)空间复杂度。 解法一：忽略空间复杂度的要求，使用栈求解解题思路：使用两个指针，快指针走两步，慢指针走一步，快指针走完时，慢指针的位置就是中点；每次慢指针走一步，就将值存入栈，等到达中点时，链表的前半段都存入栈了，由于栈的前进后出的特点，就可以和后半段链表的值进行比较了。 12345678910111213141516171819202122class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head||!head-&gt;next) return true; ListNode *fast=head,*slow=head; stack&lt;int&gt; s; s.push(slow-&gt;val); while(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123; slow=slow-&gt;next; s.push(slow-&gt;val); fast=fast-&gt;next-&gt;next; &#125; if(!fast-&gt;next) s.pop();//此时链表节点为奇数，slow指向中间节点，须将中间结点出站后比较 while(slow-&gt;next)&#123; slow=slow-&gt;next; int t=s.top();s.pop(); if(slow-&gt;val!=t) return false; &#125; return true; &#125;&#125;; 解法二解题思路：用O(1)的空间，就不能用stack了，可以先找到中点，将后半段的链表翻转一下，然后按顺序比较就好啦！ 123456789101112131415161718192021222324252627class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head||!head-&gt;next) return true; ListNode *fast=head,*slow=head; while(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; &#125; ListNode *cur=slow-&gt;next; while(cur-&gt;next)&#123; ListNode *tmp=cur-&gt;next; cur-&gt;next=tmp-&gt;next; tmp-&gt;next=slow-&gt;next; slow-&gt;next=tmp; &#125;//结束后，slow-&gt;next为后半段链表的头部 //若链表长度为奇数，则slow为中间节点，否则slow为前半段链表的最后一个节点 ListNode *tmp=head; while(slow-&gt;next)&#123; slow=slow-&gt;next; if(tmp-&gt;val!=slow-&gt;val) return false; tmp=tmp-&gt;next; &#125; return true; &#125;&#125;; 分割链表 725.Split Linked List in Pairs(Medium)Input:root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]Explanation:The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts. 题目描述：把链表分割成k部分，每部分的长度尽可能相同，排在前面的长度应该大于等于后面的。 解题思路：要想知道每个部分节点的个数，首先要统计链表中节点个数，然后除以k，得到的商ave就是平分的个数,余数mod就是包含多余节点的子链表的个数。用for循环，循环条件是i&lt;k且root存在，生成k个子链表，在循环中，先把头节点添加到res中，然后遍历该子链表的节点个数，节点个数size=ave+多余节点(前提是还有多余节点)；需注意j&lt;size-1，是因为我们希望移动到子链表的最后一个节点上，而不是移动到下一个子链表的头节点上；然后新建一个临时节点t指向下一个节点，即下一个子链表的头节点，然后将链表断开，再将root指向下一个子链表的头节点。 123456789101112131415161718192021class Solution &#123;public: vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123; vector&lt;ListNode*&gt; res(k); int len=0; for(ListNode *t=root;t;t=t-&gt;next) len++; int ave=len/k,mod=len%k; for(int i=0;i&lt;k&amp;&amp;root;i++)&#123; res[i]=root; int size=ave+(mod--&gt;0?1:0); for(int j=0;j&lt;size-1;j++)&#123; root=root-&gt;next; &#125; ListNode *t=root-&gt;next; root-&gt;next=NULL; root=t; &#125; return res; &#125;&#125;; 链表元素按奇偶聚集 328.Odd Even Linked List(Medium)Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL,return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL.Note:The relative order inside both the even and odd groups should remain as it was in the input.The first node is considered odd, the second node even and so on … 解题思路：分开奇偶节点，所有奇节点在前，偶节点在后；可以使用两个指针来做，pre指向奇节点，cur指向偶节点，然后把cur后面的那个奇节点提前到pre的后面，再把pre和cur各自前进一步，此时cur又指向偶节点，pre指向当前奇节点的末尾，以此类推，直至把所有的偶节点都提前。 123456789101112131415161718class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL) return head; ListNode *pre=head,*cur=head-&gt;next; while(cur&amp;&amp;cur-&gt;next)&#123; ListNode *t=pre-&gt;next; pre-&gt;next=cur-&gt;next; cur-&gt;next=cur-&gt;next-&gt;next; pre-&gt;next-&gt;next=t; pre=pre-&gt;next; cur=cur-&gt;next; &#125; return head; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2019%2F04%2F04%2FLeetCode%E5%88%B7%E9%A2%98%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[递归树的高度 104.Maximum Depth of Binary Tree(Easy)12345678class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; return max(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+1; &#125;&#125;; 平衡树 110.Balanced Binary Tree(Easy)解题思路：高度平衡二叉树是每一个节点的两个子树的深度不超过1，那么就需要一个求节点深度的函数，然后比较每个节点的左右子树的深度差。 1234567891011121314class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(root==NULL) return true; if(abs(getDepth(root-&gt;left)-getDepth(root-&gt;right))&gt;1) return false; return isBalanced(root-&gt;left)&amp;&amp;isBalanced(root-&gt;right); &#125;private: int getDepth(TreeNode *root)&#123; if(root==NULL) return 0; return 1+max(getDepth(root-&gt;left),getDepth(root-&gt;right)); &#125; &#125;; 解题思路：上面这种方法效率不高，因为每个点都会被上面的点计算深度时访问一次，可以对此优化。如果发现子树不平衡，就不计算具体的深度，而是直接返回-1；对于每一个节点，通过checkDepth的方法递归获得左右子树的深度，如果子树平衡，则返回真实的深度，否则返回-1. 1234567891011121314151617181920class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(root==NULL) return true; if(checkDepth(root)==-1) return false; return true; &#125;private: int checkDepth(TreeNode *root)&#123; if(root==NULL) return 0; int left=checkDepth(root-&gt;left); if(left==-1) return -1; int right=checkDepth(root-&gt;right); if(right==-1) return -1; int diff=abs(left-right); if(diff&gt;1) return -1; return 1+max(left,right); &#125; &#125;; 二叉树的直径 543.Diameter of Binary Tree(Easy)Note: The length of path between two nodes is represented by the number of edges between them. 解题思路：二叉树的直径就是两点之间的最远距离，也就是某个节点的左右两个子树的深度之和。 1234567891011121314151617class Solution &#123;public: int diameterOfBinaryTree(TreeNode* root) &#123; int res=0; maxDepth(root,res); return res; &#125;private: int maxDepth(TreeNode *root,int &amp;res)&#123; if(!root) return 0; int left=maxDepth(root-&gt;left,res); int right=maxDepth(root-&gt;right,res); res=max(res,left+right); return 1+max(left,right); &#125;&#125;; 翻转二叉树 226.Invert Binary Tree(Easy)1234567891011class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return NULL; TreeNode *t=root-&gt;left; root-&gt;left=invertTree(root-&gt;right); root-&gt;right=invertTree(t); return root; &#125;&#125;; 归并两棵二叉树 617.Merge Two Binary Trees(Easy)解题思路：如果t1不存在，则直接返回t2；若t2不存在，则直接返回t1；否则以t1和t2的节点值之和建立新节点root，然后对t1和t2的左子节点调用递归并赋给root的左子节点，再对t1和t2的右子节点调用递归并赋给root的右子节点。12345678910111213class Solution &#123;public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) &#123; //if(!t1&amp;&amp;!t2) return NULL; if(!t1) return t2; if(!t2) return t1; TreeNode *root=new TreeNode(t1-&gt;val+t2-&gt;val); root-&gt;left=mergeTrees(t1-&gt;left,t2-&gt;left); root-&gt;right=mergeTrees(t1-&gt;right,t2-&gt;right); return root; &#125;&#125;; 二叉树的路径和判断路径和是否等于一个数 112.Path Sum(Easy)123456789class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root) return false; if(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;root-&gt;val==sum) return true; return hasPathSum(root-&gt;left,sum-root-&gt;val)||hasPathSum(root-&gt;right,sum-root-&gt;val); &#125;&#125;; 找出所有路径和等于一个数的路径 113.Path Sum II(Medium)解题思路：使用深度优先搜索DFS，创建二维数组res和一位数组path，每当DFS搜索到新节点时，都要保存该节点；而且每当找出一条路径之后，都将path保存到res中；而且每当DFS搜索到子节点，发现不是路径和时，返回上一个结点时，需要把该节点从path中移除。 1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; helper(root,sum,path,res); return res; &#125;private: void helper(TreeNode *root,int sum,vector&lt;int&gt; &amp;path,vector&lt;vector&lt;int&gt;&gt; &amp;res)&#123; if(!root) return; path.push_back(root-&gt;val); if(!root-&gt;left&amp;&amp;!root-&gt;right&amp;&amp;root-&gt;val==sum) res.push_back(path); helper(root-&gt;left,sum-root-&gt;val,path,res); helper(root-&gt;right,sum-root-&gt;val,path,res); path.pop_back(); &#125; &#125;; 统计路径和等于一个数的路径数量 437.Path Sum III(Easy)题目描述：求二叉树的路径和等于一个给定值，这条路径不一定从根节点开始，也不一定以叶子节点结尾，可以是中间的任意一段，而且二叉树的节点值有正有负。 解题思路：借助一个子函数求解以root开始的路径和等于给定值的数量，然后在pathSum函数中调用该函数即可。 12345678910111213141516class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; if(!root) return 0; int res=pathSumStartWithNode(root,sum)+pathSum(root-&gt;left,sum)+pathSum(root-&gt;right,sum); return res; &#125; int pathSumStartWithNode(TreeNode* node,int sum)&#123; if(!node) return 0; int res=0; if(node-&gt;val==sum) res++; res+=pathSumStartWithNode(node-&gt;left,sum-node-&gt;val)+pathSumStartWithNode(node-&gt;right,sum-node-&gt;val); return res; &#125;&#125;; 解题思路：还有另一种解法，依然使用递归，相当于先序遍历，对于每一个节点都有记录了一条从根节点到当前节点的路径，同时用一个变量curSum记录路径节点总和，然后看curSum和sum是否相等，相等的话res自增1，不等的话继续查看子路径和有没有满足的，做法就是每次去掉一个节点，看路径和是否等于给定值。1234567891011121314151617181920212223class Solution &#123;public: int pathSum(TreeNode* root, int sum) &#123; int res=0; vector&lt;TreeNode*&gt; record; helper(root,sum,0,record,res); return res; &#125; void helper(TreeNode* node,int sum,int curSum,vector&lt;TreeNode*&gt;&amp; record,int&amp; res)&#123; if(!node) return; curSum+=node-&gt;val; record.push_back(node); if(curSum==sum) res++; int tmp=curSum; for(int i=0;i&lt;record.size()-1;i++)&#123; tmp-=record[i]-&gt;val; if(tmp==sum) res++; &#125; helper(node-&gt;left,sum,curSum,record,res); helper(node-&gt;right,sum,curSum,record,res); record.pop_back(); &#125;&#125;; 子树 572.Subtree of Another Tree(Easy)12345678910111213141516171819202122232425262728293031Given tree s: 3 / \ 4 5 / \ 1 2Given tree t: 4 / \ 1 2Return true, because t has the same structure and node values with a subtree of s.Given tree s: 3 / \ 4 5 / \ 1 2 / 0Given tree t: 4 / \ 1 2Return false. 1234567891011121314class Solution &#123;public: bool isSubtree(TreeNode* s, TreeNode* t) &#123; if(!s) return false; return isSame(s,t)||isSubtree(s-&gt;left,t)||isSubtree(s-&gt;right,t); &#125; bool isSame(TreeNode *s,TreeNode *t)&#123; if(!s&amp;&amp;!t) return true; if(!s||!t) return false; if(s-&gt;val!=t-&gt;val) return false; return isSame(s-&gt;left,t-&gt;left)&amp;&amp;isSame(s-&gt;right,t-&gt;right); &#125;&#125;; 判断对称树 101.Symmetric Tree(Easy)解题思路：判断二叉树是否是对称树，那么对于每一个节点都要对称，t1和他t2是某节点的左右子节点，我们需要比较t1和t2的节点值是否相等，同时还要比较t1的左子节点和t2的右子节点、t1的右子节点和t2的左子节点是否相等。1234567891011121314class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return isSymmetric(root-&gt;left,root-&gt;right); &#125; bool isSymmetric(TreeNode *t1,TreeNode *t2)&#123; if(!t1&amp;&amp;!t2) return true; if(!t1||!t2) return false; if(t1-&gt;val!=t2-&gt;val) return false; return isSymmetric(t1-&gt;left,t2-&gt;right)&amp;&amp;isSymmetric(t1-&gt;right,t2-&gt;left); &#125;&#125;; 最小深度 11.Minimum Depth of Binary Tree(Easy)解题思路：用深度优先搜索DFS来做。首先判空，若当前节点不存在，直接返回0；然后求左右子节点的深度，若其中一个子节点为空，则将另一个子节点深度加1返回；若左右都存在，则将二者中的较小值加1返回即可。1234567891011class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(!root) return 0; int left=minDepth(root-&gt;left); int right=minDepth(root-&gt;right); if(left==0||right==0) return left+right+1; return min(left,right)+1; &#125;&#125;; 层次遍历一棵树每层节点的平均数 637.Average pf Levels in Binary Tree(Easy)解题思路：用queue存储节点，将每层的值累加，除以该层的节点个数，存入res即可。 1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123; vector&lt;double&gt; res; queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;; while(!q.empty())&#123; int size=q.size(); double sum=0; for(int i=0;i&lt;size;i++)&#123; TreeNode* t=q.front();q.pop(); sum+=t-&gt;val; if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); &#125; res.push_back(sum/size); &#125; return res; &#125;&#125;; 寻找最左下角树节点的值 513.Find Bottom Left Tree Value(Easy)解题思路：求二叉树的最左下树节点的值，即最后一行左树第一个值，最直接的方法就是层序遍历，因为层序遍历时遍历完当前行所有节点之后才去下一行，那么我们再遍历每行一个节点时更新结果res即可。 123456789101112131415161718class Solution &#123;public: int findBottomLeftValue(TreeNode* root) &#123; int res=0; queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;; while(!q.empty())&#123; int size=q.size(); for(int i=0;i&lt;size;i++)&#123; TreeNode* t=q.front();q.pop(); if(i==0) res=t-&gt;val; if(t-&gt;left) q.push(t-&gt;left); if(t-&gt;right) q.push(t-&gt;right); &#125; &#125; return res; &#125;&#125;; 或者：由于一般的层序是从左到右，那么如果反过来，每次从右往左，这样就不用检测每一层的起始位置了，最后一个处理的节点一定是最后一层的最左节点，直接返回节点值即可。123456789101112131415class Solution &#123;public: int findBottomLeftValue(TreeNode* root) &#123; int res=0; queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;; while(!q.empty())&#123; TreeNode *t=q.front();q.pop(); res=t-&gt;val; if(t-&gt;right) q.push(t-&gt;right); if(t-&gt;left) q.push(t-&gt;left); &#125; return res; &#125;&#125;; 前中后序遍历(递归与非递归)123456 1 / \ 2 3 / \ \4 5 6 层次遍历顺序[1 2 3 4 5 6] 前序遍历顺序[1 2 4 5 3 6] 中序遍历顺序[4 2 5 1 3 6] 后序遍历顺序[4 5 2 6 3 1] 123456789101112131415161718192021222324//前序void dfs(TreeNode* root)&#123; if(!root) return; visit(root); dfs(root-&gt;left); dfs(root-&gt;right);&#125;//中序void dfs(TreeNode* root)&#123; if(!root) return; dfs(root-&gt;left); visit(root); dfs(root-&gt;right);&#125;//中序 void dfs(TreeNode* root)&#123; if(!root) return; dfs(root-&gt;left); dfs(root-&gt;right); visit(root); &#125; 二叉树的前序遍历 144.Binary Tree Preorder Traversal(Medium)解题思路： 先序遍历的顺序是“根-左-右”，要用到stack来辅助运算。 把根节点push到栈中； 循环检测栈是否为空，若不空，取出栈顶元素，保存其值，然后看其右子节点是否存在，若存在则push到栈中；再看其左子节点，若存在，则push到栈中。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if(root==NULL) return &#123;&#125;; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s&#123;&#123;root&#125;&#125;; while(!s.empty())&#123; TreeNode *t=s.top();s.pop(); res.push_back(t-&gt;val); if(t-&gt;right) s.push(t-&gt;right); if(t-&gt;left) s.push(t-&gt;left); &#125; return res; &#125;&#125;; 解法二： 使用一个辅助节点，这种写法可以看作是一个模板，对应的还有中序和后续的模板写法，形式很统一。辅助节点p初始化为根节点，while循环的条件是栈不为空或p不为空，在循环中首先判断p存在，那么先将p压入栈中，然后将p的节点值加入结果res中，此时p指向其左子节点；若p并不存在，表明没有左子节点，那么取出栈顶节点，将p指向栈顶节点的右子节点。123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; if(root==NULL) return &#123;&#125;; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; TreeNode *p=root; while(p||!s.empty())&#123; if(p)&#123; s.push(p); res.push_back(p-&gt;val); p=p-&gt;left; &#125;else&#123; TreeNode *t=s.top();s.pop(); p=t-&gt;right; &#125; &#125; return res; &#125;&#125;; 二叉树的中序遍历 94.Binary Tree Inorder Traversal(Mudium)解题思路： 需要用到栈，从根节点开始，先将根节点压入栈，然后再将其所有左子节点压入栈，然后取出栈顶节点，保存节点值，再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子节点压入栈中。这样就保证了访问顺序是“左-根-右”。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; TreeNode *p=root; while(p||!s.empty())&#123; while(p)&#123; s.push(p); p=p-&gt;left; &#125; p=s.top();s.pop(); res.push_back(p-&gt;val); p=p-&gt;right; &#125; return res; &#125;&#125;; 解法二： 与前序遍历的解法二一样，把节点值加入结果res的步骤从if移到了else。1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; TreeNode *p=root; while(p||!s.empty())&#123; if(p)&#123; s.push(p); p=p-&gt;left; &#125;else&#123; p=s.top();s.pop(); res.push_back(p-&gt;val); p=p-&gt;right; &#125; &#125; return res; &#125;&#125;; 二叉树的后序遍历 145.Binary Tree Postorder Traversal(Medium)解题思路： 由于后序遍历的顺序是“左-右-根”，而前序遍历的顺序是“根-左-右”，可以现在先序遍历方法一的基础上做些小改动，使其遍历顺序为“根-右-左”，然后翻转一下就可以啦!翻转的方法是每次都在res的开头加入节点值。12345678910111213141516class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if(!root) return &#123;&#125;;//，若不加这个判断，当root为空时会出现RE vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s&#123;&#123;root&#125;&#125;; while(!s.empty())&#123; TreeNode *t=s.top();s.pop(); res.insert(res.begin(),t-&gt;val); if(t-&gt;left) s.push(t-&gt;left); if(t-&gt;right) s.push(t-&gt;right); &#125; return res; &#125;&#125;; 解法二： 改动的思路和上面的解法一样，将先序遍历的根-左-右，变成根-右-左，然后翻转结果即可。 1234567891011121314151617181920public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; if(!root) return &#123;&#125;; vector&lt;int&gt; res; stack&lt;TreeNode*&gt; s; TreeNode *p=root; while(p||!s.empty())&#123; if(p)&#123; s.push(p); res.insert(res.begin(),p-&gt;val); p=p-&gt;right; &#125;else&#123; p=s.top();s.pop(); p=p-&gt;left; &#125; &#125; return res; &#125;&#125;; BST二叉查找树(BST)：根节点大于等于其所有节点，小于等于右子树所有节点。二叉查找树中序遍历有序。 修剪二叉查找树 669.Trim a Binary Search Tree(Easy)题目描述：修剪一颗二叉树，给了边界[L,R],所有不在这个范围内的节点应该被移除掉，但是仍需保留二叉搜索树的性质。解题思路：首先判断root为空，为空直接返回即可，然后看根节点是否在范围内，若根节点值小于L，那么返回其右子节点调用递归函数的值；如果根节点大于R，返回其左子节点调用递归函数的值。如果根节点在范围内，将其左子节点更新为对其左子节点调用递归函数的返回值，同样，将其右子节点更新为对其右子节点调用递归函数的返回值。最后返回root即可。 123456789101112class Solution &#123;public: TreeNode* trimBST(TreeNode* root, int L, int R) &#123; if(!root) return NULL; if(root-&gt;val&lt;L) return trimBST(root-&gt;right,L,R); if(root-&gt;val&gt;R) return trimBST(root-&gt;left,L,R); root-&gt;left=trimBST(root-&gt;left,L,R); root-&gt;right=trimBST(root-&gt;right,L,R); return root; &#125;&#125;; 二叉搜索树中第K小的元素 230.Kth Smallest Element in a BST(Mediun)解题思路： 使用中序遍历对的非递归方法，先遍历最小的节点，每遍历一个节点，计数器k减1，直到k为0，返回当前节点值即可。123456789101112131415161718class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; stack&lt;TreeNode*&gt; s; TreeNode *p=root; while(p||!s.empty())&#123; while(p)&#123; s.push(p); p=p-&gt;left; &#125; p=s.top();s.pop(); if(--k==0) return p-&gt;val; p=p-&gt;right; &#125; return -1; &#125;&#125;; 递归求解1234567891011121314class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; return kthSmallestDFS(root,k); &#125; int kthSmallestDFS(TreeNode *root,int&amp; k)&#123; if(!root) return -1; int value=kthSmallestDFS(root-&gt;left,k); if(k==0) return value; if(--k==0) return root-&gt;val; return kthSmallestDFS(root-&gt;right,k); &#125;&#125;; 二叉查找树的最近公共祖先 235.Lowest Common Ancesteor of a Binary Search Tree(Easy)解题思路：由于二叉搜索树的特点是左&lt;根&lt;右，所以根节点一直都是中间值。如果根节点的值大于p和q之间的较大值，说明p和q都在左子树中，那么就进入根节点的左子节点继续递归，如果根节点小于p和q之间的较小值，说明p和q都在右子树中，那么此时就进入根节点的右子树中继续递归，如果都不是，说明当前根节点就是最近公共祖先。12345678910class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root) return NULL; if(root-&gt;val&gt;max(p-&gt;val,q-&gt;val)) return lowestCommonAncestor(root-&gt;left,p,q); else if(root-&gt;val&lt;min(p-&gt;val,q-&gt;val)) return lowestCommonAncestor(root-&gt;right,p,q); else return root; &#125;&#125;; 二叉树的最近公共祖先 236.Lowest Common Ancestor of a Binary Tree(Medium)解题思路：用递归实现，在递归函数中，首先判断当前节点是否为空，若为空则直接返回空，若p或q中的任意一个，则直接返回当前节点。否则的话就对其左右子节点分别调用递归函数，由于这道题目限制了p和q一定都在二叉树中存在，那么如果当前节点不等于q或p，p和q要么分别位于左右子树中，要么同时位于左子树，要么同时位于右子树，分情况讨论： 若q和p分别位于左右子树中，那么对左右子节点调用递归函数，会分别返回q和p的位置，而当前节点就是p和q的最近公共祖先，直接返回当前节点即可； 若q和p同时位于左子树，这里有两种情况，一种是left会返回p和q中较高的那个位置，二right会返回空，所以最终返回非空的left即可；还有一中情况是会返回q和p的最近公共祖先，即当前节点的子树中的某个节点才是q和p的最近公共节点； 若p和q同时位于右子树，同样这里有两种情况，一种情况是right会返回p和q中较高的那个位置，而left会返回空，所以我们最终返回非空的right即可，还有一种情况是会返回p和q的最小父结点，就是说当前结点的右子树中的某个结点才是p和q的最小父结点，会被返回 1234567891011class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root||p==root||q==root) return root; TreeNode* left=lowestCommonAncestor(root-&gt;left,p,q); TreeNode *right=lowestCommonAncestor(root-&gt;right,p,q); if(left&amp;&amp;right) return root; return left?left:right; &#125;&#125;; 从有序数组中构造二叉搜索树 108.Convert Sorted Array to Binary Search Tree(Easy)解题思路：将有序数组转为二叉搜索树，即始终满足左&lt;根&lt;右。根节点应该是有序数组的中间点，从中间点分开为左右两个有序数组，在分别找出其中间点作为原中间点的左右两个子节点，也就是二分查找法的核心思想。 123456789101112131415class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return helper(nums,0,nums.size()-1); &#125; TreeNode* helper(vector&lt;int&gt;&amp; nums,int left,int right)&#123; if(left&gt;right) return NULL; int mid=left+(right-left)/2; TreeNode *root=new TreeNode(nums[mid]); root-&gt;left=helper(nums,left,mid-1); root-&gt;right=helper(nums,mid+1,right); return root; &#125;&#125;; 根据有序链表构造成二叉查找树 109.Convert Sorted List to Binary Search Tree(Medium)解题思路：由于二分查找需要每次找到中点，而链表的查找中间点可以通过快慢指针来操作；找到中间后，要以中点的值建立一个数的根节点，然后需要把原链表断掉，分为前后两个链表，但都不能包含原中间节点，然后再分别对这两个链表递归调用原函数，分别连上左右子节点即可！1234567891011121314151617181920class Solution &#123;public: TreeNode* sortedListToBST(ListNode* head) &#123; if(!head) return NULL; if(!head-&gt;next) return new TreeNode(head-&gt;val); ListNode *slow=head,*fast=head,*last=slow; while(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123; last=slow; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; &#125; fast=slow-&gt;next; last-&gt;next=NULL;//！！！ TreeNode *cur=new TreeNode(slow-&gt;val); if(slow!=head) cur-&gt;left=sortedListToBST(head); cur-&gt;right=sortedListToBST(fast); return cur; &#125;&#125;; 在二叉树中寻找两个节点，使它们的和为一个给定值 653.Two Sum IV-Input is a BST解题思路：中序遍历得到有序数组，再利用双指针对数组进行查找。 12345678910111213141516171819202122class Solution &#123;public: bool findTarget(TreeNode* root, int k) &#123; vector&lt;int&gt; nums; inOrder(root,nums); int i=0,j=nums.size()-1; while(i&lt;j)&#123; int m=i+(j-i)/2; if(nums[i]+nums[j]==k) return true; else if(nums[i]+nums[j]&lt;k) i++; else j--; &#125; return false; &#125; void inOrder(TreeNode* root,vector&lt;int&gt; &amp;nums)&#123; if(!root) return; inOrder(root-&gt;left,nums); nums.push_back(root-&gt;val); inOrder(root-&gt;right,nums); &#125;&#125;; 在二叉搜索树中查找两个节点之间的最小绝对差 530.Minimum Absolute Difference in BST(Easy)题目描述：给一棵二叉搜索树，求任意个节点值之间的最小绝对差。由于BST的左&lt;根&lt;右的性质可知，如果按照中序遍历得到一个有序数组，那么最小绝对差肯定在相邻的两个节点值之间产生。解题思路：对BST进行中序遍历，然后当前节点值和之前节点值求绝对差并更新结果res。这里需要注意的就是在处理第一个节点值时，由于其没有前节点，所以不能求绝对差；这里我们用变量pre来表示前节点值，由于题目中说明了节点值不为负数，所以给pre初始化为-1，这样我们就知道pre是否存在。如果没有题目中的这个非负条件，就不能用int变量，必须要用指针，通过判断指针是否指向空来判断前节点是否存在。 12345678910111213141516class Solution &#123;public: int getMinimumDifference(TreeNode* root) &#123; int res=INT_MAX,pre=-1; inOrder(root,pre,res); return res; &#125; void inOrder(TreeNode* root,int&amp; pre,int &amp;res)&#123; if(!root) return; inOrder(root-&gt;left,pre,res); if(pre!=-1) res=min(res,abs(root-&gt;val-pre)); pre=root-&gt;val; inOrder(root-&gt;right,pre,res); &#125;&#125;; 查找二叉搜索树的众数 501.Find Mode in Binary Search Tree(Easy)问题描述：求二叉搜索树的众数，这里定义的二分搜索树中左根右节点之间的关系是小于等于的，有些题目是严格小于的，所以一定要看清题。解题思路：众数就是出现次数最多次的数字，可以有多个，那么这道题比较直接的思路就是利用一个哈希表记录数字和其出现次数之间的映射，然后维护一个max来记录当前最多的次数值，这样遍历完树之后，根据max值就能把对应的元素找出来；这种方法就不需要利用二分搜索树的性质了，随意一种便利方式都可以。123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; findMode(TreeNode* root) &#123; vector&lt;int&gt; res; int mx=0; unordered_map&lt;int,int&gt; m; inOrder(root,mx,m); for(auto a:m)&#123; if(a.second==mx) res.push_back(a.first); &#125; return res; &#125; void inOrder(TreeNode* root,int &amp;mx,unordered_map&lt;int,int&gt; &amp;m)&#123; if(!root) return; inOrder(root-&gt;left,mx,m); mx=max(mx,++m[root-&gt;val]); inOrder(root-&gt;right,mx,m); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治]]></title>
    <url>%2F2019%2F04%2F02%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[给表达式加括号 241.Different Ways to Add Parentheses(Medium)Input: “2-1-1”.((2-1)-1) = 0(2-(1-1)) = 2Output : [0, 2] 题目描述：给出一个可能含有加减乘的表达式，让我们在任意位置添加括号，求出所有可能的表达式的值。 解题思路：以遇到的运算符为界，将表达式分为两部分，分别递归求解。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; res; for(int i=0;i&lt;input.size();i++)&#123; if(input[i]==&apos;+&apos;||input[i]==&apos;-&apos;||input[i]==&apos;*&apos;)&#123; vector&lt;int&gt; left=diffWaysToCompute(input.substr(0,i));//获得字符串input中从0开始长度为i的字符串 vector&lt;int&gt; right=diffWaysToCompute(input.substr(i+1));//默认时的长度是从开始到尾 for(int j=0;j&lt;left.size();j++)&#123; for(int k=0;k&lt;right.size();k++)&#123; if(input[i]==&apos;+&apos;) res.push_back(left[j]+right[k]); else if(input[i]==&apos;-&apos;) res.push_back(left[j]-right[k]); else res.push_back(left[j]*right[k]); &#125; &#125; &#125; &#125; //若res为空，说明传入的字符串为一个数字，直接将该数字存入结果即可 //c_str()函数返回一个指向正规C字符串的指针常量,atoi()的参数类型是const char* if(res.empty()) res.push_back(atoi(input.c_str())); return res; &#125;&#125;; 上述解法中的递归函数的参数没用指针，这样的话每次调用都要拷贝string对象，如果用指针的化就是直接引用，在leetcode上测试两种方法消耗的内存没差，可能是因为传入的对象本身就不大。 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; if(input.empty()) return &#123;&#125;; return helper(input,0,input.size()-1); &#125;private: vector&lt;int&gt; helper(string&amp; input,int l,int r)&#123; vector&lt;int&gt; res; for(int i=l;i&lt;=r;i++)&#123; if(input[i]==&apos;+&apos;||input[i]==&apos;-&apos;||input[i]==&apos;*&apos;)&#123; vector&lt;int&gt; left=helper(input,l,i-1);//获得字符串input中从0开始长度为i的字符串 vector&lt;int&gt; right=helper(input,i+1,r);//默认时的长度是从开始到尾 for(int j=0;j&lt;left.size();j++)&#123; for(int k=0;k&lt;right.size();k++)&#123; if(input[i]==&apos;+&apos;) res.push_back(left[j]+right[k]); else if(input[i]==&apos;-&apos;) res.push_back(left[j]-right[k]); else res.push_back(left[j]*right[k]); &#125; &#125; &#125; &#125; if(res.empty()) res.push_back(atoi(input.substr(l,r-l+1).c_str())); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心思想]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode%E5%88%B7%E9%A2%98%2F%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[分配饼干 455.Assign Cookies (Easy)Input: [1,2], [1,2,3]Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.You have 3 cookies and their sizes are big enough to gratify all of the children,You need to output 2. 题目描述：每个孩子都有一个满意度，每个饼干斗殴一个大小，只有饼干的大小大于等于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。 解题思路：先拿最小的Cookies给胃口最小的孩子，看能否满足，能的话，res自增1，然后再拿下一个Cookies去满足下一位小朋友；如果当前Cookies不能满足当前小朋友，那么就用下一块稍大一些的Cookies去尝试满足当前的小朋友。当Cookies发完了或小朋友都满足了就停止遍历。 123456789101112131415class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; sort(g.begin(),g.end()); sort(s.begin(),s.end()); int res=0,si=0; while(res&lt;g.size()&amp;&amp;si&lt;s.size())&#123; if(s[si]&gt;=g[res]) res++; si++; &#125; return res; &#125;&#125;; 不重叠的区间个数 435.Non-overlapping Intervals (Medium)Input: [ [1,2], [1,2], [1,2] ] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. 题目描述：计算让一组区间不重叠最少需要移除的区间个数。 解题思路：先计算最多能组成的不重叠区间个数，然后用区间总个数减去不重叠区间的个数。 在每次选择中，区间的结尾最为重要，选择的区间结尾越小，留给后面的区间的空间越大，那么后面的区间个数也就越大。 按区间的结尾进行排序，每次选择结尾最小并且和前一个区间不重叠的区间。 1234567891011121314151617181920212223242526/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public: int eraseOverlapIntervals(vector&lt;Interval&gt;&amp; intervals) &#123; if(intervals.size()==0) return 0; sort(intervals.begin(),intervals.end(),[](Interval&amp; a,Interval&amp; b)&#123;return a.end&lt;b.end;&#125;); int res=1; int end=intervals[0].end; for(int i=1;i&lt;intervals.size();i++)&#123; if(intervals[i].start&lt;end) continue; end=intervals[i].end; res++; &#125; return intervals.size()-res; &#125;&#125;; 非递减数组665.Non-decreasing Array(Easy)Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. 题目描述：最多有一次修改某个数字的机会，问是否能将数组变为非递减数组。 解题思路：看下面三个例子，4，2，3-1，4，2，32，3，4，2，5观察上面三个例子可以发现，当后面的数字小于前面的数字时，有时只需修改前面较大的数字(如前两个例子)，有时却要修改后面较小的数字(如第3个例子)，规律如下：判断较小的数字与再前面的数字的关系！ 如果再前面的数字不存在，如第一个例子，4前面没有数字了，就直接修改前面的数字为当前的数字2； 若再前面的数字存在，且小于当前数字时(-1&lt;2)，同样的，直接修改前面的数字为当前的数字2就好了； 若再前面的数字存在，但大于当前数字时(3&gt;2)，就需要修改当前的数字为前面的数字； 由于只有一次修改的机会，用一个变量flag，初始化为true，修改数字后变为false，当下次再需要修改时，若flag为false，就直接返回false；遍历结束后返回true。 123456789101112131415161718class Solution &#123;public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; bool flag=true; for(int i=1;i&lt;nums.size();i++)&#123; if(nums[i]&lt;nums[i-1])&#123; if(!flag) return false; if(i==1||nums[i]&gt;=nums[i-2]) nums[i-1]=nums[i]; else nums[i]=nums[i-1]; flag=false; &#125; &#125; return true; &#125;&#125;; 买入和售出股票的最大收益121.Best Time to Buy and Sell Stock(Easy)题目描述：只进行一次交易 解题思路：记录前面的最小价格，将这个价格作为买入价格，然后将当前的价格作为售出价格，判断当前收益是否为最大收益。 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0,buy=INT_MAX; for(int i=0;i&lt;prices.size();i++)&#123; buy=min(buy,prices[i]); res=max(res,prices[i]-buy); &#125; return res; &#125;&#125;; 122.Best Time to Buy and Sell Stock II(Easy)题目描述：可以交易无数次，一次股票交易包括买入和卖出，多个交易之间不能交叉。 解题思路：只需要从第二天开始，如果当前价格比昨天价格高，就把差值加入到收益，因为我们可以昨天买入，今天卖出，若明天价更高，还可以今天买入，明天卖出；以此类推。 123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res=0; for(int i=1;i&lt;prices.size();i++)&#123; if(prices[i]&gt;prices[i-1]) res+=prices[i]-prices[i-1]; &#125; return res; &#125;&#125;; 还有股票3问题，需要用到动态规划，就先不写啦！ 子数组最大的和 53.Maximum Subarray(Easy)For example, given the array [-2,1,-3,4,-1,2,1,-5,4],the contiguous subarray [4,-1,2,1] has the largest sum = 6. O(n)时间复杂度解题思路：定义两个变量res和curSum，res保存要返回的结果，curSum保存当前为止求出的数组之和的最大值；每遍历一个数字nums[i],比较curSum+nums[i]和nums[i]中的较大值存入curSum，然后再比较res和curSum的较大值并存入res，以此类推，最后返回res。 123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int res=INT_MIN,curSum=0; for(int num:nums)&#123; curSum=max(curSum+num,num); res=max(res,curSum); &#125; return res; &#125;&#125;; O(logn)时间复杂度解题思路：分治法求解，把数组分为两部分，分别求出左边和右边的最大数组之和；然后还要从中间向左右两边分别扫描，找出包含中间元素的最大数组之和；求出包含中间元素的最大值和左右两边得到的最大值中较大的那个。 1234567891011121314151617181920212223242526class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty()) return 0; return helper(nums,0,nums.size()-1); &#125;private: int helper(vector&lt;int&gt;&amp; nums,int l,int r)&#123; if(l&gt;=r) return nums[l]; int m=l+(r-l)/2; int lmax=helper(nums,l,m-1); int rmax=helper(nums,m+1,r); int mmax=nums[m],t=mmax; for(int i=m-1;i&gt;=l;i--)&#123; t+=nums[i]; mmax=max(mmax,t); &#125; t=mmax; for(int i=m+1;i&lt;=r;i++)&#123; t+=nums[i]; mmax=max(mmax,t); &#125; return max(mmax,max(lmax,rmax)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2019%2F03%2F31%2FLeetCode%E5%88%B7%E9%A2%98%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[求开方 69.Sqrt (Easy)Input: 4Output: 2 Input: 8Output: 2Explanation: The square root of 8 is 2.82842…, and since we want to return an integer, the decimal part will be truncated. 解题思路：利用二分查找在0~x中查找sqrt。对于x=8，它的开方是2.82842…，最后返回2而不是3.再循环条件l&lt;=h并且循环退出时，h总是比l小，即h=2，l=3，因此最后的返回值应该是h而不是l。 1234567891011121314151617class Solution &#123;public: int mySqrt(int x) &#123; if(x==0||x==1) return x; int l=0,h=x; while(l&lt;=h)&#123; int mid=(l+h)&gt;&gt;1; if(mid==x/mid) return mid; else if(mid&gt;x/mid) h=mid-1; else l=mid+1; &#125; return h; &#125;&#125;; 大于给定元素的最小元素 744.Find Smallest Letter Greater Than Target (Easy)题目描述：给定一个有序数组和一个字符，要求找出letters中大于target的最小字符，如果找不到就返回第一个字符。 1234567891011121314class Solution &#123;public: char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; int l=0,h=letters.size()-1; while(l&lt;=h)&#123; int m=l+(h-l)/2; if(letters[m]&lt;=target) l=m+1; else h=m-1; &#125; return l&lt;letters.size()? letters[l]:letters[0]; &#125;&#125;; 有序数组中的单独元素 540.Single Element in a Sorted Array (Medium)Input: [1,1,2,3,3,4,4,8,8]Output: 2 Note: Your solution should run in O(log n) time and O(1) space. 题目描述：题目给了一个有序数组，所有的元素都出现了两次，除了一个元素，让我们找到这个元素。 解题思路： 设index为单独元素在数组中的位置。如果m为偶数，并且m+1&lt;index,那么nums[m]==nums[m+1];m+1&gt;index,那么nums[m]!=nums[m+1]. 从上面的规律可以看出，如果nums[m]==nums[m+1]，那么index所在数组位置为[m+2,h],此时令l=m+2;如果nums[m]!=nums[m+1]，那么index所在数组位置为[l,m],此时令h=m。 解释为什么可以直接取nums[m+1]的值，不用考虑越界？因为如果l与h相等就不会进入循环，所以m一定比h小，一定会有m+1存在。 12345678910111213141516class Solution &#123;public: int singleNonDuplicate(vector&lt;int&gt;&amp; nums) &#123; int l=0,h=nums.size()-1; while(l&lt;h)&#123; int m=l+(h-l)/2; if(m&amp;1) m--;//保证l/m/h均为偶数 if(nums[m]==nums[m+1]) l=m+2; else h=m; &#125; return nums[l];//返回l或h均可 &#125;&#125;; 第一个错误的版本 278.First Bad Version题目描述：给定一个元素n代表有[1,2,3…n]版本，可以调用isBadversion(int x)知道某个版本是否错误，要求找到第一个错误的版本。 解题思路：如果第m个版本出错，则表示第一个错误的版本在[l,m]之间，令h=m；否则第一个错误的版本在[m+1,h]之间，令l=m+1.因为h的赋值表达式为h=m，因此循环条件为l&lt;h,不然可能会死循环。 1234567891011121314151617// Forward declaration of isBadVersion API.bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int l=0,h=n; while(l&lt;h)&#123; int m=l+(h-l)/2; if(isBadVersion(m)) h=m; else l=m+1; &#125; return l; &#125;&#125;; 旋转数字的最小数字 153.Find Minimum in Rotated Sorted Array (medium)Input: [3,4,5,1,2],Output: 1 解题思路：如果nums[m]&gt;nums[h],则最小的数字肯定在[m+1,h]之间，令l=m+1;否则，最小的数字在[l,m]之间，令h=m(若nums[m]&lt;nums[h],则m对应的数字肯定在最小数字的右边，即是和最小数字一起被旋转到数组后面的); 123456789101112131415class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; int l=0,h=nums.size()-1; while(l&lt;h)&#123; int m=l+(h-l)/2; if(nums[m]&gt;nums[h]) l=m+1; else h=m; &#125; return nums[l]; &#125;&#125;; 查找区间 34.Find First and Last Position of Element in a Sorted Array (Medium)Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 解题思路：定义一个二分查找子函数。若nums[m]&gt;=target,h=m;否则l=m-1;该函数h初始值为nums.size(), 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int first=binarySearch(nums,target); int last=binarySearch(nums,target+1)-1; if(first==nums.size()||nums[first]!=target) return vector&lt;int&gt; &#123;-1,-1&#125;; else&#123; return vector&lt;int&gt; &#123;first,max(first,last)&#125;; &#125; &#125;private: int binarySearch(vector&lt;int&gt;&amp;nums,int target)&#123; int l=0,h=nums.size();//注意，h的初值 while(l&lt;h)&#123; int m=l+(h-l)/2; if(nums[m]&gt;=target) h=m; else l=m+1; &#125; return l; &#125;&#125;; 代码解释：return vector {first,max(first,last)};若改成return vector {first,last};若出现数组中只有一个元素时，会出错，如Input：[1]1Output：[0,-1]Expected：[0,0] 代码解释：int l=0,h=nums.size();若改成h=nums.size()-1;若找不到target时，返回的将是nums.size()-1的值，再减1之后值就不对了，该句代码主要是考虑到target为最后的元素的情况，如：Input:[2,2]2Output:[0,0]Expected:[0,1]]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双指针]]></title>
    <url>%2F2019%2F03%2F30%2FLeetCode%E5%88%B7%E9%A2%98%2F%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[有序数组的 167.Two Sum IIInput: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 题目描述：在有序数组中找出两个数，使它们的和为 target。 解题思路：使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。 如果两个指针指向元素的和sum==target，即返回结果； 如果sum&gt;target，移动较大元素的指针； 如果sum&lt;target，移动较小元素的指针。 123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int i=0,j=numbers.size()-1; while(i&lt;j)&#123; if(numbers[i]+numbers[j]==target) return vector&lt;int&gt; &#123;i+1,j+1&#125;; else if(numbers[i]+numbers[j]&lt;target) i++; else j--; &#125; return vector&lt;int&gt;&#123;&#125;; &#125;&#125;; 两数平方和 633.Sum of Square NumbersInput: 5Output: TrueExplanation: 1 1 + 2 2 = 5 题目描述：判断一个数是否为两个数的平方和。 12345678910111213141516class Solution &#123;public: bool judgeSquareSum(int c) &#123; int i=0,j=(int)sqrt(c); while(i&lt;=j)&#123; int powSum=i*i+j*j; if(powSum==c) return true; else if(powSum&lt;c) i++; else j--; &#125; return false; &#125;&#125;; 上述代码超时，无奈又去网上找了其他的解法： 方法二： 由于是求一个数能否由两个数平方之和组成，需要判断两次；从c的平方根开始；先判断如果i i==c,说明c是个平方数，再凑个0就是两数平方之和，返回true；如果不等，那么算出c-ii，如果这个差值也是个平方数的化，返回true；遍历结束后返回false。 123456789101112class Solution &#123;public: bool judgeSquareSum(int c) &#123; for(int i=sqrt(c);i&gt;=0;i--)&#123; if(i*i==c) return true; int t=c-i*i,j=sqrt(t); if(j*j==t) return true; &#125; return false; &#125;&#125;; 方法三： 使用集合set，对于每个i i,都加入集合set中，然后计算c-ii，如果这个差值在集合set中，则返回true，遍历结束返回false。1234567891011121314class Solution &#123;public: bool judgeSquareSum(int c) &#123; unordered_set&lt;int&gt; s; for(int i=0;i&lt;=sqrt(c);i++)&#123; s.insert(i*i); int t=c-i*i; if(s.find(t)!=s.end()) return true; &#125; return false; &#125;&#125;; 翻转字符串的元音字母 345.Reverse Vowels of a StrigGiven s = “leetcode”, return “leotcede”. 使用双指针指向待翻转的两个原因字符，一个从头向尾，一个指针从尾向头。 12345678910111213141516171819202122class Solution &#123;public: string reverseVowels(string s) &#123; int i=0,j=s.size()-1; char vowel[]=&#123;&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;,&apos;A&apos;,&apos;E&apos;,&apos;I&apos;,&apos;O&apos;,&apos;U&apos;&#125;; set&lt;char&gt; vowels(vowel,vowel+sizeof(vowel)/sizeof(char)); string res(s.size(),&apos;\0&apos;); while(i&lt;=j)&#123; if(vowels.find(s[i])==vowels.end()) res[i++]=s[i]; else if(vowels.find(s[j])==vowels.end()) res[j--]=s[j]; else&#123; res[i]=s[j]; res[j]=s[i]; i++;j--; &#125; &#125; return res; &#125;&#125;; 回文字符串 680.Valid PalindromeInput: “abca”Output: TrueExplanation: You could delete the character ‘c’. 题目描述：可以删除一个字符，判断是否能构成回文字符串。 解题思路：允许删除一个字符，当遇到不匹配的时候，要么删除左边的字符，要么删除右边的字符，都要遍历一遍，只要有一种能返回true，结果就返回true。可以写一个子函数来判断字符串中的某个范围内的子字符串是否为回文串。 123456789101112131415161718192021class Solution &#123;public: bool validPalindrome(string s) &#123; int i=0,j=s.size()-1; while(i&lt;j)&#123; if(s[i]!=s[j]) return isValid(s,i+1,j)||isValid(s,i,j-1); i++;j--; &#125; return true; &#125;private: bool isValid(string s,int i,int j)&#123; while(i&lt;j)&#123; if(s[i++]!=s[j--]) return false; &#125; return true; &#125;&#125;; 归并两个有序数组 88.Merge Sorted ArrayInput:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3Output: [1,2,2,3,5,6] 题目描述：把归并结果存到第一个数组上。解题思路：题目中说了num1数组有足够的空间，不用resize数组，已知混合之后的数组的大小，这样从nums1和nums2数组的末尾开始一个一个比较，把较大的数按顺序从后往前加入混合之后的数组末尾。需要三个变量i、j、k，分别指向nums1、nums2和混合数组的末尾。进行while循环，如果i和j都大于0，再看如果nums1[i]&gt;nums[j],说明要先把nums1[i]先加入混合数组的末尾，加入后k和i均自减1；反之把nums2[j]加入混合数组末尾，加入后k和j均自减1。循环结束后，有可能i或j还大于0，若j大于0，则需要继续循环将nums2中的数组继续拷贝到nums1；若i大于0，那么就不用管了。 1234567891011121314class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int i=m-1,j=n-1,k=m+n-1; while(i&gt;=0&amp;&amp;j&gt;=0)&#123; if(nums1[i]&gt;nums2[j]) nums1[k--]=nums1[i--]; else nums1[k--]=nums2[j--]; &#125; while(j&gt;=0) nums1[k--]=nums2[j--]; &#125;&#125;; 判断链表是否存在环 141.Linked List Circle使用快慢指针，一个指针移动一个节点，一个指针移动两个节点，若存在环，那么两指针一定相遇。12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head==NULL||head-&gt;next==NULL) return false; ListNode *slow=head,*fast=head; while(fast-&gt;next!=NULL&amp;&amp;fast-&gt;next-&gt;next!=NULL)&#123; slow=slow-&gt;next; fast=fast-&gt;next-&gt;next; if(fast==slow) return true; &#125; return false; &#125;&#125;; 判断是否为子序列 392.Is Subsequence(Medium)s = “abc”, t = “ahbgdc”Return true. 解题思路：两个指针分别指向字符串s和t，如果字符相等，则i和j自增1，否则j自增1，，看最后i是否等于s的长度；若等于说明s已经遍历完了，且字符都在t中出现过。123456789101112class Solution &#123;public: bool isSubsequence(string s, string t) &#123; int i=0; for(int j=0;i&lt;s.size()&amp;&amp;j&lt;t.size();j++)&#123; if(s[i]==t[j]) i++; &#125; return i==s.size(); &#125;&#125;; 最长子序列 524.Longest Word in Dictionary through DeletingInput:s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]Output:“apple” 题目描述：删除s中的一些字符，使得它构成的字符串列表d中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。解题思路：判断s删除一些字符后，是否存在于字典中，用i、j分别表示字符串和单词中某个字母的位置；遍历给定字符串，若遍历到单词中的某个字母，则j自增1，如果没有，则继续往下遍历。这样如果最后i和单词长度相等，则说明单词中所有的字母都按顺序出现在字符串s中！找出能构成的最长单词，需要遍历字典中的所有单词，找出长度最长的。 12345678910111213141516171819202122232425class Solution &#123;public: string findLongestWord(string s, vector&lt;string&gt;&amp; d) &#123; string longestWord=&quot;&quot;; for(string target:d)&#123; int l1=longestWord.size(),l2=target.size(); if(l1&gt;l2||(l1==l2&amp;&amp;longestWord.compare(target)&lt;0)) continue; if(isValid(s,target)) longestWord=target; &#125; return longestWord; &#125;private: bool isValid(string s,string target)&#123; int i=0,j=0; while(i&lt;s.size()&amp;&amp;j&lt;target.size())&#123; if(s[i]==target[j]) j++; i++; &#125; return j==target.size(); &#125;&#125;; 补充：字典中的最长单词 720.Lonest Word in DIctionaryInput:words = [“w”,”wo”,”wor”,”worl”, “world”]Output: “world”Explanation:The word “world” can be built one character at a time by “w”, “wo”, “wor”, and “worl”. 解题思路：题目给了一个字符串数组，从单个字符开始拼，最长能构成什么单词，注意中间生成的字符串也要在字典中，而且当组成的单词长度一样时，返回字母序小的那个。使用BFS的做法，使用一个queue来辅助，先把所有长度为1的单词找出来放入queue中，当作初始的单词，然后进行循环，每次从队首取出一个元素，如果长度大于我们维护的最大值mxLen，则更新mxlen和结果，如果相等取字母序小的那个。然后试着增加长度，做法就是遍历26个字母，将每个字母都加到单词后面，然后看是否存在于字典中，存在的话，就入队，等待下一次遍历，增加长度之后记得要恢复原来的状态。 1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestWord(vector&lt;string&gt;&amp; words) &#123; string res=&quot;&quot;; int mxLen=0; unordered_set&lt;string&gt; s(words.begin(),words.end()); queue&lt;string&gt; q; for(string word:words)&#123; if(word.size()==1) q.push(word); &#125; while(!q.empty())&#123; string t=q.front(); q.pop(); if(t.size()&gt;mxLen)&#123; mxLen=t.size(); res=t; &#125;else if(t.size()==mxLen) res=min(res,t); for(char c=&apos;a&apos;;c&lt;=&apos;z&apos;;c++)&#123; t.push_back(c); if(s.find(t)!=s.end())//或者使用count函数 q.push(t); t.pop_back(); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode刷题</category>
      </categories>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.数学形态学运算]]></title>
    <url>%2F2019%2F03%2F25%2FComputerVision%2FOpenCV-ImageProcessing%2F3-Mathematical%20morphology%2F</url>
    <content type="text"><![CDATA[数学形态学运算–腐蚀、膨胀、开运算、闭运算数学形态学操作可以分为二值形态学和灰度形态学，灰度形态学由二值形态学扩展而来，数学形态学有两个基本的运算，腐蚀和膨胀，而腐蚀和膨胀又形成了开运算和闭运算。 二值形态学-通常用于二值图像腐蚀膨胀的作用： 消除噪声 分割出独立的图像元素，在图像中连接相邻的元素 寻找图像中明显的极大值区域或者极小值区域 求出图像的梯度 膨胀– 是图像中的高亮部分进行膨胀，效果图拥有比原图更大的高亮区域；腐蚀– 是原图中的高亮部分被腐蚀，效果图拥有比原图更小的高亮区域。从数学的角度来说腐蚀和膨胀操作就是将图像与核进行卷积，核可以是任意形状和大小的，核大则周围对其影响大，变化大，核小则周围对齐影响小，变化小。 更加高级的形态学变换 开运算–先腐蚀再膨胀，可以用来去掉目标外的孤立点，消除小物体，在纤细处分离物体，并且在平滑较大物体的边界的同时不明显改变其面积。 闭运算–先膨胀再腐蚀，能够去掉目标内的孔，排除小型黑洞。 形态学梯度–就是膨胀图与俯视图之差，用于保留物体的边缘轮廓。 顶帽–原图像与开运算之差，用于分离比邻近点亮一些的斑块。 黑帽–闭运算与原图像之差，用于分离比临近点暗一些的斑块。 1234567891011121314151617181920212223int main()&#123; Mat img = imread(&quot;alita.png&quot;); Mat out1, out2,out3,out4,out5; //MORPH_RECT表示矩形的卷积核，当然也可以选择椭圆形、交叉型的 Mat element = getStructuringElement(MORPH_RECT, Size(10, 10)); dilate(img, out1, element); erode(img, out2, element); //高级形态学处理，调用这个函数就可以了，具体选择哪种操作，直接修改第三个参数 morphologyEx(img, out3, MORPH_GRADIENT, element); morphologyEx(img, out4, MORPH_TOPHAT, element); morphologyEx(img, out5, MORPH_BLACKHAT, element); imshow(&quot;原图&quot;, img); imshow(&quot;膨胀操作&quot;, out1); imshow(&quot;腐蚀操作&quot;, out2); imshow(&quot;形态学梯度&quot;, out3); imshow(&quot;顶帽&quot;, out4); imshow(&quot;黑帽&quot;, out5); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>腐蚀</tag>
        <tag>膨胀</tag>
        <tag>开闭运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.Filter]]></title>
    <url>%2F2019%2F03%2F25%2FComputerVision%2FOpenCV-ImageProcessing%2F2-Filter%2F</url>
    <content type="text"><![CDATA[OpenCV基本滤波算法分类及作用 线性滤波 方框滤波：模糊图像 均值滤波：模糊图像 高斯滤波：信号的平滑处理，去除符合正态分布的噪声 非线性滤波 中值滤波：去除椒盐噪声 双边滤波：保边去噪 OpenCV中的函数调用1.方框滤波void boxFilter(InputArray src,OutputArray dst, int ddepth, Size ksize, Point anchor=Point(-1,-1), boolnormalize=true, int borderType=BORDER_DEFAULT )用一个像素的领域像素值之和作为滤波结果，邻域即模板所覆盖的图像区域，此时模板的所有系数都为1. 源图像可以是彩色图或者是灰度图,因为图像处理的时候,通道是分开来处理的 目的图像的大小和通道数必须和源图像相同 int类型的ddepth，输出图像的深度，-1代表使用原图深度，即src.depth()。 Size类型（对Size类型稍后有讲解）的ksize，内核的大小 Point类型的anchor，表示锚点（即被平滑的那个点），注意它有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。 bool类型的normalize，默认值为true，一个标识符，表示内核是否被其区域归一化（normalized）了。 int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，我们一般不去管它。 其中f表示原图，h表示核，g表示目标图，当normalize=true的时候，方框滤波就变成了我们熟悉的均值滤波。也就是说，均值滤波是方框滤波归一化（normalized）后的特殊情况。其中，归一化就是把要处理的量都缩放到一个范围内,比如(0,1)，以便统一处理和直观量化. 2.均值滤波void blur(InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT )均值滤波就是方框滤波的一个特殊情况，blur函数内部中其实就是调用了一下boxFilter,均值滤波的特点就是不能很好的保护细节，在图像去噪的同时也破坏了图像的细节部分，从而使图像变得模糊，不能很好的去除噪点。 src,输入图像。该函数对通道是独立处理的,且可以处理任意通道数的图片，但需要注意，待处理的图片深度应该为CV_8U, CV_16U, CV_16S, CV_32F 以及 CV_64F之一。 dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。 Size类型的ksize，内核的大小。一般这样写Size(w,h)来表示内核的大小(其中，w 为像素宽度,h为像素高度)。Size（3,3）就表示3x3的核大小，Size（5,5）就表示5x5的核大小 Point类型的anchor，表示锚点（即被平滑的那个点），注意他有默认值Point(-1,-1)。如果这个点坐标是负值的话，就表示取核的中心为锚点，所以默认值Point(-1,-1)表示这个锚点在核的中心。 int类型的borderType，用于推断图像外部像素的某种边界模式。有默认值BORDER_DEFAULT，一般不去管它。 3.高斯滤波void GaussianBlur(InputArray src, OutputArray dst, Size ksize, double sigmaX, double sigmaY=0, int borderType=BORDER_DEFAULT)高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。从数学的角度来看，图像的高斯模糊过程就是图像与正态分布做卷积。由于正态分布又叫作高斯分布，所以这项技术就叫作高斯模糊。 src，输入图像，即源图像，填Mat类的对象即可。它可以是单独的任意通道数的图片，但需要注意，图片深度应该为CV_8U,CV_16U, CV_16S, CV_32F 以及 CV_64F之一。 dst，即目标图像，需要和源图片有一样的尺寸和类型。比如可以用Mat::Clone，以源图片为模板，来初始化得到如假包换的目标图。 ksize，高斯内核的大小。其中ksize.width和ksize.height可以不同，但他们都必须为正数和奇数。或者，它们可以是零的，它们都是由sigma计算而来。 sigmaX，表示高斯核函数在X方向的的标准偏差。 sigmaY，表示高斯核函数在Y方向的的标准偏差。若sigmaY为零，就将它设为sigmaX，如果sigmaX和sigmaY都是0，那么就由ksize.width和ksize.height计算出来。 4.中值滤波void medianBlur(InputArray src, OutputArray dst, int ksize)基本思想就是用像素点的邻域灰度的中值来代替该像素点的灰度值，该方法在去除脉冲噪声、椒盐噪声的同时又能保留图像的细节，不会出现边缘模糊的情况。中值滤波跟均值滤波的思想看起来很相似，只是一个取平均值，一个取中位数而已 第一个参数，InputArray类型的src，函数的输入参数，填1、3或者4通道的Mat类型的图像；当ksize为3或者5的时候，图像深度需为CV_8U，CV_16U，或CV_32F其中之一，而对于较大孔径尺寸的图片，它只能是CV_8U。 第二个参数，OutputArray类型的dst，需要和源图片有一样的尺寸和类型。 第三个参数，int类型的ksize，孔径的线性尺寸（aperture linear size），注意这个参数必须是大于1的奇数，比如：3，5，7，9 … 中值滤波与均值滤波的比较：均值滤波中噪声成分会被加入到平均计算，所以输出是受到噪声的影响的。但是中值滤波中，由于噪声成分很难选上，所以基本不影响输出。当然好的性能也需要付出一点代价的，中值滤波花费的时间是均值滤波的5倍以上 5.双边滤波void bilateralFilter(InputArray src, OutputArray dst, int d,double sigmaColor,double sigmaSpace,int borderType=BORDER_DEFAULT )双边滤波的最大特点就是做边缘保护。 InputArray src: 输入图像，可以是Mat类型，图像必须是8位或浮点型单通道、三通道的图像。 OutputArray dst: 输出图像，和原图像有相同的尺寸和类型。.- int d: 表示在过滤过程中每个像素邻域的直径范围。如果这个值是非正数，则函数会从第五个参数sigmaSpace计算该值。 double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值越大，表明该像素邻域内有越宽广的颜色会被混合到一起，产生较大的半相等颜色区域。 double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着颜色相近的较远的像素将相互影响，从而使更大的区域中足够相似的颜色获取相同的颜色。当d&gt;0时，d指定了邻域大小且与sigmaSpace五官，否则d正比于sigmaSpace. int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT 123456789101112131415161718int mainfilter()&#123; Mat img = imread(&quot;alita.png&quot;); Mat out1,out2,out3,out4,out5; boxFilter(img, out1, -1, Size(3, 3)); blur(img, out2, Size(3, 3)); GaussianBlur(img, out3, Size(3, 3), 0, 0); medianBlur(img, out4, 5); bilateralFilter(img, out5, 25, 25 * 2, 25 / 2); imshow(&quot;原图&quot;, img); imshow(&quot;方框滤波&quot;, out1); imshow(&quot;均值滤波&quot;, out2); imshow(&quot;高斯滤波&quot;, out3); imshow(&quot;中值滤波&quot;, out4); imshow(&quot;双边滤波&quot;, out5); waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>图像滤波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.imageBasicOperation]]></title>
    <url>%2F2019%2F03%2F24%2FComputerVision%2FOpenCV-ImageProcessing%2F1-imageBasicOperation%2F</url>
    <content type="text"><![CDATA[OpenCV Mat类型定义和赋值cv::Mat img(height,width,例：cv::Mat M(480,640,CV_8UC3，Scalar(255,0,0)); 表示定义了一个480行640列的矩阵，矩阵的每个单元的由三个(C3:3 Channel)8位无符号整形(U Unsigned U8 8位)构成,Scalar(255,0,0)表示给每个单元赋值。 123456789101112131415161718192021222324252627282930313233#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char **argv)&#123; //这些方式都是自己拥有独立的内存空间 Mat img1(3, 3, CV_8UC3, Scalar(255, 0, 0)); cout &lt;&lt; img1&lt;&lt;esndl; int sz[3] = &#123; 2, 2, 2 &#125;; Mat img2(3, 3, CV_8UC1, Scalar(200, 0, 255));//单通道的化只会赋值第一个值 cout &lt;&lt; img2 &lt;&lt; endl; Mat img3; img3.create(4, 4, CV_8UC3); cout &lt;&lt; img3 &lt;&lt; endl; Mat img4 = Mat::zeros(4, 4, CV_8UC3); Mat img5 = img4.clone(); Mat img6; img4.copyTo(img6); //clone和copyto函数，这是图像的深拷贝，相当于重新创建了一份一模一样的图像 //下面都是浅拷贝，指针指向同一个实例 Mat img7 = img6; Mat img8(img6); waitKey(0); return 0;&#125; 图像二值化操作threshold —— 简单的阈值操作def threshold(src, dst,thresh, maxval,thresholdType) thresh：Double类型的，具体的阈值 maxval：Double类型的，阈值的最大值 thresholdType: THRESH_BINARY 二进制阈值化 -&gt; 大于阈值为1 小于阈值为0 THRESH_BINARY_INV 反二进制阈值化 -&gt; 大于阈值为0 小于阈值为1 THRESH_TRUNC 截断阈值化 -&gt; 大于阈值为阈值，小于阈值不变 THRESH_TOZERO 阈值化为0 -&gt; 大于阈值的不变，小于阈值的全为0 THRESH_TOZERO_INV 反阈值化为0 -&gt; 大于阈值为0，小于阈值不变 adaptiveThreshold —— 自适应阈值操作def adaptiveThreshold(src,dst,maxValue,adaptiveMethod,thresholdType,blockSize,C) maxval：Double类型的，阈值的最大值 adaptiveMethod： ADAPTIVE_THRESH_MEAN_C（通过平均的方法取得平均值)ADAPTIVE_THRESH_GAUSSIAN_C(通过高斯取得高斯值) thresholdType同上 blockSize：Int类型的，这个值来决定像素的邻域块有多大（这里的blockSize的值要为奇数，否则会给出这样的提示：Assertion failed (blockSize % 2 == 1 &amp;&amp; blockSize &gt; 1) in cv::adaptiveThreshold ） C：偏移值调整量，计算adaptiveMethod用到的参数 总结： 在两种情况下，自适应阈值T(x, y)。通过计算每个像素周围bxb大小像素块的加权均值并减去常量C得到。其中，b由blockSize给出，大小必须为奇数；如果使用平均的方法，则所有像素周围的权值相同；如果使用高斯的方法，则（x,y）周围的像素的权值则根据其到中心点的距离通过高斯方程得到。 12345678910111213141516171819202122232425262728#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;int main(int argc, char **argv)&#123; Mat img = imread(&quot;groot.jpg&quot;, CV_LOAD_IMAGE_GRAYSCALE);//载入灰度图 if (img.empty())&#123; cout &lt;&lt; &quot;read img falied!\n&quot;; return -1; &#125; //全局二值化 int th = 150; Mat global; threshold(img, global, th, 255, CV_THRESH_BINARY); //局部二值化 int blockSize = 25; int constValue = 10; Mat local; adaptiveThreshold(img, local, 255, CV_ADAPTIVE_THRESH_MEAN_C, CV_THRESH_BINARY, blockSize, constValue); imshow(&quot;原图&quot;, img); imshow(&quot;全局二值化&quot;, global); imshow(&quot;局部二值化&quot;, local); waitKey(0); return 0;&#125; 运行结果如下： 访问图片中的像素①指针访问：最快 ②迭代器iterator：较慢，非常安全，指针访问可能出现越界问题 ③动态地址计算：更慢，通过at()实现。适用于访问具体某个第i行，j列的像素，而不适用遍历像素 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;opencv2\opencv.hpp&gt;#include&lt;opencv2\highgui\highgui.hpp&gt;using namespace std;using namespace cv;void visitByPointer(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); int rows = dstImg.rows; int cols = dstImg.cols*dstImg.channels(); for (int i = 0; i &lt; rows; i++) &#123; uchar *data = dstImg.ptr&lt;uchar&gt;(i);//获取第i行地址 for (int j = 0; j &lt; cols; j++)&#123; data[j] += 10; //add code 处理每一个像素 &#125; &#125;&#125;void visitByIterator(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); const int chanels = dstImg.channels(); switch (chanels) &#123; case 1:&#123; Mat_&lt;uchar&gt;::iterator it = dstImg.begin&lt;uchar&gt;(); Mat_&lt;uchar&gt;::iterator itend = dstImg.end&lt;uchar&gt;(); for (; it != itend;it++) &#123; *it += 10;//处理每个像素 &#125;break; &#125; case 3:&#123; Mat_&lt;Vec3d&gt;::iterator it3 = dstImg.begin&lt;Vec3d&gt;(); Mat_&lt;Vec3d&gt;::iterator it3end = dstImg.end&lt;Vec3d&gt;(); for (; it3 != it3end;it3++) &#123; (*it3)[0] += 10; (*it3)[1] -= 10; (*it3)[2] -= 10; &#125;break; &#125; default: break; &#125;&#125;void visitByAt(Mat &amp;srcImg,Mat &amp;dstImg)&#123; dstImg = srcImg.clone(); int rows = dstImg.rows; int cols = dstImg.cols; int channels = dstImg.channels(); switch (channels) &#123; case 1:&#123; for (int i = 0; i &lt; rows;i++) &#123; for (int j = 0; j &lt; cols;j++) &#123; dstImg.at&lt;uchar&gt;(i, j) += 10; &#125; &#125;break; &#125; case 3:&#123; for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; dstImg.at&lt;Vec3d&gt;(i, j)[0] += 10; dstImg.at&lt;Vec3d&gt;(i, j)[1] -= 10; dstImg.at&lt;Vec3d&gt;(i, j)[2] -= 10; &#125; &#125;break; &#125; default: break; &#125;&#125;int main(int argc, char **argv)&#123; Mat img = imread(&quot;Lena.png&quot;); Mat dstImg1,dstImg2,dstImg3; visitByPointer(img, dstImg1); visitByIterator(img, dstImg2); //visitByAt(img, dstImg3); imshow(&quot;原图&quot;, img); imshow(&quot;指针访问&quot;, dstImg1); imshow(&quot;迭代器访问&quot;, dstImg2); //imshow(&quot;at访问&quot;, dstImg3); waitKey(0); return 0;&#125; 常用的数据结构12345678910111213141516171819202122232425262728293031323334353637int main(int argc,char** argv)&#123; Mat m1(3, 3, CV_8UC3, Scalar(255, 0, 0));//其中宏的解释：CV_[位数][带符号与否][类型前缀]C[通道数] cout &lt;&lt; m1 &lt;&lt; endl;//输出的就是3*9的矩阵 //或者利用IplImage指针来初始化，将IplImage*转化为Mat IplImage* img = cvLoadImage(&quot;Lena.png&quot;); Mat m2 = cvarrToMat(img); //Mat转IplImage IplImage img2 = IplImage(m2); Mat m3; m3.create(3, 3, CV_8UC(2)); cout &lt;&lt; m3 &lt;&lt; endl; //点的表示 Point p1; p1.x = 1; p1.y = 1; //或者 Point p2(1, 1); //颜色的表示：Scalar(b,g,r) Scalar(1, 1, 1) ; //尺寸的表示：Size Size(2,3);//宽和高 //矩形的表示：Rect，成员变量有x、y、width、height Rect r1(0, 0, 100, 200); Rect r2(10, 10, 100, 200); Rect r3 = r1 | r2;//两个矩形求交集 Rect r4 = r1 &amp; r2;//两个矩形求并集 waitKey(0); return 0;&#125;]]></content>
      <tags>
        <tag>Mat初始化</tag>
        <tag>访问像素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路径中斜杠和反斜杠的区别]]></title>
    <url>%2F2019%2F03%2F24%2F%E9%9A%8F%E7%AC%94%2F%E8%B7%AF%E5%BE%84%E4%B8%AD%E6%96%9C%E6%9D%A0%E5%92%8C%E5%8F%8D%E6%96%9C%E6%9D%A0%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Unix使用斜杠/ 作为路径分隔符，而web应用最新使用在Unix系统上面，所以目前所有的网络地址都采用斜杠/ 作为分隔符; Windows由于使用斜杠/作为DOS命令提示符的参数标志了，为了不混淆，所以采用反斜杠\作为路径分隔符。所以目前Windows系统上的文件目录结构都是用反斜杠\作为路径分隔符。随着发展，DOS系统已经被淘汰了，命令提示符用的很少，斜杠和反斜杠在大多数情况下可以互换。 总结: 浏览器地址栏网址使用斜杠/ Windows文件目录结构地址使用反斜杠\ 出现heml url()属性中的路径，指定的路径是网络路径，所以必须用斜杠/ 出现在普通字符串中的路径，如果代表的是Windows文件路径，则使用斜杠和反斜杠是一样的，如果代表的是网络文件路径，则必须使用斜杠/ 上面提到斜杠/是url地址中用到的分隔符；对应的，双斜杠//用在网络域名访问中，是协议和主机名或IP地址之间的分隔符，以双斜杠//开头的是一俩url是依赖协议的url表示形式，URL格式：协议://域名或IP/请求文件路径/文件名；如百度的网址：https://www.baidu.com/ 。URL默认以斜杠/结尾，而没有给出文件名的情况下，URL引用路径中最后一个目录中的默认文件(通常对应于主页). 反斜杠是Windows系统文件目录结构使用的分隔符，如：D:\allDream(用反斜杠也可以，但是双斜杠或双反斜杠不行)。对应的，双反斜杠\在Windows里表示绝对地址的第一项，后面跟IP地址或计算机名，就是需要打开这个IP地址或计算机名对应主机的网络共享资源。]]></content>
      <tags>
        <tag>Node</tag>
        <tag>路径分隔符/&amp;\</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-TwoSum]]></title>
    <url>%2F2019%2F03%2F22%2FLeetCode%E5%88%B7%E9%A2%98%2FLeetCode-TwoSum%2F</url>
    <content type="text"><![CDATA[1.Two Sum (1)Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解题思路 定义一个unordered_map变量record，用于保存遍历过的元素的下标； 遍历数组的每一个元素，如果target减去nums[i]的值在record中，则直接返回两个下标，否则将该元素插入到record中，继续循环； 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int,int&gt; record; for(int i=0;i&lt;nums.size();i++)&#123; int complement=target-nums[i]; if(record.find(complement)!=record.end())&#123; int res[]=&#123;record[complement],i&#125;; return vector&lt;int&gt; &#123;res,res+2&#125;; &#125; record[nums[i]]=i; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; Two Sum II (167)这道题目和剑指offer上”和为s的两个数字”是一样的。 Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Note: Your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice.Example: Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2. 解法一：暴力+二分搜索给定的数组有序，而且题目中限定一定有解，那么可以使用两层循环进行暴力求解，外层循环遍历数组，作为第一个元素，然后内层循环使用二分法来搜索target-numbers[i]即可。时间复杂度为O(nlogn).12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; for(int i=0;i&lt;numbers.size();i++)&#123; int t=target-numbers[i],left=i+1,right=numbers.size()-1; while(left&lt;=right)&#123; int mid=(left+right)/2; if(numbers[mid]==t) return vector&lt;int&gt; &#123;i+1,mid+1&#125;; else if(numbers[mid]&lt;t) left=mid+1; else right=mid-1; &#125; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 解法二：对撞指针需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加刚好等于target，直接返回两个指针的位置，若小于target，左指针右移，若大于target，有指针左移，以此类推直到两个指针相遇停止。时间复杂度为O(n).123456789101112131415161718// 对撞指针// Time：O(n)// Space:O(1)class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int i=0,j=numbers.size()-1; while(i&lt;j)&#123; if(numbers[i]+numbers[j]==target) return vector&lt;int&gt; &#123;i+1,j+1&#125;; else if(numbers[i]+numbers[j]&lt;target) i++; else j--; &#125; return vector&lt;int&gt; &#123;&#125;; &#125;&#125;; 和为s的连续正整数序列要求计算出9~16的和,写出正确答案是100。究竟有多少种连续的正数序列的和为100(至少包括两个数)。另一组连续正数和为100的序列:18,19,20,21,22。现有问题如下,能不能也很快的找出所有和为S的连续正数序列? 输出所有和为S的正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。 方法一：暴力求解——滑动窗口思想将序列(1, 2)作为初始序列，small表示序列的第一个，big表示序列的最后一个。如果序列中和小于所求值，序列的big往前走一个从而把一个更大的数包括到序列中；如果序列中和小于所求值，small往前走一个把原来序列中最小的数排除出去。如果相等，打印出当前序列，big继续往前走一个，来寻找新的序列。一直到big大于等于所求和的一半了，遍历就停止了。 整个思路就像模拟了一个窗口在变化，这种方法本质上依然是贪心，不过是首位双指针的贪心。123456789101112131415161718192021222324252627282930313233//牛客网上的解决方案class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(sum&lt;3) return res; int small=1,big=2; int mid=(1+sum)&gt;&gt;1; int curSum=small+big; while(small&lt;mid)&#123; if(curSum==sum) InsertRes(small,big,res); while(curSum&gt;sum&amp;&amp;small&lt;mid)&#123; curSum-=small; small++; if(curSum==sum)&#123; InsertRes(small,big,res); &#125; &#125; big++; curSum+=big; &#125; return res; &#125;private: void InsertRes(int begin,int end,vector&lt;vector&lt;int&gt; &gt; &amp;res)&#123; vector&lt;int&gt; temp; for(int i = begin;i&lt;=end;i++) temp.push_back(i); res.push_back(temp); &#125;&#125;;]]></content>
      <tags>
        <tag>LeetCode刷题</tag>
        <tag>窗口思想</tag>
        <tag>中位数法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法小结]]></title>
    <url>%2F2019%2F03%2F22%2FMarkDown%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[MarkDown修改字体颜色用代码进行更改字体颜色，还可以修改字体大小、字体格式等 。1234567891011121314&lt;font 更改语法&gt; 你的内容 &lt;/font&gt;更改语法有: color=#0099ff 更改字体颜色face=&quot;黑体&quot; 更改字体size= 7 更改字体大小 &lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=7 face=&quot;黑体&quot;&gt;color=#0099ff size=72 face=&quot;黑体&quot;&lt;/font&gt;&lt;font color=#00ffff size=72&gt;color=#00ffff&lt;/font&gt;&lt;font color=gray size=72&gt;color=gray&lt;/font&gt; 常用颜色表：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145颜色名 十六进制颜色值 颜色AliceBlue #F0F8FF rgb(240, 248, 255)AntiqueWhite #FAEBD7 rgb(250, 235, 215)Aqua #00FFFF rgb(0, 255, 255)Aquamarine #7FFFD4 rgb(127, 255, 212)Azure #F0FFFF rgb(240, 255, 255)Beige #F5F5DC rgb(245, 245, 220)Bisque #FFE4C4 rgb(255, 228, 196)Black #000000 rgb(0, 0, 0)BlanchedAlmond #FFEBCD rgb(255, 235, 205)Blue #0000FF rgb(0, 0, 255)BlueViolet #8A2BE2 rgb(138, 43, 226)Brown #A52A2A rgb(165, 42, 42)BurlyWood #DEB887 rgb(222, 184, 135)CadetBlue #5F9EA0 rgb(95, 158, 160)Chartreuse #7FFF00 rgb(127, 255, 0)Chocolate #D2691E rgb(210, 105, 30)Coral #FF7F50 rgb(255, 127, 80)CornflowerBlue #6495ED rgb(100, 149, 237)Cornsilk #FFF8DC rgb(255, 248, 220)Crimson #DC143C rgb(220, 20, 60)Cyan #00FFFF rgb(0, 255, 255)DarkBlue #00008B rgb(0, 0, 139)DarkCyan #008B8B rgb(0, 139, 139)DarkGoldenRod #B8860B rgb(184, 134, 11)DarkGray #A9A9A9 rgb(169, 169, 169)DarkGreen #006400 rgb(0, 100, 0)DarkKhaki #BDB76B rgb(189, 183, 107)DarkMagenta #8B008B rgb(139, 0, 139)DarkOliveGreen #556B2F rgb(85, 107, 47)Darkorange #FF8C00 rgb(255, 140, 0)DarkOrchid #9932CC rgb(153, 50, 204)DarkRed #8B0000 rgb(139, 0, 0)DarkSalmon #E9967A rgb(233, 150, 122)DarkSeaGreen #8FBC8F rgb(143, 188, 143)DarkSlateBlue #483D8B rgb(72, 61, 139)DarkSlateGray #2F4F4F rgb(47, 79, 79)DarkTurquoise #00CED1 rgb(0, 206, 209)DarkViolet #9400D3 rgb(148, 0, 211)DeepPink #FF1493 rgb(255, 20, 147)DeepSkyBlue #00BFFF rgb(0, 191, 255)DimGray #696969 rgb(105, 105, 105)DodgerBlue #1E90FF rgb(30, 144, 255)Feldspar #D19275 rgb(209, 146, 117)FireBrick #B22222 rgb(178, 34, 34)FloralWhite #FFFAF0 rgb(255, 250, 240)ForestGreen #228B22 rgb(34, 139, 34)Fuchsia #FF00FF rgb(255, 0, 255)Gainsboro #DCDCDC rgb(220, 220, 220)GhostWhite #F8F8FF rgb(248, 248, 255)Gold #FFD700 rgb(255, 215, 0)GoldenRod #DAA520 rgb(218, 165, 32)Gray #808080 rgb(128, 128, 128)Green #008000 rgb(0, 128, 0)GreenYellow #ADFF2F rgb(173, 255, 47)HoneyDew #F0FFF0 rgb(240, 255, 240)HotPink #FF69B4 rgb(255, 105, 180)IndianRed #CD5C5C rgb(205, 92, 92)Indigo #4B0082 rgb(75, 0, 130)Ivory #FFFFF0 rgb(255, 255, 240)Khaki #F0E68C rgb(240, 230, 140)Lavender #E6E6FA rgb(230, 230, 250)LavenderBlush #FFF0F5 rgb(255, 240, 245)LawnGreen #7CFC00 rgb(124, 252, 0)LemonChiffon #FFFACD rgb(255, 250, 205)LightBlue #ADD8E6 rgb(173, 216, 230)LightCoral #F08080 rgb(240, 128, 128)LightCyan #E0FFFF rgb(224, 255, 255)LightGoldenRodYellow #FAFAD2 rgb(250, 250, 210)LightGrey #D3D3D3 rgb(211, 211, 211)LightGreen #90EE90 rgb(144, 238, 144)LightPink #FFB6C1 rgb(255, 182, 193)LightSalmon #FFA07A rgb(255, 160, 122)LightSeaGreen #20B2AA rgb(32, 178, 170)LightSkyBlue #87CEFA rgb(135, 206, 250)LightSlateBlue #8470FF rgb(132, 112, 255)LightSlateGray #778899 rgb(119, 136, 153)LightSteelBlue #B0C4DE rgb(176, 196, 222)LightYellow #FFFFE0 rgb(255, 255, 224)Lime #00FF00 rgb(0, 255, 0)LimeGreen #32CD32 rgb(50, 205, 50)Linen #FAF0E6 rgb(250, 240, 230)Magenta #FF00FF rgb(255, 0, 255)Maroon #800000 rgb(128, 0, 0)MediumAquaMarine #66CDAA rgb(102, 205, 170)MediumBlue #0000CD rgb(0, 0, 205)MediumOrchid #BA55D3 rgb(186, 85, 211)MediumPurple #9370D8 rgb(147, 112, 216)MediumSeaGreen #3CB371 rgb(60, 179, 113)MediumSlateBlue #7B68EE rgb(123, 104, 238)MediumSpringGreen #00FA9A rgb(0, 250, 154)MediumTurquoise #48D1CC rgb(72, 209, 204)MediumVioletRed #C71585 rgb(199, 21, 133)MidnightBlue #191970 rgb(25, 25, 112)MintCream #F5FFFA rgb(245, 255, 250)MistyRose #FFE4E1 rgb(255, 228, 225)Moccasin #FFE4B5 rgb(255, 228, 181)NavajoWhite #FFDEAD rgb(255, 222, 173)Navy #000080 rgb(0, 0, 128)OldLace #FDF5E6 rgb(253, 245, 230)Olive #808000 rgb(128, 128, 0)OliveDrab #6B8E23 rgb(107, 142, 35)Orange #FFA500 rgb(255, 165, 0)OrangeRed #FF4500 rgb(255, 69, 0)Orchid #DA70D6 rgb(218, 112, 214)PaleGoldenRod #EEE8AA rgb(238, 232, 170)PaleGreen #98FB98 rgb(152, 251, 152)PaleTurquoise #AFEEEE rgb(175, 238, 238)PaleVioletRed #D87093 rgb(216, 112, 147)PapayaWhip #FFEFD5 rgb(255, 239, 213)PeachPuff #FFDAB9 rgb(255, 218, 185)Peru #CD853F rgb(205, 133, 63)Pink #FFC0CB rgb(255, 192, 203)Plum #DDA0DD rgb(221, 160, 221)PowderBlue #B0E0E6 rgb(176, 224, 230)Purple #800080 rgb(128, 0, 128)Red #FF0000 rgb(255, 0, 0)RosyBrown #BC8F8F rgb(188, 143, 143)RoyalBlue #4169E1 rgb(65, 105, 225)SaddleBrown #8B4513 rgb(139, 69, 19)Salmon #FA8072 rgb(250, 128, 114)SandyBrown #F4A460 rgb(244, 164, 96)SeaGreen #2E8B57 rgb(46, 139, 87)SeaShell #FFF5EE rgb(255, 245, 238)Sienna #A0522D rgb(160, 82, 45)Silver #C0C0C0 rgb(192, 192, 192)SkyBlue #87CEEB rgb(135, 206, 235)SlateBlue #6A5ACD rgb(106, 90, 205)SlateGray #708090 rgb(112, 128, 144)Snow #FFFAFA rgb(255, 250, 250)SpringGreen #00FF7F rgb(0, 255, 127)SteelBlue #4682B4 rgb(70, 130, 180)Tan #D2B48C rgb(210, 180, 140)Teal #008080 rgb(0, 128, 128)Thistle #D8BFD8 rgb(216, 191, 216)Tomato #FF6347 rgb(255, 99, 71)Turquoise #40E0D0 rgb(64, 224, 208)Violet #EE82EE rgb(238, 130, 238)VioletRed #D02090 rgb(208, 32, 144)Wheat #F5DEB3 rgb(245, 222, 179)White #FFFFFF rgb(255, 255, 255)WhiteSmoke #F5F5F5 rgb(245, 245, 245)Yellow #FFFF00 rgb(255, 255, 0)YellowGreen #9ACD32 rgb(154, 205, 50)]]></content>
      <tags>
        <tag>Node</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法_递归]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[1.如何理解”递归”？当你在电影院看电影时忘记自己是在第几排，电影院里面太黑看不清，没法数，于是就问前面的人他是第几排，你想只要在他的数字上加1，就知道自己是在哪一排了；但是前面的人也看不清啊，所以他也问他前面的人…就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排把数字传回来，于是你就知道答案了。这就是一个非常标准的递归求解问题的分解过程，去的过程叫”递”，回来的过程叫”归”。基本上，所有的递归问题都可以用递推公式来表示。12f(n)=f(n-1)+1 其中，f(1)=1 2.递归需要满足的三个条件2.1 一个问题的解可以分解为几个子问题的解子问题就是数据规模更小的问题。比如，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。 2.2 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样你在求解“自己在哪一排”的思路，和前一排的人求解“自己在哪一排”的思路是一模一样的。 2.3 存在递归终止条件写递归代码最关键的是写出递推公式，找到终止条件。举个例子：假如这里有n个台阶，每次可以跨1个台阶或2个台阶，请问走完这n个台阶有多少种走法？可以这样思考：走到第n个台阶的走法有两类，第一类是从第n-1阶走了1个台阶，另一类是从n-2阶走了2个台阶。所以n个台阶的走法就等于:(走n-1阶的走法，再走1个台阶)+(走n-2阶的走法，再走2个台阶)，用公式表示就是：1f(n)=f(n-1)+f(n-2) 来看终止条件：当有一个台阶时，就只有一种走法 ，所以f(1)=1。如果递归终止条件只有f(1)=1一个，那f(2)就没法求解了，所以我们可以把f(2)=2作为另一个终止条件。123f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2) 最终的递归代码：12345int f(int n) &#123; if (n == 1) return 1; if (n == 2) return 2; return f(n-1) + f(n-2);&#125; 总结： 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。编写递归代码的关键是，只要遇到递归，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 3.递归代码要警惕堆栈溢出函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完返回时，才出栈。系统栈或则虚拟机栈空间一般都不大，如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。 4.递归代码要警惕重复计算上述第二个递归例子，如果把整个过程分解一下，如图所示：从图中可以发现，计算f(5)时，要先计算f(4)和f(3),而计算f(4)时还需要计算f(3),因此f(3)被计算了很多次，这就是重复计算问题。重复子问题可以用数组保存中间值的方法来优化，之后动态规划问题会用到这类思想。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——把数组排成最小的数]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。时间限制：1秒 空间限制：32768K 解题思路 将数组中的整数数组转换成字符串数组； 自定义一个比较大小的函数，比较两个字符串s1和s2大小的时候，先将它们拼起来，比较s1+s2和s2和s1哪个大，如果s1+s2大，说明s2应该放前面，根据这个规则将所有的字符换排序； 拼接所有的字符串数组中的元素。 123456789101112131415161718class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string res; vector&lt;string&gt; str; for(int i=0;i&lt;numbers.size();i++) str.push_back(to_string(numbers[i])); sort(str.begin(),str.end(),myCompare); for(int i=0;i&lt;str.size();i++) res+=str[i]; return res; &#125;private: static bool myCompare(string &amp;s1,string &amp;s2)&#123; return s1+s2 &lt; s2+s1; &#125;&#125;; tips：1. sort()函数的第三个参数自定义的比较函数返回值类型应该是static bool，不然会报错,但是在其他编译器中只要自定义函数返回的是bool类型的就可以了，没必要是静态函数。 ./solution.h:8:36: error: reference to non-static member function must be calledsort(str.begin(),str.end(),myCompare); 2. 深究STL的sort()函数以前在自定义比较函数时一直都有个疑问，当什么情况下会进行升序排列、什么情况下又进行降序排列呢？传入的两个参数应该如何进行比较？在这里推荐直接看C++技术文档 comp函数返回值：返回一个bool类型的值，这个值表示了在上升序列中第一个参数是否位于第二个参数之前。 如果comp返回true，sort根据返回值将第一个参数排在第二个参数前面； 如果comp返回false，sort根据返回值将第一个参数排在第二个参数后面。 本题中，当s1+s2 &lt; s2+s1时，s1应该排在s2前面，即排序结果能够使数据最小。 总结sort函数根据comp函数的返回值，对comp函数的两个参数排序：如果comp返回true，排序为 参数1、参数2，否则排序为 参数2、参数1。升序排列，则return para1para2]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>数组</tag>
        <tag>sort函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——二维数组中的查找]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。时间限制：1秒 空间限制：32768K 解题思路利用二维数组从上到下、从左到右递增的规律，选取右上角或左下角的元素a[i][j]与target比较： 当target小于元素a[i][j]时，那么target必定在元素a[i][j]所在行的左边，即j–； 当target大于元素a[i][j]时，那么target必定在元素a[i][j]所在列的下边，即i++。 1234567891011121314151617class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row=array.size(); int col=array[0].size(); int i=0,j=col-1;//坐标定在右上角 while( i&lt;row &amp;&amp; j&gt;=0)&#123; if(target==array[i][j]) return true; else if(target&lt;array[i][j]) j--;//遇小左移 else i++;//遇大下移 &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>数组</tag>
        <tag>元素查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——数组：为什么很多编程语言中数组都从0开始编号？]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前言在每一种编程语言中，基本都会有数组这种数据类型。但它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。大部分编程语言中，数组都是从0开始编号的，但你是否下意识的想过，为什么数组要从0开始编号，而不是从1开始呢？ 从1开始不是更符合人类的思维习惯吗？ 如何实现随机访问？数组(Array)是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。 接下来分两个角度来理解。 第一个是线性表 线性表就是数据拍成向一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈也是线性表结构。 与之对应的是非线性表 。如二叉树、堆、图等，在非线性表中，数据之间并不是简单的前后关系。 第二个是连续的内存空间和相同类型的数据。 因为这两个限制它才有了随机访问的特性，但也让数组的删除、插入变得非常低效，为了保证连续性，就需要做大量的数据搬移工作。 数组是如何实现根据下标随机访问数组元素的呢？拿一个长度为10的int类型的数组int[] a=new int[10]来举例。计算机给数组a分配一块连续内存空间1000-1039，其中内存块的首地址为base_address=1000。计算机通过地址来访问内存中的数据，当计算机需要访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：a[i]_address=base_address+i×data_type_size 面试的时候，经常会问数组和链表的区别，很多人回答说“链表适合插入删除，时间复杂度为O(1)；数组适合查找，查找时间为O(1)”。这种描述是不准确的。数组是适合查找，但是查找的时间复杂度并不为O(1).即使是排好序的数组，用二分查找，时间的复杂度也是O(logn)，所以正确的描述应该是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。 低效的插入和删除数组为了保证内存数据的连续性，会导致插入、删除操作比较低效。现在我们来讨论一下，究竟为什么会导致低效？又有哪些改进方法？ 插入操作假设数组长度为n，现在需要将一个数据插入到数组中的第k个位置，须将k~n这部分的元素都顺序的往后挪一位，平均情况时间复杂度为O(n)。如果数组中的数据是有序的，我们在某个位置插入一个新元素时，就必须安装刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，，在这种情况下，要将某个元素插入到第k个位置，为避免大规模的数据搬移，有一个简单的办法就是直接将第k为的数据搬移到数组元素的最后，把新的元素直接放到第k个位置。这种处理技巧，在特性场景下，在第k个位置插入一个元素的时间复杂度就会降到O(1)。这个处理思想在快排中也会用到。 删除操作和插入类似，如果删除数组末尾的数据，最好情况时间复杂度为O(1),如果删除开头的数据，则最坏情况时间复杂度为O(n),平均情况时间复杂度为O(n)。实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多！例如，数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在要依次删除a,b,c三个元素。为避免多次数据搬移，我们可以先记录下已经删除的数据。每次的删除操作并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 解答开篇问题从数组储存的内存模型来看，“下标”最确切的定义应该是“偏移”，根据前面讲到的寻址公式，如果数组从1开始计数，那么我们计算数组元素a[i]的内存地址就会变成： a[i]_address=base_address+i×data_type_size对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的操作，效率的优化就要尽可能做到极致。数组选择从0开始，而不是从1开始，最主要的原因可能是历史原因。## 相关思考题目### JVM的标记清楚垃圾回收算法的核心理念大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。不足：- 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时效率较高。- 空间问题。会产生不连续的内存空间碎片。### 二维数组的内存寻址公式假设二维数组大小为m*n,则a[i][j]的地址为：a[i][j]_address=base_address+(i×m+j)×data_type_size]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer——二进制中1的个数 & 整数中1出现的次数]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%89%91%E6%8C%87offer%2F%E5%89%91%E6%8C%87offer-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%20%26%20%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述：二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解法一基本思路： 先判断整数二进制表示中最右边是不是为1，如果是则计数器自增1；接着把输入的整数右移一位，继续判断二进制表示中最右边是否为1，直到整个数变为0为止。代码如下所示，case通过率0.00%，超时引起的，是因为如果输入的是负数，右移时，为保证移位后是一个负数，因此移位后的最高为会设1.如果一直做右移，那么这个数字最终会变为0xFFFFFFFF而陷入死循环。若n=n&gt;&gt;1;改为n/=2;通过率为55.56%，还没找到是什么原因？ 12345678910111213class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n)&#123; if(n&amp;1) res++; n=n&gt;&gt;1; &#125; return res; &#125;&#125;; 解法二基本思路： 为避免死循环，不右移输入的数字，而是定义一个无符号整型变量flag，让flag返回左移，与输入的数字进行与运算，如下：然鹅case通过率为11.11%，看书写的代码，我也不清楚为什么这样！！ 1234567891011121314class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; unsigned int flag=1; while(flag)&#123; if(n&amp;&amp;flag) res++; flag=flag&lt;&lt;1; &#125; return res; &#125;&#125;; 解法三基本思路： 这种解法就厉害了，整数的二进制表示中有几个1就执行几次循环，步骤：把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变为0. 123456789101112class Solution &#123;public: int NumberOf1(int n) &#123; int res=0; while(n)&#123; res++; n=(n-1)&amp;n; &#125; return res; &#125;&#125;; Tips:位运算左移右移计算机表示数字正负不是用+、-号来表示，而是用最高位数字来表示，0表示正，1表示负。 1.有符号右移&gt;&gt;（若正数，高位补0，若负数，高位补1）正数：4&gt;&gt;2 右移两位，高为补0(0000 0000 0000 0000 0000 0000 0000 0100)&gt;&gt;(000000 0000 0000 0000 0000 0000 0000 01)结果为1，即4/(2^2) 负数：-4&gt;&gt;2 (-4的二进制为4的原码取反再加1，如下)右移两位，高位补1(1111 1111 1111 1111 1111 1111 1111 1100)&gt;&gt;(1111 1111 1111 1111 1111 1111 1111 1111)根据上述得到的补码求出源码才是我们所求的结果，保留符号位，然后按位取反再加1，为(100000 0000 0000 0000 0000 0000 0000 01),结果为-1，即-4/(2^2)。 2.无符号右移&gt;&gt;&gt;(无论正负，高位均补0)正数：4&gt;&gt;&gt;2 与4&gt;&gt;2的运算结果相同，结果也是1 负数：-4&gt;&gt;&gt;2(1111 1111 1111 1111 1111 1111 1111 1100)&gt;&gt;&gt;(0011 1111 1111 1111 1111 1111 1111 1111)结果为1073741823 3.左移&lt;&lt;(不区分有符号和无符号)分析num&lt;&lt;n 相当于num(num的二进制)向左移动n位； 左边(高位)溢出部分直接舍弃；右边(低位)移入部分全部补0； 移位结果：若左移时舍弃的高位不包括1，则没左移一位，就相当于该数乘以2.(左移有可能导致符号变化) 题目描述：整数中1出现的次数求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 解法一：暴力解决累加1~n中每个正数1的个数。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int res=0; for(int i=1;i&lt;=n;i++)&#123; res+=numberOf1(i); &#125; return res; &#125;private: int numberOf1(unsigned int i)&#123; int res=0; while(i)&#123; if(i%10==1) res++; i/=10; &#125; return res; &#125;&#125;; 解法二：找规律1的数目： 如果第i位（自右至左，从1开始标号）上的数字为0，则第i位可能出现1的次数由更高位决定（若没有高位，视高位为0），等于更高位数字X当前位数的权重10^(i-1); 如果第i位上的数字为1，则第i位上可能出现1的次数不仅受更高位影响，还受低位影响（若没有低位，视低位为0），等于更高位数字X当前位数的权重10^i-1+（低位数字+1）; 如果第i位上的数字大于1，则第i位上可能出现1的次数仅由更高位决定（若没有高位，视高位为0），等于（更高位数字+1）X当前位数的权重10i-1。 X的数目：这里的X∈[1,9],因为X=0不符合下列规律，需单独计算。首先直到以下的规律： 从1-10，在它们的个位数中，任意的X都出现了1次； 从1-100，在它们的十位数中，任意的X都出现了10次； 从1-1000，在它们的百位数中，任意的X都出现了100次； 依次类推，从1-10^i,在他们的左边第二位(右数第i位)中，任意的X都出现了10^i-1次。 接下来以n=2593，X=5为例来解释如何得到数学公式。从1至2593中，数字 5 总计出现了 813 次，其中有 259 次出现在个位，260 次出现在十位，294 次出现在百位，0 次出现在千位。 首先是个位。从 1 至 2590 中，包含了 259 个 10，因此任意的 X 都出现了 259 次。最后剩余的三个数 2591, 2592 和 2593，因为它们最大的个位数字 3 &lt; X，因此不会包含任何 5。（也可以这么看，3&lt;X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字（259）X10^(1-1)=259）； 然后是十位。从 1 至 2500 中，包含了 25 个 100，因此任意的 X 都出现了 25×10=250 次。剩下的数字是从 2501 至 2593，它们最大的十位数字 9 &gt; X，因此会包含全部 10 个 5。最后总计 250 + 10 = 260。（也可以这么看，9&gt;X，则十位上可能出现的X的次数仅由更高位决定，等于更高位数字（25+1）X10^(2-1)=260）； 接下来是百位。从 1 至 2000 中，包含了 2 个 1000，因此任意的 X 都出现了 2×100=200 次。剩下的数字是从 2001 至 2593，它们最大的百位数字 5 == X，这时情况就略微复杂，它们的百位肯定是包含 5 的，但不会包含全部 100 个。如果把百位是 5 的数字列出来，是从 2500 至 2593，数字的个数与百位和十位数字相关，是 93+1 = 94。最后总计 200 + 94 = 294。（也可以这么看，5==X，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，等于更高位数字（2）X10^(3-1)+（93+1）=294）； 最后是千位。现在已经没有更高位，因此直接看最大的千位数字 2 &lt; X，所以不会包含任何 5。（也可以这么看，2&lt;X，则千位上可能出现的X的次数仅由更高位决定，等于更高位数字（0）X10^(4-1)=0）。 总结一下以上的算法，可以看到，当计算右数第 i 位包含的 X 的个数时： 取第 i 位左边（高位）的数字，乘以 10^i−1 ，得到基础值 a 。 取第 i 位数字，计算修正值： 如果大于 X，则结果为 a+ 10^i−1 。 如果小于 X，则结果为 a 。 如果等 X，则取第 i 位右边（低位）数字，设为 b ，最后结果为 a+b+1 。 相应的代码非常简单，效率也非常高，时间复杂度只有 O(log_10^n) 。 123456789101112131415161718192021222324class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int res=0; int high,low,tmp,cur,i=1; high=n; while(high)&#123; high=n/(int)pow(10,i);//求第i位的高位 tmp=n%(int)pow(10,i); cur=tmp/(int)pow(10,i-1);//求第i位的值 low=tmp%(int)pow(10,i-1);//求第i位的低位 if(cur==1) res+=high*(int)pow(10,i-1)+low+1; else if(cur&lt;1) res+=high*(int)pow(10,i-1); else res+=(high+1)*(int)pow(10,i-1); i++; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>牛客刷题</tag>
        <tag>二进制</tag>
        <tag>数1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法(一)]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[操作系统做了什么看不下去了！！！]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——复杂度分析]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据结构与算法概念理解从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。狭义上讲，就是指某些著名的数据结构和算法。 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、回溯算法、分治算法、动态规划、字符串匹配算法。 上面最常用、最基础的20个数据结构与算法，要学习它们的”来历”、”特点”、”适合解决什么问题”以及”实际的应用场景”。 下面放一张数据结构和算法的知识图谱：数据结构是为算法服务的，算法要作用在特定的数据结构之上。 那么接下来就开始学习一个数据结构与算法中最重要的概念——复杂度分析。 复杂度分析(上)——如何分析、统计算法的执行效率和资源消耗事后统计法把代码跑一边，通过统计、监控就能得到算法执行的时间和占用的内存大小。但是这种统计法有非常大的局限性。 测试结果非常依赖测试环境 测试结果受数据规模的影响很大，比如对同一个算法，待排序的数据有序度不一样，排序的时间会有河大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作执行时间非常短。此外，测试数据规模小，测试结果无法真实的反应算法的性能。比如对于小规模的数据排序，插入排序可能回避快排要块！ 大O表示法 大O时间复杂度表示法T(n)=O(f(n))其中T(n)表示代码执行的时间，n表示数据规模大小，f(n)表示每行代码执行的次数总和。公式中的O表示代码的执行时间T(n)与f(n)表达式成正比。 时间复杂度分析 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度示例分析对于复杂度量级，可以粗略的分为多项式量级 和非多项式量级 。如下图： O(1)代码执行的时间不随n的增大而增大。算法中不存在循环递归语句，即使有千万行代码，其时间复杂度也是O(1)。 O(logn)、O(nlogn) 1234int i=1;while(i&lt;=n)&#123; i*=2; &#125; 归并排序、快速排序的时间复杂度就是O(nlogn)。 O(m+n)、O(m*n)代码的复杂度由两个数据的规模来决定。 空间复杂度常见的空间复杂度就是O(1)、O(n)、O(n^2)。 复杂度分析(下)——浅析最好、最坏、平均、均摊时间复杂度最好、最坏时间复杂度例如，在一个无序数组中查找变量x。如果数组中第一个元素就是要查找的变量x，那就不需要遍历剩下的n-1个数据了，最好时间复杂度为O(1)。但如果数组中不存在x，那就要把数组遍历一遍，最坏时间复杂度为O(n)。 平均情况时间复杂度依然分析查找变量x的例子：要查找的变量x在数组中的位置，有n+1中情况：在数组的0~n-1为之中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后除以n+1，就可以得到需要遍历的元素个数的平均值。上面的推导存在一个问题就是没有把各种情况发生的概率考虑进去。假设变量x在或不在数组中的概率都为1/2，要查找的数据出现在0~n-1这n个位置的概率也是一样的，为1/n。 均摊时间复杂度 // array 表示一个长度为 n 的数组 // 代码中的 array.length 就等于 n int[] array = new int[n]; int count = 0; void insert(int val) { if (count == array.length) { int sum = 0; for (int i = 0; i &lt; array.length; ++i) { sum = sum + array[i]; } array[0] = sum; count = 1; } array[count] = val; ++count; } 假设数组的长度为n，根据数据插入的位置的不同，可以分为n种情况，每种情况的时间复杂度都是O(1)。此外还有一种额外的情况，就是在数组没有空间时间时插入一个数据，这时时间复杂度为O(n)。而且，这n+1种情况发生的概率一样，都是1/(n+1)。所以根据加权平均的计算方法，求得的平均时间复杂度就是：对于insert()函数来说，O(1)时间的插入和O(n)时间的插入出现的频率是非常有规律的，而且有一定的前后时序关系，一个O(n)插入之后紧跟着n-1个O(1)的插入操作，循环往复。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo及GitPage搭建博客]]></title>
    <url>%2F2019%2F03%2F20%2F%E4%BD%BF%E7%94%A8Hexo%E5%8F%8AGitPage%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面刚开始使用GitHub，看到别人在git上搭建的博客很简洁优美，简直就是一片净土，于是自己也来试试！在搭建的过程中遇到了一些问题，再此做个记录。也算是自己的第一篇文章 :) 1.概述Git Pages本来是用于介绍托管在GitHub上的项目，不过，由于它的空间免费稳定，非常适合搭建一个博客。也可以认为是用户编写的、托管在GitHub上的静态网页。目前有两大静态博客主流框架：Jekyll和hexo。但是看到网上很多人吹捧hexo，于是直接放弃Jekyll，开始了hexo+GitHub搭建博客的第一步（在搭建的过程中，发现使用jekyll很简单，等会儿会提到我是如何偶遇它的）。hexo是一个快速、简洁且高效的博客框架，使用markdown解析文章，使用Node.js渲染界面( Hexo Themes上有很多主题以及各种功能，可参考博客我的个人博客之旅：从jekyll到hexo)。 2.搭建步骤2.1环境准备 安装Node.js,用来安装博客框架、渲染主题等。 安装Git，用来下载主题、提交、部署文章等。 2.2安装Hexo运行git bash，执行下面第一条命令安装hexo，第二条用于检查hexo安装的版本,第三条用于初始化hexo，hexo会自动下载一些文件到这个目录，包括node_modules。 $ npm install -g hexo-cli $ hexo -v $ hexo init 2.3建站及本地测试找一个合适的文件夹新建所需文件,第一条在指定文件夹创建所需文件(并初始化)，第三条安装所需组件.第四条开启服务器，访问localhost:4000(默认端口4000，ctrl+c关闭server)即可体验。 $ hexo init myBlog $ cd myBlog $ npm install $ hexo S 在hexo文件夹下执行命令： hexo generate 或者 hexo g //生成静态页面至public目录,public文件夹内的内容是要提交到GitHub上的 hexo server 或 hexo s //开启预览访问端口(开启本地服务) 2.4主题下载和配置使用命令下载主题，然后修改myBlog文件夹下的_config.yml(网站的配置文件，等会儿和github关联时也会修改改配置)。 $ cd themes $ git init $ git clone https://github.com/iissnan/hexo-theme-next.git 2.5将hexo和Git Pages关联起来2.5.1准备工作 注册GitHub账号https://github.com/，并设置Git的user name和email 配置ssh-key 代码库的设置：创建名为 “用户名.github.io” 的仓库，星号表示用户名，创建好之后访问https://zuiing.github.io 即可。插曲：以前我建立过一个git网页博客，但是今天配置hexo时不成功就删除又建了一个，但是域名变为https://zuiing.github.io/zuiing.github.io，如果访问https://zuiing.github.io 出现下面的错误：表示域名已经能够解析到，但是还需要配置，进入仓库zuiing.github.io-&gt;Setting;我的操作是Rename一下，又点了Git Pages中的”Choose a theme”(在这里偶遇了yekyll)，然后就点开了下图中的网页博客链接,就神奇的好了，而且还有了主题，惊喜！ 2.5.2正式开始部署，即设置deployment npm install hexo-deployer-git –save 在网站配置文件 _config.yml中有关deploy部分：修改仓库地址,需要特别注意的是冒号后面一定要有一个空格，以及这里使用的是ssh协议而不是http协议(刚开始我使用的http协议，执行hexo d之后一直关联不成功，估计和协议有关系)，前提是确保在Github上已经添加了公钥。 执行 hexo d 即可发布到Github仓库，其实我的过程远不像上面写的那么简单，在经历了千辛万苦之后总算成功了，这简直就是今天最开心的事儿了！还有，有网友建议每次都按下面的执行顺序来： hexo clean hexo generate hexo deploy 新增或修改主题之后请执行 hexo clean &amp;&amp; hexo d 清理缓存文件并部署。 2.6未知我知道现在才成功了一步，自己对git和hexo的了解还非常少，继续探索啦啦啦，做一个努力的小仙女儿！！！2019/03/20更 3.上传md文件图片无法显示的坑(下面是填坑过程)3.1问题介绍在sourse文件夹下建了一个img文件夹用于存储md插入图片，生成并上传到git之后，发现图片被存在了’用户名.github.io/img’文件夹下,如下图 打开博客网页却看不到图片，肯定是因为生成的index.html格式的文件图片路径不对，导致在GitHub上找不到图片,于是开始网上找解决方案，大部分说辞都差不多，例如hexo博客图片问题### 3.2开始动手1. 确认_config.yml中的post_asset_folder:true；Hexo提供了一种方便管理Asset的设定post_asset_folder，当设置为true后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，可以把该文章相关的所有资源都放到那个文件夹，这样便可以更方便的使用资源。2. 在Hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save3. 安装完成后用hexo创建文章时会发现_posts目录下面会多出一个和文章名字一样的文件夹，图片就放文件夹内即可。4. 接下来是测试图片的过程，图片插入格式如下图：5. hexo g生成之后先去本地public文件夹下看看index.yml中的路径，如下图：真是活见鬼，刚刚测试的时候在index.yml中第一张的路径是要比第二张的路径多一个testImg的(src=”/2019/03/20/testImg/testImg/test.JPG”),现在却都一样，而且在md文档中第二种写法没法直接预览图片，既然这样就是用第一种插入方法吧，anyway，图片插入的问题算是解决了。6. 在博客上查看结果如下： 4.上传md文件格式杂乱 md文档在本地格式正常，但上传到git上就很乱糟糟，如图： 很奇怪的是当我搞好图片显示问题之后，这个问题就自动好了，但我觉得二者之间没太大联系，可能是网页更新显示太慢的原因，如下图： 在用md写文档或插入代码的时候总出错，这里有篇还不错的博文，可以学习下markdown的语法 Markdown语法你都会了吗？,以及在markDown中输入数学公式。 在操作的过程中总是会遇到各种怪象，太菜啦，要被自己蠢哭了 :( 插入图片时，图片所在目录不要有中文，不然本地的markdown都找不到在哪 markdown文档名字与文档中title的名字最好一致，不然上传到gitpages之后文档中的格式会消失，这个问题搞了好几天才发现！！！2019/03/20更 5.hexo next主题配置我的博客配置参考了这篇文章，写的非常详细，效果也很美！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Node</tag>
        <tag>hexo&amp;GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
