<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构与算法——数组：为什么很多编程语言中数组都从0开始编号？]]></title>
    <url>%2F2019%2F03%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[前言在每一种编程语言中，基本都会有数组这种数据类型。但它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。大部分编程语言中，数组都是从0开始编号的，但你是否下意识的想过，为什么数组要从0开始编号，而不是从1开始呢？ 从1开始不是更符合人类的思维习惯吗？ 如何实现随机访问？数组(Array)是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。 接下来分两个角度来理解。 第一个是线性表 线性表就是数据拍成向一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈也是线性表结构。 与之对应的是非线性表 。如二叉树、堆、图等，在非线性表中，数据之间并不是简单的前后关系。 第二个是连续的内存空间和相同类型的数据。 因为这两个限制它才有了随机访问的特性，但也让数组的删除、插入变得非常低效，为了保证连续性，就需要做大量的数据搬移工作。 数组是如何实现根据下标随机访问数组元素的呢？拿一个长度为10的int类型的数组int[] a=new int[10]来举例。计算机给数组a分配一块连续内存空间1000-1039，其中内存块的首地址为base_address=1000。计算机通过地址来访问内存中的数据，当计算机需要访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：a[i]_address=base_address+i×data_type_size 面试的时候，经常会问数组和链表的区别，很多人回答说“链表适合插入删除，时间复杂度为O(1)；数组适合查找，查找时间为O(1)”。这种描述是不准确的。数组是适合查找，但是查找的时间复杂度并不为O(1).即使是排好序的数组，用二分查找，时间的复杂度也是O(logn)，所以正确的描述应该是数组支持随机访问，根据下标随机访问的时间复杂度为O(1)。 低效的插入和删除数组为了保证内存数据的连续性，会导致插入、删除操作比较低效。现在我们来讨论一下，究竟为什么会导致低效？又有哪些改进方法？ 插入操作假设数组长度为n，现在需要将一个数据插入到数组中的第k个位置，须将k~n这部分的元素都顺序的往后挪一位，平均情况时间复杂度为O(n)。如果数组中的数据是有序的，我们在某个位置插入一个新元素时，就必须安装刚才的方法搬移k之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合，，在这种情况下，要将某个元素插入到第k个位置，为避免大规模的数据搬移，有一个简单的办法就是直接将第k为的数据搬移到数组元素的最后，把新的元素直接放到第k个位置。这种处理技巧，在特性场景下，在第k个位置插入一个元素的时间复杂度就会降到O(1)。这个处理思想在快排中也会用到。 删除操作和插入类似，如果删除数组末尾的数据，最好情况时间复杂度为O(1),如果删除开头的数据，则最坏情况时间复杂度为O(n),平均情况时间复杂度为O(n)。实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率就会提高很多！例如，数组a[10]中存储了8个元素：a,b,c,d,e,f,g,h。现在要依次删除a,b,c三个元素。为避免多次数据搬移，我们可以先记录下已经删除的数据。每次的删除操作并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。 解答开篇问题从数组储存的内存模型来看，“下标”最确切的定义应该是“偏移”，根据前面讲到的寻址公式，如果数组从1开始计数，那么我们计算数组元素a[i]的内存地址就会变成： a[i]_address=base_address+i×data_type_size对比两个公式，从1开始编号，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的操作，效率的优化就要尽可能做到极致。数组选择从0开始，而不是从1开始，最主要的原因可能是历史原因。## 相关思考题目### JVM的标记清楚垃圾回收算法的核心理念大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。不足：- 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时效率较高。- 空间问题。会产生不连续的内存空间碎片。### 二维数组的内存寻址公式假设二维数组大小为m*n,则a[i][j]的地址为：a[i][j]_address=base_address+(i×m+j)×data_type_size]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newCoder——把数组排成最小的数]]></title>
    <url>%2F2019%2F03%2F21%2FnewCoder%2FnewCoder-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。时间限制：1秒 空间限制：32768K 解题思路 将数组中的整数数组转换成字符串数组； 自定义一个比较大小的函数，比较两个字符串s1和s2大小的时候，先将它们拼起来，比较s1+s2和s2和s1哪个大，如果s1+s2大，说明s2应该放前面，根据这个规则将所有的字符换排序； 拼接所有的字符串数组中的元素。 123456789101112131415161718class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string res; vector&lt;string&gt; str; for(int i=0;i&lt;numbers.size();i++) str.push_back(to_string(numbers[i])); sort(str.begin(),str.end(),myCompare); for(int i=0;i&lt;str.size();i++) res+=str[i]; return res; &#125;private: static bool myCompare(string &amp;s1,string &amp;s2)&#123; return s1+s2 &lt; s2+s1; &#125;&#125;; tips：1. sort()函数的第三个参数自定义的比较函数返回值类型应该是static bool，不然会报错,但是在其他编译器中只要自定义函数返回的是bool类型的就可以了，没必要是静态函数。 ./solution.h:8:36: error: reference to non-static member function must be calledsort(str.begin(),str.end(),myCompare); 2. 深究STL的sort()函数以前在自定义比较函数时一直都有个疑问，当什么情况下会进行升序排列、什么情况下又进行降序排列呢？传入的两个参数应该如何进行比较？在这里推荐直接看C++技术文档 comp函数返回值：返回一个bool类型的值，这个值表示了在上升序列中第一个参数是否位于第二个参数之前。 如果comp返回true，sort根据返回值将第一个参数排在第二个参数前面； 如果comp返回false，sort根据返回值将第一个参数排在第二个参数后面。 本题中，当s1+s2 &lt; s2+s1时，s1应该排在s2前面，即排序结果能够使数据最小。 总结sort函数根据comp函数的返回值，对comp函数的两个参数排序：如果comp返回true，排序为 参数1、参数2，否则排序为 参数2、参数1。升序排列，则return para1para2]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>牛客刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[newCoder——二维数组中的查找]]></title>
    <url>%2F2019%2F03%2F21%2FnewCoder%2FnewCoder-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。时间限制：1秒 空间限制：32768K 解题思路利用二维数组从上到下、从左到右递增的规律，选取右上角或左下角的元素a[i][j]与target比较： 当target小于元素a[i][j]时，那么target必定在元素a[i][j]所在行的左边，即j–； 当target大于元素a[i][j]时，那么target必定在元素a[i][j]所在列的下边，即i++。 1234567891011121314151617class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; int row=array.size(); int col=array[0].size(); int i=0,j=col-1;//坐标定在右上角 while( i&lt;row &amp;&amp; j&gt;=0)&#123; if(target==array[i][j]) return true; else if(target&lt;array[i][j]) j--;//遇小左移 else i++;//遇大下移 &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>牛客刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法(一)]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[操作系统做了什么看不下去了！！！]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法——复杂度分析]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据结构与算法概念理解从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。狭义上讲，就是指某些著名的数据结构和算法。 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、回溯算法、分治算法、动态规划、字符串匹配算法。 上面最常用、最基础的20个数据结构与算法，要学习它们的”来历”、”特点”、”适合解决什么问题”以及”实际的应用场景”。 下面放一张数据结构和算法的知识图谱：数据结构是为算法服务的，算法要作用在特定的数据结构之上。 那么接下来就开始学习一个数据结构与算法中最重要的概念——复杂度分析。 复杂度分析(上)——如何分析、统计算法的执行效率和资源消耗事后统计法把代码跑一边，通过统计、监控就能得到算法执行的时间和占用的内存大小。但是这种统计法有非常大的局限性。 测试结果非常依赖测试环境 测试结果受数据规模的影响很大，比如对同一个算法，待排序的数据有序度不一样，排序的时间会有河大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作执行时间非常短。此外，测试数据规模小，测试结果无法真实的反应算法的性能。比如对于小规模的数据排序，插入排序可能回避快排要块！ 大O表示法 大O时间复杂度表示法T(n)=O(f(n))其中T(n)表示代码执行的时间，n表示数据规模大小，f(n)表示每行代码执行的次数总和。公式中的O表示代码的执行时间T(n)与f(n)表达式成正比。 时间复杂度分析 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度示例分析对于复杂度量级，可以粗略的分为多项式量级 和非多项式量级 。如下图： O(1)代码执行的时间不随n的增大而增大。算法中不存在循环递归语句，即使有千万行代码，其时间复杂度也是O(1)。 O(logn)、O(nlogn) 1234int i=1;while(i&lt;=n)&#123; i*=2; &#125; 归并排序、快速排序的时间复杂度就是O(nlogn)。 O(m+n)、O(m*n)代码的复杂度由两个数据的规模来决定。 空间复杂度常见的空间复杂度就是O(1)、O(n)、O(n^2)。 复杂度分析(下)——浅析最好、最坏、平均、均摊时间复杂度最好、最坏时间复杂度例如，在一个无序数组中查找变量x。如果数组中第一个元素就是要查找的变量x，那就不需要遍历剩下的n-1个数据了，最好时间复杂度为O(1)。但如果数组中不存在x，那就要把数组遍历一遍，最坏时间复杂度为O(n)。 平均情况时间复杂度依然分析查找变量x的例子：要查找的变量x在数组中的位置，有n+1中情况：在数组的0~n-1为之中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后除以n+1，就可以得到需要遍历的元素个数的平均值。上面的推导存在一个问题就是没有把各种情况发生的概率考虑进去。假设变量x在或不在数组中的概率都为1/2，要查找的数据出现在0~n-1这n个位置的概率也是一样的，为1/n。 均摊时间复杂度 // array 表示一个长度为 n 的数组 // 代码中的 array.length 就等于 n int[] array = new int[n]; int count = 0; void insert(int val) { if (count == array.length) { int sum = 0; for (int i = 0; i &lt; array.length; ++i) { sum = sum + array[i]; } array[0] = sum; count = 1; } array[count] = val; ++count; } 假设数组的长度为n，根据数据插入的位置的不同，可以分为n种情况，每种情况的时间复杂度都是O(1)。此外还有一种额外的情况，就是在数组没有空间时间时插入一个数据，这时时间复杂度为O(n)。而且，这n+1种情况发生的概率一样，都是1/(n+1)。所以根据加权平均的计算方法，求得的平均时间复杂度就是：对于insert()函数来说，O(1)时间的插入和O(n)时间的插入出现的频率是非常有规律的，而且有一定的前后时序关系，一个O(n)插入之后紧跟着n-1个O(1)的插入操作，循环往复。]]></content>
      <categories>
        <category>Struct&amp;Alogorithms</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>复杂度分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo & GitPage 搭建博客]]></title>
    <url>%2F2019%2F03%2F20%2FmyFirstBlog%2F</url>
    <content type="text"><![CDATA[写在前面刚开始使用GitHub，看到别人在git上搭建的博客很简洁优美，简直就是一片净土，于是自己也来试试！在搭建的过程中遇到了一些问题，再此做个记录。也算是自己的第一篇文章 :) 概述Git Pages本来是用于介绍托管在GitHub上的项目，不过，由于它的空间免费稳定，非常适合搭建一个博客。也可以认为是用户编写的、托管在GitHub上的静态网页。目前有两大静态博客主流框架：Jekyll和hexo。但是看到网上很多人吹捧hexo，于是直接放弃Jekyll，开始了hexo+GitHub搭建博客的第一步（在搭建的过程中，发现使用jekyll很简单，等会儿会提到我是如何偶遇它的）。hexo是一个快速、简洁且高效的博客框架，使用markdown解析文章，使用Node.js渲染界面( Hexo Themes上有很多主题以及各种功能，可参考博客我的个人博客之旅：从jekyll到hexo)。 搭建步骤1.环境准备 安装Node.js,用来安装博客框架、渲染主题等。 安装Git，用来下载主题、提交、部署文章等。 2.安装Hexo运行git bash，执行下面第一条命令安装hexo，第二条用于检查hexo安装的版本,第三条用于初始化hexo，hexo会自动下载一些文件到这个目录，包括node_modules。 $ npm install -g hexo-cli $ hexo -v $ hexo init 3.建站及本地测试找一个合适的文件夹新建所需文件,第一条在指定文件夹创建所需文件(并初始化)，第三条安装所需组件.第四条开启服务器，访问localhost:4000(默认端口4000，ctrl+c关闭server)即可体验。 $ hexo init myBlog $ cd myBlog $ npm install $ hexo S 在hexo文件夹下执行命令： hexo generate 或者 hexo g //生成静态页面至public目录,public文件夹内的内容是要提交到GitHub上的 hexo server 或 hexo s //开启预览访问端口(开启本地服务) 4.主题下载和配置使用命令下载主题，然后修改myBlog文件夹下的_config.yml(网站的配置文件，等会儿和github关联时也会修改改配置)。 $ cd themes $ git init $ git clone https://github.com/iissnan/hexo-theme-next.git 5.将hexo和Git Pages关联起来5.1准备工作 注册GitHub账号https://github.com/，并设置Git的user name和email 配置ssh-key 代码库的设置：创建名为 “用户名.github.io” 的仓库，星号表示用户名，创建好之后访问https://zuiing.github.io 即可。插曲：以前我建立过一个git网页博客，但是今天配置hexo时不成功就删除又建了一个，但是域名变为https://zuiing.github.io/zuiing.github.io，如果访问https://zuiing.github.io 出现下面的错误：表示域名已经能够解析到，但是还需要配置，进入仓库zuiing.github.io-&gt;Setting;我的操作是Rename一下，又点了Git Pages中的”Choose a theme”(在这里偶遇了yekyll)，然后就点开了下图中的网页博客链接,就神奇的好了，而且还有了主题，惊喜！ 5.2正式开始部署，即设置deployment npm install hexo-deployer-git –save 在网站配置文件 _config.yml中有关deploy部分：修改仓库地址,需要特别注意的是冒号后面一定要有一个空格，以及这里使用的是ssh协议而不是http协议(刚开始我使用的http协议，执行hexo d之后一直关联不成功，估计和协议有关系)，前提是确保在Github上已经添加了公钥。 执行 hexo d 即可发布到Github仓库，其实我的过程远不像上面写的那么简单，在经历了千辛万苦之后总算成功了，这简直就是今天最开心的事儿了！还有，有网友建议每次都按下面的执行顺序来： hexo clean hexo generate hexo deploy 新增或修改主题之后请执行 hexo clean &amp;&amp; hexo d 清理缓存文件并部署。 6.未知我知道现在才成功了一步，自己对git和hexo的了解还非常少，继续探索啦啦啦，做一个努力的小仙女儿！！！2019/03/20更 7.上传md文件图片无法显示的坑(下面是填坑过程)7.1问题介绍在sourse文件夹下建了一个img文件夹用于存储md插入图片，生成并上传到git之后，发现图片被存在了’用户名.github.io/img’文件夹下,如下图 打开博客网页却看不到图片，肯定是因为生成的index.html格式的文件图片路径不对，导致在GitHub上找不到图片,于是开始网上找解决方案，大部分说辞都差不多，例如hexo博客图片问题。#### 7.2开始动手1. 确认_config.yml中的post_asset_folder:true；Hexo提供了一种方便管理Asset的设定post_asset_folder，当设置为true后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，可以把该文章相关的所有资源都放到那个文件夹，这样便可以更方便的使用资源。2. 在Hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image –save3. 安装完成后用hexo创建文章时会发现_posts目录下面会多出一个和文章名字一样的文件夹，图片就放文件夹内即可。4. 接下来是测试图片的过程，图片插入格式如下图：5. hexo g生成之后先去本地public文件夹下看看index.yml中的路径，如下图：真是活见鬼，刚刚测试的时候在index.yml中第一张的路径是要比第二张的路径多一个testImg的(src=”/2019/03/20/testImg/testImg/test.JPG”),现在却都一样，而且在md文档中第二种写法没法直接预览图片，既然这样就是用第一种插入方法吧，anyway，图片插入的问题算是解决了。6. 在博客上查看结果如下： 8.上传md文件格式杂乱 md文档在本地格式正常，但上传到git上就很乱糟糟，如图： 很奇怪的是当我搞好图片显示问题之后，这个问题就自动好了，但我觉得二者之间没太大联系，可能是网页更新显示太慢的原因，如下图： 在用md写文档或插入代码的时候总出错，这里有篇还不错的博文，可以学习下markdown的语法 Markdown语法你都会了吗？,以及在markDown中输入数学公式。 在操作的过程中总是会遇到各种怪象，太菜啦，要被自己蠢哭了 :(2019/03/20更]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>hexo&amp;GitPage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
</search>
